import { BBox, Vector, VectorType, SplineCurveOptions, CurveMapper } from './core/interfaces';
export interface CurveInterpolatorOptions extends SplineCurveOptions {
    arcDivisions?: number;
    numericalApproximationOrder?: number;
    numericalInverseSamples?: number;
    lmargin?: number;
}
/**
 * Cubic curve interpolator
 */
export default class CurveInterpolator {
    _lmargin: number;
    _curveMapper: CurveMapper;
    _cache: Map<string, object>;
    /**
     * Create a new interpolator instance
     * @param points control points
     * @param options curve interpolator options
     */
    constructor(points: Vector[], options?: CurveInterpolatorOptions);
    /**
     * Returns the time on curve at a position, given as a value between 0 and 1
     * @param position position on curve (0..1)
     * @param clampInput whether the input value should be clamped to a valid range or not
     */
    getTimeFromPosition(position: number, clampInput?: boolean): number;
    /**
     * Returns the normalized position u for a normalized time value t
     * @param t time on curve (0..1)
     * @param clampInput whether the input value should be clamped to a valid range or not
     * @returns position (u)
     */
    getPositionFromTime(t: number, clampInput?: boolean): number;
    /**
     * Returns the normalized position u for the specified length
     * @param t time on curve (0..1)
     * @param clampInput whether the input value should be clamped to a valid range or not
     * @returns position (u)
     */
    getPositionFromLength(length: number, clampInput?: boolean): number;
    /**
     *
     * @param position position on curve (0..1)
     * @returns length from start to position
     */
    getLengthAt(position?: number, clampInput?: boolean): number;
    /**
     * Returns the time (t) of the knot at the specified index
     * @param index index of knot (control/input point)
     * @returns time (t)
     */
    getTimeAtKnot(index: number): number;
    /**
     * Returns the position (u) of the knot at the specified index
     * @param index index of knot (control/input point)
     * @returns position (u)
     */
    getPositionAtKnot(index: number): number;
    /**
     * Get the point along the curve corresponding to the value of t (time along curve)
     * This function is only useful when you need to address the curve by time, where time
     * will vary depending on segment length and curvature. To address the curve normalized
     * for length (constant speed and uniform spacing), use the getPointAt function instead.
     * @param t time along full curve (encodes segment index and segment t)
     * @param target optional target vector
     * @returns position as vector
     */
    getPointAtTime(t: number, target?: VectorType): Vector;
    /**
     * Interpolate a point at the given position.
     * @param position position on curve (0..1)
     * @param target optional target
     */
    getPointAt<T extends VectorType>(position: number, target: T): T;
    getPointAt(position: number): Vector;
    /**
     * Get the tangent at the given position.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getTangentAt<T extends VectorType>(position: number, target: T): T;
    getTangentAt(position: number): Vector;
    /**
     * Get the tangent at the given time.
     * @param t time at curve (0 - 1)
     * @param target optional target
     */
    getTangentAtTime<T extends VectorType>(t: number, target: T): T;
    getTangentAtTime(t: number): Vector;
    /**
     * Get the normal for 2D or 3D curve at the given position. In 3D the normal
     * points towards the center of the curvature.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getNormalAt<T extends VectorType>(position: number, target: T): T;
    getNormalAt(position: number): Vector;
    /**
     * Get the normal for 2D or 3D curve at the given time (t). In 3D the normal
     * points towards the center of the curvature.
     * @param t time at curve (0 - 1)
     * @param target optional target
     */
    getNormalAtTime<T extends VectorType>(t: number, target: T): T;
    getNormalAtTime(t: number): Vector;
    /**
     * Calculate the Frenet-Serret frames for a 3d curve, using the concept of parallel transport.
     * The implementation used here is basically a copy of the function used in THREE.js (https://github.com/mrdoob/three.js),
     * which in turn is based on the the paper "Parallel Transport Approach to Curve Framing" by Hanson and Ma
     * (https://legacy.cs.indiana.edu/ftp/techreports/TR425.pdf)
     *
     * In the case of 2d, the normals are rotated 90 degrees counter-clockwise from the tangents and the binormals are omitted.
     * @param segments number of samples (segments) along the curve (will return segments + 1 frames)
     * @returns object containing arrays for tangents, normals and binormals if applicable
     */
    getFrenetFrames(segments: number): {
        tangents: Vector[];
        normals: Vector[];
        binormals?: Vector[];
    };
    /**
     * Finds the curvature and radius at the specified position (0..1) on the curve. The unsigned curvature
     * is returned along with radius, tangent vector and, for 2D and 3D curves, a direction vector is included
     * (which points toward the center of the curvature).
     * @param position position on curve (0 - 1)
     * @returns object containing the unsigned curvature, radius + tangent and direction vectors
     */
    getCurvatureAt(position: number): {
        curvature: number;
        radius: number;
        tangent: Vector;
        direction: Vector;
    };
    /**
     * Finds the curvature and radius at the specified time (0..1) on the curve. The unsigned curvature
     * is returned along with radius, tangent vector and, for 2D and 3D curves, a direction vector is included
     * (which points toward the center of the curvature).
     * @param t time (t) along curve (0 - 1)
     * @returns object containing the unsigned curvature, radius + tangent and direction vectors
     */
    getCurvatureAtTime(t: number): {
        curvature: number;
        radius: number;
        tangent: Vector;
        direction: Vector;
    };
    /**
     * Get the derivative at the given position.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getDerivativeAt<T extends VectorType>(position: number, target: T): T;
    getDerivativeAt(position: number): Vector;
    /**
     * Get the second derivative at the given position.
     * @param position position on curve (0 - 1)
     * @param target optional target
     */
    getSecondDerivativeAt<T extends VectorType>(position: number, target: T): T;
    getSecondDerivativeAt(position: number): Vector;
    /**
     * Get a bounding box for the curve or the segment given by the
     * from and to parameters
     * @param from position from
     * @param to position to
     */
    getBoundingBox(from?: number, to?: number): BBox;
    /**
     * Get uniformly sampled points along the curve. Returns samples + 1 points.
     * @param segments number of samples (segments)
     * @param returnType optional return type
     * @param from start at position
     * @param to end at position
     */
    getPoints<T extends VectorType>(segments: number, returnType: {
        new (): T;
    }): T[];
    getPoints<T extends VectorType>(segments: number, returnType: {
        new (): T;
    }, from: number): T[];
    getPoints<T extends VectorType>(segments: number, returnType: {
        new (): T;
    }, from: number, to: number): T[];
    getPoints(): any;
    getPoints(segments: number): any;
    getPoints(segments: number, returnType: null, from: number, to: number): Vector[];
    /**
     * Get the nearest position on the curve from a point. This is an approximation and its
     * accuracy is determined by the threshold value (smaller number requires more passes but is more precise)
     * @param point Vector
     * @param threshold Precision
     * @returns Object with position (u), distance and the point at u/t
     */
    getNearestPosition(point: Vector, threshold?: number, samples?: number): {
        u: number;
        point: Vector;
        distance: number;
    };
    /**
    * Find points on the curve intersecting a specific value along a given axis. The axis is given as
    * an index from 0 - n, i.e. 0 = x-axis, 1 = y-axis, 2 = z-axis etc.
    *
    * The max parameter is used to specify the maximum number of solutions you want returned, where max=0
    * returns all solutions and a negative number will return the max number of solutions starting from
    * the end of the curve and a positive number starting from the beginning of the curve. Note that If
    * max = 1 or -1, this function returns the point (unwrapped) or null if no intersects exist. In any
    * other case an array will be returned, regardless of there's multiple, a single or no solutions.
    * @param v lookup value
    * @param axis index of axis [0=x, 1=y, 2=z ...]
    * @param max max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)
    */
    getIntersects(v: number, axis?: number, max?: number, margin?: number): Vector[] | Vector;
    /**
     * Find positions (0-1) on the curve intersected by the given value along a given axis
     * @param v lookup value
     * @param axis index of axis [0=x, 1=y, 2=z ...]
     * @param max max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)
     */
    getIntersectsAsPositions(v: number, axis?: number, max?: number, margin?: number): number[];
    /**
     * Find intersects as time (0-1) on the curve intersected by the given value along a given axis
     * @param v lookup value
     * @param axis index of axis [0=x, 1=y, 2=z ...]
     * @param max max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)
     */
    getIntersectsAsTime(v: number, axis?: number, max?: number, margin?: number): number[];
    /**
     * Create and cache a lookup table of n=samples points, indexed by position (u)
     * @param func function generating lookup table value
     * @param samples number of samples (segments)
     * @param options object of \{ from, to, cacheKey \} - if cacheKey is included, the map will be stored in the internal cache
     * @returns Map of positions -> points
     */
    createLookupTable<T>(func: (u: number) => T, samples: number, options?: {
        from?: number;
        to?: number;
        cacheKey?: string;
        cacheForceUpdate?: boolean;
    }): Map<number, T>;
    /**
     * Convenience function for iterating over multiple values for a set of samples along the curve.
     * The forEach function takes a user defined callback function, which will be called for each position
     * along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)
     * @param func callback function
     * @param samples number of (evenly spaced) samples OR an array of user specified positions (u)
     * @param from from position
     * @param to to position
     * @returns array of mapped objects
     */
    forEach<T>(func: ({ u, t, i, prev }: {
        u: any;
        t: any;
        i: any;
        prev: any;
    }) => T, samples: (number | number[]), from?: number, to?: number): void;
    /**
     * Convenience function for returning multiple values for a set of samples along the curve.
     * The map function takes a user defined mapping function, which will be called for each position
     * along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)
     * @param func mapping function
     * @param samples number of (evenly spaced) samples OR an array of user specified positions (u)
     * @param from from position
     * @param to to position
     * @returns array of mapped objects
     */
    map<T>(func: ({ u, t, i, prev }: {
        u: any;
        t: any;
        i: any;
        prev: any;
    }) => T, samples: (number | number[]), from?: number, to?: number): T[];
    /**
     * Convenience function for reducing multiple values for a set of samples along the curve.
     * This function takes a user defined reduce function, which will be called for each position
     * along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)
     * @param func reduce function
     * @param initialValue initial accumulator value
     * @param samples number of (evenly spaced) samples OR an array of user specified positions (u)
     * @param from from position
     * @param to to position
     * @returns array of mapped objects
     */
    reduce<T>(func: ({ acc, u, t, i }: {
        acc: any;
        u: any;
        t: any;
        i: any;
    }) => T, initialValue: T, samples: (number | number[]), from?: number, to?: number): T;
    /**
     * Invalidates/clears cache
     */
    private _invalidateCache;
    /**
     * Reset any pre-calculated/cached data
     */
    reset(): void;
    get points(): Vector[];
    set points(pts: Vector[]);
    get tension(): number;
    set tension(t: number);
    get alpha(): number;
    set alpha(a: number);
    get closed(): boolean;
    set closed(isClosed: boolean);
    get length(): number;
    get minX(): number;
    get maxX(): number;
    get minY(): number;
    get maxY(): number;
    get minZ(): number;
    get maxZ(): number;
    get dim(): number;
}

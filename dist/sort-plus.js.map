{
  "version": 3,
  "sources": ["../node_modules/fp-ts/lib/function.js", "../node_modules/fp-ts/lib/Functor.js", "../node_modules/fp-ts/lib/Const.js", "../node_modules/fp-ts/lib/internal.js", "../node_modules/fp-ts/lib/Apply.js", "../node_modules/fp-ts/lib/Chain.js", "../node_modules/fp-ts/lib/pipeable.js", "../node_modules/fp-ts/lib/Eq.js", "../node_modules/fp-ts/lib/FromEither.js", "../node_modules/fp-ts/lib/number.js", "../node_modules/fp-ts/lib/Ord.js", "../node_modules/fp-ts/lib/Magma.js", "../node_modules/fp-ts/lib/Semigroup.js", "../node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/lib/Separated.js", "../node_modules/fp-ts/lib/Witherable.js", "../node_modules/fp-ts/lib/Zero.js", "../node_modules/fp-ts/lib/ReadonlyArray.js", "../node_modules/fp-ts/lib/string.js", "../node_modules/fp-ts/lib/ReadonlyRecord.js", "../node_modules/fp-ts/lib/Applicative.js", "../node_modules/fp-ts/lib/Predicate.js", "../node_modules/fp-ts/lib/Option.js", "../node_modules/fp-ts/lib/ChainRec.js", "../node_modules/fp-ts/lib/Either.js", "../node_modules/monocle-ts/lib/internal.js", "../node_modules/monocle-ts/lib/Traversal.js", "../node_modules/monocle-ts/lib/Lens.js", "../node_modules/monocle-ts/lib/Optional.js", "../node_modules/spectacles-ts/dist/util/monocle.js", "../node_modules/spectacles-ts/dist/values/get.js", "../node_modules/spectacles-ts/dist/values/set.js", "../node_modules/spectacles-ts/dist/values/setOption.js", "../node_modules/spectacles-ts/dist/values/modify.js", "../node_modules/spectacles-ts/dist/values/modifyOption.js", "../node_modules/spectacles-ts/dist/values/modifyW.js", "../node_modules/spectacles-ts/dist/values/modifyOptionW.js", "../node_modules/spectacles-ts/dist/values/modifyF.js", "../node_modules/spectacles-ts/dist/values/upsert.js", "../node_modules/spectacles-ts/dist/values/remove.js", "../node_modules/spectacles-ts/dist/values/rename.js", "../node_modules/spectacles-ts/dist/index.js", "react", "react-dom", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/function.js", "../node_modules/fp-ts/es6/internal.js", "../node_modules/fp-ts/es6/internal.js", "../node_modules/fp-ts/es6/internal.js", "../node_modules/fp-ts/es6/Apply.js", "../node_modules/fp-ts/es6/Functor.js", "../node_modules/fp-ts/es6/Functor.js", "../node_modules/fp-ts/es6/Applicative.js", "../node_modules/fp-ts/es6/Chain.js", "../node_modules/fp-ts/es6/FromEither.js", "../node_modules/fp-ts/es6/FromEither.js", "../node_modules/fp-ts/es6/Eq.js", "../node_modules/fp-ts/es6/Ord.js", "../node_modules/fp-ts/es6/Magma.js", "../node_modules/fp-ts/es6/Semigroup.js", "../node_modules/fp-ts/es6/Semigroup.js", "../node_modules/fp-ts/es6/Semigroup.js", "../node_modules/fp-ts/es6/Semigroup.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/NonEmptyArray.js", "../node_modules/fp-ts/es6/number.js", "../node_modules/fp-ts/es6/Separated.js", "../node_modules/fp-ts/es6/Witherable.js", "../node_modules/fp-ts/es6/Zero.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/ReadonlyArray.js", "../node_modules/fp-ts/es6/Array.js", "../node_modules/fp-ts/es6/Array.js", "../node_modules/fp-ts/es6/Predicate.js", "../node_modules/fp-ts/es6/Predicate.js", "../node_modules/fp-ts/es6/Option.js", "../node_modules/fp-ts/es6/Option.js", "../node_modules/fp-ts/es6/Const.js", "../node_modules/fp-ts/es6/Const.js", "../node_modules/fp-ts/es6/Const.js", "../node_modules/fp-ts/es6/Const.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Either.js", "../node_modules/fp-ts/es6/Endomorphism.js", "../node_modules/fp-ts/es6/FromIO.js", "../node_modules/fp-ts/es6/FromIO.js", "../node_modules/fp-ts/es6/ReadonlyMap.js", "../node_modules/fp-ts/es6/Map.js", "../node_modules/fp-ts/es6/Monoid.js", "../node_modules/fp-ts/es6/Monoid.js", "../node_modules/fp-ts/es6/Monoid.js", "../node_modules/fp-ts/es6/pipeable.js", "../node_modules/fp-ts/es6/Task.js", "../node_modules/fp-ts/es6/Task.js", "../node_modules/fp-ts/es6/string.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/ReadonlyRecord.js", "../node_modules/fp-ts/es6/Record.js", "../node_modules/fp-ts/es6/Record.js", "../node_modules/fp-ts/es6/Record.js", "../node_modules/fp-ts/es6/Record.js", "../node_modules/fp-ts/es6/Record.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Function.js", "../node_modules/fp-ts-std/dist/esm/Predicate.js", "../node_modules/fp-ts-std/dist/esm/Record.js", "../node_modules/monocle-ts/es6/internal.js", "../node_modules/monocle-ts/es6/At.js", "../node_modules/monocle-ts/es6/Iso.js", "../node_modules/monocle-ts/es6/Iso.js", "../node_modules/monocle-ts/es6/Iso.js", "../node_modules/monocle-ts/es6/Iso.js", "../node_modules/monocle-ts/es6/Ix.js", "../node_modules/monocle-ts/es6/Lens.js", "../node_modules/monocle-ts/es6/Optional.js", "../node_modules/monocle-ts/es6/Optional.js", "../node_modules/monocle-ts/es6/Optional.js", "../node_modules/monocle-ts/es6/Optional.js", "../node_modules/monocle-ts/es6/Optional.js", "../node_modules/monocle-ts/es6/Prism.js", "../node_modules/monocle-ts/es6/Prism.js", "../node_modules/monocle-ts/es6/Prism.js", "../node_modules/monocle-ts/es6/Prism.js", "../node_modules/monocle-ts/es6/Traversal.js", "../node_modules/monocle-ts/es6/Traversal.js", "../node_modules/monocle-ts/es6/Traversal.js", "../node_modules/monocle-ts/es6/Traversal.js", "../node_modules/monocle-ts/es6/Traversal.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../node_modules/monocle-ts/es6/index.js", "../extensions/sort-plus/app.tsx", "../shared/fp.tsx", "../shared/fp.tsx", "../shared/util.tsx", "../shared/util.tsx", "../shared/util.tsx", "../shared/util.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/api.tsx", "../shared/parse.tsx", "../shared/settings.tsx", "../shared/settings.tsx", "../extensions/sort-plus/settings.tsx", "../extensions/sort-plus/app.tsx"],
  "sourcesContent": [
    "\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dual = exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\nexports.getBooleanAlgebra = getBooleanAlgebra;\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\nexports.getSemigroup = getSemigroup;\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getMonoid = function (M) {\n    var getSemigroupM = (0, exports.getSemigroup)(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\nexports.getSemiring = getSemiring;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getRing = function (R) {\n    var S = (0, exports.getSemiring)(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\nexports.getRing = getRing;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\nexports.apply = apply;\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\nexports.identity = identity;\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\nexports.constant = constant;\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexports.constTrue = constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexports.constFalse = constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexports.constNull = constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexports.constUndefined = constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexports.constVoid = exports.constUndefined;\nfunction flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexports.flip = flip;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\nexports.flow = flow;\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\nexports.tuple = tuple;\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\nexports.increment = increment;\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\nexports.decrement = decrement;\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\nexports.tupled = tupled;\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexports.untupled = untupled;\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\nexports.pipe = pipe;\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexports.hole = absurd;\n/**\n * @since 2.11.0\n */\nvar SK = function (_, b) { return b; };\nexports.SK = SK;\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\nexports.not = not;\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n/** @internal */\nvar dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\nexports.dual = dual;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asUnit = exports.as = exports.getFunctorComposition = exports.let = exports.bindTo = exports.flap = exports.map = void 0;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nfunction map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexports.map = map;\nfunction flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexports.flap = flap;\nfunction bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nexports.bindTo = bindTo;\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexports.let = let_;\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return (0, function_1.pipe)(fga, _map(f)); }\n    };\n}\nexports.getFunctorComposition = getFunctorComposition;\n/** @internal */\nfunction as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\nexports.as = as;\n/** @internal */\nfunction asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\nexports.asUnit = asUnit;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.const_ = exports.Bifunctor = exports.Contravariant = exports.flap = exports.Functor = exports.URI = exports.mapLeft = exports.bimap = exports.map = exports.contramap = exports.getApplicative = exports.getApply = exports.getBooleanAlgebra = exports.getHeytingAlgebra = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBounded = exports.getOrd = exports.getEq = exports.getShow = exports.make = void 0;\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\n/**\n * @category constructors\n * @since 2.0.0\n */\nexports.make = function_1.unsafeCoerce;\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getShow(S) {\n    return {\n        show: function (c) { return \"make(\".concat(S.show(c), \")\"); }\n    };\n}\nexports.getShow = getShow;\n/**\n * @category instances\n * @since 2.0.0\n */\nexports.getEq = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getOrd = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getBounded = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getSemigroup = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getMonoid = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getSemiring = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getRing = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getHeytingAlgebra = function_1.identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexports.getBooleanAlgebra = function_1.identity;\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getApply(S) {\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return (0, exports.make)(S.concat(fab, fa)); }\n    };\n}\nexports.getApply = getApply;\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getApplicative(M) {\n    var A = getApply(M);\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: A.map,\n        ap: A.ap,\n        of: function () { return (0, exports.make)(M.empty); }\n    };\n}\nexports.getApplicative = getApplicative;\nvar _contramap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\n/**\n * @since 2.0.0\n */\nvar contramap = function () { return function_1.unsafeCoerce; };\nexports.contramap = contramap;\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nvar map = function () { return function_1.unsafeCoerce; };\nexports.map = map;\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.6.2\n */\nvar bimap = function (f) { return function (fa) {\n    return (0, exports.make)(f(fa));\n}; };\nexports.bimap = bimap;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.6.2\n */\nvar mapLeft = function (f) { return function (fa) { return (0, exports.make)(f(fa)); }; };\nexports.mapLeft = mapLeft;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Const';\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: _contramap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `C.Functor` instead of `C.const_`\n * (where `C` is from `import C from 'fp-ts/Const'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.const_ = {\n    URI: exports.URI,\n    map: _map,\n    contramap: _contramap,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n",
  "\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n/** @internal */\nvar isSome = function (fa) { return fa._tag === 'Some'; };\nexports.isSome = isSome;\n/** @internal */\nexports.none = { _tag: 'None' };\n/** @internal */\nvar some = function (a) { return ({ _tag: 'Some', value: a }); };\nexports.some = some;\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isLeft = function (ma) { return ma._tag === 'Left'; };\nexports.isLeft = isLeft;\n/** @internal */\nvar isRight = function (ma) { return ma._tag === 'Right'; };\nexports.isRight = isRight;\n/** @internal */\nvar left = function (e) { return ({ _tag: 'Left', left: e }); };\nexports.left = left;\n/** @internal */\nvar right = function (a) { return ({ _tag: 'Right', right: a }); };\nexports.right = right;\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar singleton = function (a) { return [a]; };\nexports.singleton = singleton;\n/** @internal */\nvar isNonEmpty = function (as) { return as.length > 0; };\nexports.isNonEmpty = isNonEmpty;\n/** @internal */\nvar head = function (as) { return as[0]; };\nexports.head = head;\n/** @internal */\nvar tail = function (as) { return as.slice(1); };\nexports.tail = tail;\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.emptyReadonlyArray = [];\n/** @internal */\nexports.emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\nexports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;\n/** @internal */\nvar liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));\n        };\n    };\n};\nexports.liftNullable = liftNullable;\n/** @internal */\nvar liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));\n        };\n    };\n};\nexports.liftOption = liftOption;\n/** @internal */\nvar flatMapNullable = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(3, function (self, f, onNullable) {\n        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));\n    });\n};\nexports.flatMapNullable = flatMapNullable;\n/** @internal */\nvar flatMapOption = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(3, function (self, f, onNone) { return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone)); });\n};\nexports.flatMapOption = flatMapOption;\n/** @internal */\nvar flatMapEither = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\nexports.flatMapEither = flatMapEither;\n/** @internal */\nvar flatMapIO = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\nexports.flatMapIO = flatMapIO;\n/** @internal */\nvar flatMapTask = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\nexports.flatMapTask = flatMapTask;\n/** @internal */\nvar flatMapReader = function (F, M) {\n    /*#__PURE__*/ return (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\nexports.flatMapReader = flatMapReader;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;\n/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nvar _ = __importStar(require(\"./internal\"));\nfunction ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexports.ap = ap;\nfunction apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexports.apFirst = apFirst;\nfunction apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexports.apSecond = apSecond;\nfunction apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexports.apS = apS;\nfunction getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nexports.getApplySemigroup = getApplySemigroup;\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nfunction sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nexports.sequenceT = sequenceT;\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nfunction sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\nexports.sequenceS = sequenceS;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bind = exports.tap = exports.chainFirst = void 0;\nfunction chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\nexports.chainFirst = chainFirst;\n/** @internal */\nfunction tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexports.tap = tap;\nfunction bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\nexports.bind = bind;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pipe = exports.pipeable = exports.compose = exports.promap = exports.partitionMapWithIndex = exports.partitionWithIndex = exports.filterMapWithIndex = exports.filterWithIndex = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.alt = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.reduceRight = exports.foldMap = exports.reduce = exports.extend = exports.mapLeft = exports.bimap = exports.chain = exports.ap = exports.mapWithIndex = exports.contramap = exports.map = void 0;\nvar Apply_1 = require(\"./Apply\");\nvar Chain_1 = require(\"./Chain\");\nvar function_1 = require(\"./function\");\nfunction map(F) {\n    return function (f) { return function (fa) { return F.map(fa, f); }; };\n}\nexports.map = map;\nfunction contramap(F) {\n    return function (f) { return function (fa) { return F.contramap(fa, f); }; };\n}\nexports.contramap = contramap;\nfunction mapWithIndex(F) {\n    return function (f) { return function (fa) { return F.mapWithIndex(fa, f); }; };\n}\nexports.mapWithIndex = mapWithIndex;\nfunction ap(F) {\n    return function (fa) { return function (fab) { return F.ap(fab, fa); }; };\n}\nexports.ap = ap;\nfunction chain(F) {\n    return function (f) { return function (fa) { return F.chain(fa, f); }; };\n}\nexports.chain = chain;\nfunction bimap(F) {\n    return function (f, g) { return function (fea) { return F.bimap(fea, f, g); }; };\n}\nexports.bimap = bimap;\nfunction mapLeft(F) {\n    return function (f) { return function (fea) { return F.mapLeft(fea, f); }; };\n}\nexports.mapLeft = mapLeft;\nfunction extend(F) {\n    return function (f) { return function (wa) { return F.extend(wa, f); }; };\n}\nexports.extend = extend;\nfunction reduce(F) {\n    return function (b, f) { return function (fa) { return F.reduce(fa, b, f); }; };\n}\nexports.reduce = reduce;\nfunction foldMap(F) {\n    return function (M) {\n        var foldMapM = F.foldMap(M);\n        return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n    };\n}\nexports.foldMap = foldMap;\nfunction reduceRight(F) {\n    return function (b, f) { return function (fa) { return F.reduceRight(fa, b, f); }; };\n}\nexports.reduceRight = reduceRight;\nfunction reduceWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceWithIndex(fa, b, f); }; };\n}\nexports.reduceWithIndex = reduceWithIndex;\nfunction foldMapWithIndex(F) {\n    return function (M) {\n        var foldMapWithIndexM = F.foldMapWithIndex(M);\n        return function (f) { return function (fa) { return foldMapWithIndexM(fa, f); }; };\n    };\n}\nexports.foldMapWithIndex = foldMapWithIndex;\nfunction reduceRightWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceRightWithIndex(fa, b, f); }; };\n}\nexports.reduceRightWithIndex = reduceRightWithIndex;\nfunction alt(F) {\n    return function (that) { return function (fa) { return F.alt(fa, that); }; };\n}\nexports.alt = alt;\nfunction filter(F) {\n    return function (predicate) { return function (fa) { return F.filter(fa, predicate); }; };\n}\nexports.filter = filter;\nfunction filterMap(F) {\n    return function (f) { return function (fa) { return F.filterMap(fa, f); }; };\n}\nexports.filterMap = filterMap;\nfunction partition(F) {\n    return function (f) { return function (fa) { return F.partition(fa, f); }; };\n}\nexports.partition = partition;\nfunction partitionMap(F) {\n    return function (f) { return function (fa) { return F.partitionMap(fa, f); }; };\n}\nexports.partitionMap = partitionMap;\nfunction filterWithIndex(F) {\n    return function (predicate) { return function (fa) { return F.filterWithIndex(fa, predicate); }; };\n}\nexports.filterWithIndex = filterWithIndex;\nfunction filterMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.filterMapWithIndex(fa, f); }; };\n}\nexports.filterMapWithIndex = filterMapWithIndex;\nfunction partitionWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionWithIndex(fa, f); }; };\n}\nexports.partitionWithIndex = partitionWithIndex;\nfunction partitionMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionMapWithIndex(fa, f); }; };\n}\nexports.partitionMapWithIndex = partitionMapWithIndex;\nfunction promap(F) {\n    return function (f, g) { return function (fbc) { return F.promap(fbc, f, g); }; };\n}\nexports.promap = promap;\nfunction compose(F) {\n    return function (ea) { return function (ab) { return F.compose(ab, ea); }; };\n}\nexports.compose = compose;\nvar isFunctor = function (I) { return typeof I.map === 'function'; };\nvar isContravariant = function (I) { return typeof I.contramap === 'function'; };\nvar isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };\nvar isApply = function (I) { return typeof I.ap === 'function'; };\nvar isChain = function (I) { return typeof I.chain === 'function'; };\nvar isBifunctor = function (I) { return typeof I.bimap === 'function'; };\nvar isExtend = function (I) { return typeof I.extend === 'function'; };\nvar isFoldable = function (I) { return typeof I.reduce === 'function'; };\nvar isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };\nvar isAlt = function (I) { return typeof I.alt === 'function'; };\nvar isCompactable = function (I) { return typeof I.compact === 'function'; };\nvar isFilterable = function (I) { return typeof I.filter === 'function'; };\nvar isFilterableWithIndex = function (I) {\n    return typeof I.filterWithIndex === 'function';\n};\nvar isProfunctor = function (I) { return typeof I.promap === 'function'; };\nvar isSemigroupoid = function (I) { return typeof I.compose === 'function'; };\nvar isMonadThrow = function (I) { return typeof I.throwError === 'function'; };\n/** @deprecated */\nfunction pipeable(I) {\n    var r = {};\n    if (isFunctor(I)) {\n        r.map = map(I);\n    }\n    if (isContravariant(I)) {\n        r.contramap = contramap(I);\n    }\n    if (isFunctorWithIndex(I)) {\n        r.mapWithIndex = mapWithIndex(I);\n    }\n    if (isApply(I)) {\n        r.ap = ap(I);\n        r.apFirst = (0, Apply_1.apFirst)(I);\n        r.apSecond = (0, Apply_1.apSecond)(I);\n    }\n    if (isChain(I)) {\n        r.chain = chain(I);\n        r.chainFirst = (0, Chain_1.chainFirst)(I);\n        r.flatten = r.chain(function_1.identity);\n    }\n    if (isBifunctor(I)) {\n        r.bimap = bimap(I);\n        r.mapLeft = mapLeft(I);\n    }\n    if (isExtend(I)) {\n        r.extend = extend(I);\n        r.duplicate = r.extend(function_1.identity);\n    }\n    if (isFoldable(I)) {\n        r.reduce = reduce(I);\n        r.foldMap = foldMap(I);\n        r.reduceRight = reduceRight(I);\n    }\n    if (isFoldableWithIndex(I)) {\n        r.reduceWithIndex = reduceWithIndex(I);\n        r.foldMapWithIndex = foldMapWithIndex(I);\n        r.reduceRightWithIndex = reduceRightWithIndex(I);\n    }\n    if (isAlt(I)) {\n        r.alt = alt(I);\n    }\n    if (isCompactable(I)) {\n        r.compact = I.compact;\n        r.separate = I.separate;\n    }\n    if (isFilterable(I)) {\n        r.filter = filter(I);\n        r.filterMap = filterMap(I);\n        r.partition = partition(I);\n        r.partitionMap = partitionMap(I);\n    }\n    if (isFilterableWithIndex(I)) {\n        r.filterWithIndex = filterWithIndex(I);\n        r.filterMapWithIndex = filterMapWithIndex(I);\n        r.partitionWithIndex = partitionWithIndex(I);\n        r.partitionMapWithIndex = partitionMapWithIndex(I);\n    }\n    if (isProfunctor(I)) {\n        r.promap = promap(I);\n    }\n    if (isSemigroupoid(I)) {\n        r.compose = compose(I);\n    }\n    if (isMonadThrow(I)) {\n        var fromOption = function (onNone) { return function (ma) {\n            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n        }; };\n        var fromEither = function (ma) {\n            return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);\n        };\n        var fromPredicate = function (predicate, onFalse) {\n            return function (a) {\n                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));\n            };\n        };\n        var filterOrElse = function (predicate, onFalse) {\n            return function (ma) {\n                return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); });\n            };\n        };\n        r.fromOption = fromOption;\n        r.fromEither = fromEither;\n        r.fromPredicate = fromPredicate;\n        r.filterOrElse = filterOrElse;\n    }\n    return r;\n}\nexports.pipeable = pipeable;\n/**\n * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexports.pipe = function_1.pipe;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nvar fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\nexports.fromEquals = fromEquals;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar struct = function (eqs) {\n    return (0, exports.fromEquals)(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\nexports.struct = struct;\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return (0, exports.fromEquals)(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\nexports.tuple = tuple;\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nvar contramap = function (f) { return function (fa) {\n    return (0, exports.fromEquals)(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexports.eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (x, y) { return (0, exports.fromEquals)(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * @category instances\n * @since 2.6.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: empty\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleEq = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructEq = exports.struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.strictEqual = exports.eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eq = exports.Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqBoolean = exports.eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqString = exports.eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqNumber = exports.eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n",
  "\"use strict\";\n/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tapEither = exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;\nvar Chain_1 = require(\"./Chain\");\nvar function_1 = require(\"./function\");\nvar _ = __importStar(require(\"./internal\"));\nfunction fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nexports.fromOption = fromOption;\nfunction fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nexports.fromPredicate = fromPredicate;\nfunction fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return (0, function_1.flow)(f, from); };\n    };\n}\nexports.fromOptionK = fromOptionK;\nfunction chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nexports.chainOptionK = chainOptionK;\nfunction fromEitherK(F) {\n    return function (f) { return (0, function_1.flow)(f, F.fromEither); };\n}\nexports.fromEitherK = fromEitherK;\nfunction chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nexports.chainEitherK = chainEitherK;\nfunction chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nexports.chainFirstEitherK = chainFirstEitherK;\nfunction filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\nexports.filterOrElse = filterOrElse;\n/** @internal */\nfunction tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = (0, Chain_1.tap)(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\nexports.tapEither = tapEither;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Field = exports.MonoidProduct = exports.MonoidSum = exports.SemigroupProduct = exports.SemigroupSum = exports.MagmaSub = exports.Show = exports.Bounded = exports.Ord = exports.Eq = exports.isNumber = void 0;\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @category refinements\n * @since 2.11.0\n */\nvar isNumber = function (u) { return typeof u === 'number'; };\nexports.isNumber = isNumber;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Ord = {\n    equals: exports.Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Bounded = {\n    equals: exports.Eq.equals,\n    compare: exports.Ord.compare,\n    top: Infinity,\n    bottom: -Infinity\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Show = {\n    show: function (n) { return JSON.stringify(n); }\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.MagmaSub = {\n    concat: function (first, second) { return first - second; }\n};\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.SemigroupSum = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.SemigroupProduct = {\n    concat: function (first, second) { return first * second; }\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.MonoidSum = {\n    concat: exports.SemigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.MonoidProduct = {\n    concat: exports.SemigroupProduct.concat,\n    empty: 1\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Field = {\n    add: exports.SemigroupSum.concat,\n    zero: 0,\n    mul: exports.SemigroupProduct.concat,\n    one: 1,\n    sub: exports.MagmaSub.concat,\n    degree: function (_) { return 1; },\n    div: function (first, second) { return first / second; },\n    mod: function (first, second) { return first % second; }\n};\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;\nvar Eq_1 = require(\"./Eq\");\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nvar equalsDefault = function (compare) {\n    return function (first, second) {\n        return first === second || compare(first, second) === 0;\n    };\n};\nexports.equalsDefault = equalsDefault;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nvar fromCompare = function (compare) { return ({\n    equals: (0, exports.equalsDefault)(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\nexports.fromCompare = fromCompare;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return (0, exports.fromCompare)(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\nexports.tuple = tuple;\n/**\n * @since 2.10.0\n */\nvar reverse = function (O) { return (0, exports.fromCompare)(function (first, second) { return O.compare(second, first); }); };\nexports.reverse = reverse;\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nvar contramap = function (f) { return function (fa) {\n    return (0, exports.fromCompare)(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return (0, exports.fromCompare)(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: (0, exports.fromCompare)(function () { return 0; })\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexports.trivial = {\n    equals: function_1.constTrue,\n    compare: /*#__PURE__*/ (0, function_1.constant)(0)\n};\n/**\n * @since 2.11.0\n */\nvar equals = function (O) {\n    return function (second) {\n        return function (first) {\n            return first === second || O.compare(first, second) === 0;\n        };\n    };\n};\nexports.equals = equals;\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nvar lt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === -1;\n    };\n};\nexports.lt = lt;\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nvar gt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === 1;\n    };\n};\nexports.gt = gt;\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nvar leq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== 1;\n    };\n};\nexports.leq = leq;\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nvar geq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== -1;\n    };\n};\nexports.geq = geq;\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nvar min = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) < 1 ? first : second;\n    };\n};\nexports.min = min;\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nvar max = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) > -1 ? first : second;\n    };\n};\nexports.max = max;\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nvar clamp = function (O) {\n    var minO = (0, exports.min)(O);\n    var maxO = (0, exports.max)(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\nexports.clamp = clamp;\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nvar between = function (O) {\n    var ltO = (0, exports.lt)(O);\n    var gtO = (0, exports.gt)(O);\n    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };\n};\nexports.between = between;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleOrd = exports.tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getDualOrd = exports.reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ord = exports.Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: Eq_1.eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.ordDate = (0, function_1.pipe)(exports.ordNumber, \n/*#__PURE__*/\n(0, exports.contramap)(function (date) { return date.valueOf(); }));\n",
  "\"use strict\";\n/**\n * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`\n *\n * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.\n *\n * @since 2.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Magma`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse, concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(reverse(N.MagmaSub))(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), 2)\n *\n * @since 2.11.0\n */\nvar reverse = function (M) { return ({\n    concat: function (first, second) { return M.concat(second, first); }\n}); };\nexports.reverse = reverse;\n/**\n * @since 2.11.0\n */\nvar filterFirst = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }\n    }); };\n};\nexports.filterFirst = filterFirst;\n/**\n * @since 2.11.0\n */\nvar filterSecond = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }\n    }); };\n};\nexports.filterSecond = filterSecond;\n/**\n * @since 2.11.0\n */\nvar endo = function (f) {\n    return function (M) { return ({\n        concat: function (first, second) { return M.concat(f(first), f(second)); }\n    }); };\n};\nexports.endo = endo;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(N.MagmaSub)(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), -6)\n *\n * @since 2.11.0\n */\nvar concatAll = function (M) {\n    return function (startWith) {\n        return function (as) {\n            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);\n        };\n    };\n};\nexports.concatAll = concatAll;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;\n/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nvar _ = __importStar(require(\"./internal\"));\nvar M = __importStar(require(\"./Magma\"));\nvar Or = __importStar(require(\"./Ord\"));\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar min = function (O) { return ({\n    concat: Or.min(O)\n}); };\nexports.min = min;\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nvar max = function (O) { return ({\n    concat: Or.max(O)\n}); };\nexports.max = max;\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\nexports.constant = constant;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexports.reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nvar struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\nexports.struct = struct;\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\nexports.tuple = tuple;\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nvar intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\nexports.intercalate = intercalate;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nvar first = function () { return ({ concat: function_1.identity }); };\nexports.first = first;\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nvar last = function () { return ({ concat: function (_, y) { return y; } }); };\nexports.last = last;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexports.concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupVoid = (0, exports.constant)(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\nexports.getObjectSemigroup = getObjectSemigroup;\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getLastSemigroup = exports.last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getFirstSemigroup = exports.first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleSemigroup = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructSemigroup = exports.struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getDualSemigroup = exports.reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getJoinSemigroup = exports.max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getMeetSemigroup = exports.min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.getIntercalateSemigroup = exports.intercalate;\nfunction fold(S) {\n    var concatAllS = (0, exports.concatAll)(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\nexports.fold = fold;\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getFunctionSemigroup = function_1.getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;\nexports.groupSort = exports.chain = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;\nexports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = exports.filter = void 0;\nvar Apply_1 = require(\"./Apply\");\nvar Chain_1 = require(\"./Chain\");\nvar Eq_1 = require(\"./Eq\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\nvar Ord_1 = require(\"./Ord\");\nvar Se = __importStar(require(\"./Semigroup\"));\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexports.empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexports.isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nvar isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\nexports.isOutOfBound = isOutOfBound;\n/**\n * @internal\n */\nvar prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\nexports.prependW = prependW;\n/**\n * @internal\n */\nexports.prepend = exports.prependW;\n/**\n * @internal\n */\nvar appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\nexports.appendW = appendW;\n/**\n * @internal\n */\nexports.append = exports.appendW;\n/**\n * @internal\n */\nvar unsafeInsertAt = function (i, a, as) {\n    if ((0, exports.isNonEmpty)(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\nexports.unsafeInsertAt = unsafeInsertAt;\n/**\n * @internal\n */\nvar unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\nexports.unsafeUpdateAt = unsafeUpdateAt;\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nvar uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [(0, exports.head)(as)];\n        var rest = (0, exports.tail)(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\nexports.uniq = uniq;\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nvar sortBy = function (ords) {\n    if ((0, exports.isNonEmpty)(ords)) {\n        var M = (0, Ord_1.getMonoid)();\n        return (0, exports.sort)(ords.reduce(M.concat, M.empty));\n    }\n    return function_1.identity;\n};\nexports.sortBy = sortBy;\n/**\n * @since 2.11.0\n */\nvar union = function (E) {\n    var uniqE = (0, exports.uniq)(E);\n    return function (second) { return function (first) { return uniqE((0, function_1.pipe)(first, concat(second))); }; };\n};\nexports.union = union;\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nvar rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if ((0, exports.isOutOfBound)(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = (0, exports.splitAt)(-m)(as), f = _a[0], s = _a[1];\n            return (0, function_1.pipe)(s, concat(f));\n        }\n        else {\n            return (0, exports.rotate)(m - len)(as);\n        }\n    };\n};\nexports.rotate = rotate;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nvar fromReadonlyArray = function (as) {\n    return (0, exports.isNonEmpty)(as) ? _.some(as) : _.none;\n};\nexports.fromReadonlyArray = fromReadonlyArray;\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nvar makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\nexports.makeBy = makeBy;\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nvar replicate = function (a) { return (0, exports.makeBy)(function () { return a; }); };\nexports.replicate = replicate;\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nvar range = function (start, end) {\n    return start <= end ? (0, exports.makeBy)(function (i) { return start + i; })(end - start + 1) : [start];\n};\nexports.range = range;\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nvar unprepend = function (as) { return [(0, exports.head)(as), (0, exports.tail)(as)]; };\nexports.unprepend = unprepend;\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nvar unappend = function (as) { return [(0, exports.init)(as), (0, exports.last)(as)]; };\nexports.unappend = unappend;\n/**\n * @category conversions\n * @since 2.5.0\n */\nvar fromArray = function (as) { return (0, exports.fromReadonlyArray)(as.slice()); };\nexports.fromArray = fromArray;\nfunction concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexports.concatW = concatW;\nfunction concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\nexports.concat = concat;\n/**\n * @since 2.5.0\n */\nvar reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([(0, exports.last)(as)], as.slice(0, -1).reverse(), true);\n};\nexports.reverse = reverse;\nfunction group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return exports.empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\nexports.group = group;\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nvar groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\nexports.groupBy = groupBy;\n/**\n * @since 2.5.0\n */\nvar sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\nexports.sort = sort;\n/**\n * @since 2.5.0\n */\nvar updateAt = function (i, a) {\n    return (0, exports.modifyAt)(i, function () { return a; });\n};\nexports.updateAt = updateAt;\n/**\n * @since 2.5.0\n */\nvar modifyAt = function (i, f) {\n    return function (as) {\n        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));\n    };\n};\nexports.modifyAt = modifyAt;\n/**\n * @since 2.5.1\n */\nvar zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexports.zipWith = zipWith;\nfunction zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });\n}\nexports.zip = zip;\n/**\n * @since 2.5.1\n */\nvar unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\nexports.unzip = unzip;\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nvar prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\nexports.prependAll = prependAll;\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nvar intersperse = function (middle) {\n    return function (as) {\n        var rest = (0, exports.tail)(as);\n        return (0, exports.isNonEmpty)(rest) ? (0, function_1.pipe)(rest, (0, exports.prependAll)(middle), (0, exports.prepend)((0, exports.head)(as))) : as;\n    };\n};\nexports.intersperse = intersperse;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nvar chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, (0, exports.head)(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\nexports.chainWithIndex = chainWithIndex;\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nvar chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while ((0, exports.isNonEmpty)(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\nexports.chop = chop;\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nvar splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, exports.empty] : [(0, function_1.pipe)(as.slice(1, m), (0, exports.prepend)((0, exports.head)(as))), as.slice(m)];\n    };\n};\nexports.splitAt = splitAt;\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nvar chunksOf = function (n) { return (0, exports.chop)((0, exports.splitAt)(n)); };\nexports.chunksOf = chunksOf;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };\nvar _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexports.of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nvar altW = function (that) {\n    return function (as) {\n        return (0, function_1.pipe)(as, concatW(that()));\n    };\n};\nexports.altW = altW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexports.alt = exports.altW;\n/**\n * @since 2.5.0\n */\nvar ap = function (as) { return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(as, (0, exports.map)(f)); }); };\nexports.ap = ap;\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexports.flatMap = (0, function_1.dual)(2, function (ma, f) {\n    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nvar extend = function (f) {\n    return function (as) {\n        var next = (0, exports.tail)(as);\n        var out = [f(as)];\n        while ((0, exports.isNonEmpty)(next)) {\n            out.push(f(next));\n            next = (0, exports.tail)(next);\n        }\n        return out;\n    };\n};\nexports.extend = extend;\n/**\n * @since 2.5.0\n */\nexports.duplicate = \n/*#__PURE__*/ (0, exports.extend)(function_1.identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexports.flatten = \n/*#__PURE__*/ (0, exports.flatMap)(function_1.identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nvar map = function (f) {\n    return (0, exports.mapWithIndex)(function (_, a) { return f(a); });\n};\nexports.map = map;\n/**\n * @category mapping\n * @since 2.5.0\n */\nvar mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, (0, exports.head)(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\nexports.mapWithIndex = mapWithIndex;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduce = function (b, f) {\n    return (0, exports.reduceWithIndex)(b, function (_, b, a) { return f(b, a); });\n};\nexports.reduce = reduce;\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nvar foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\nexports.foldMap = foldMap;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceRight = function (b, f) {\n    return (0, exports.reduceRightWithIndex)(b, function (_, b, a) { return f(b, a); });\n};\nexports.reduceRight = reduceRight;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\nexports.reduceWithIndex = reduceWithIndex;\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nvar foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\nexports.foldMapWithIndex = foldMapWithIndex;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\nexports.reduceRightWithIndex = reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\nexports.traverse = traverse;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) { return (0, exports.traverseWithIndex)(F)(function_1.SK); };\nexports.sequence = sequence;\n/**\n * @category sequencing\n * @since 2.6.3\n */\nvar traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, (0, exports.head)(as)), exports.of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\nexports.traverseWithIndex = traverseWithIndex;\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexports.extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexports.URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nvar getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\nexports.getShow = getShow;\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nvar getSemigroup = function () { return ({\n    concat: concat\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nvar getEq = function (E) {\n    return (0, Eq_1.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\nexports.getEq = getEq;\n/**\n * @since 2.11.0\n */\nvar getUnionSemigroup = function (E) {\n    var unionE = (0, exports.union)(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\nexports.getUnionSemigroup = getUnionSemigroup;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FunctorWithIndex = {\n    URI: exports.URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Apply = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexports.apFirst = (0, Apply_1.apFirst)(exports.Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexports.apSecond = (0, Apply_1.apSecond)(exports.Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Chain = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FoldableWithIndex = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.TraversableWithIndex = {\n    URI: exports.URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Comonad = {\n    URI: exports.URI,\n    map: _map,\n    extend: _extend,\n    extract: exports.extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexports.Do = (0, exports.of)(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bindTo = (0, Functor_1.bindTo)(exports.Functor);\nvar let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);\nexports.let = let_;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bind = (0, Chain_1.bind)(exports.Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.apS = (0, Apply_1.apS)(exports.Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexports.head = exports.extract;\n/**\n * @since 2.5.0\n */\nexports.tail = _.tail;\n/**\n * @since 2.5.0\n */\nvar last = function (as) { return as[as.length - 1]; };\nexports.last = last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nvar init = function (as) { return as.slice(0, -1); };\nexports.init = init;\n/**\n * @since 2.5.0\n */\nvar min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\nexports.min = min;\n/**\n * @since 2.5.0\n */\nvar max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\nexports.max = max;\n/**\n * @since 2.10.0\n */\nvar concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\nexports.concatAll = concatAll;\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nvar matchLeft = function (f) {\n    return function (as) {\n        return f((0, exports.head)(as), (0, exports.tail)(as));\n    };\n};\nexports.matchLeft = matchLeft;\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nvar matchRight = function (f) {\n    return function (as) {\n        return f((0, exports.init)(as), (0, exports.last)(as));\n    };\n};\nexports.matchRight = matchRight;\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nvar modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f((0, exports.head)(as))], (0, exports.tail)(as), true);\n    };\n};\nexports.modifyHead = modifyHead;\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nvar updateHead = function (a) { return (0, exports.modifyHead)(function () { return a; }); };\nexports.updateHead = updateHead;\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nvar modifyLast = function (f) {\n    return function (as) {\n        return (0, function_1.pipe)((0, exports.init)(as), (0, exports.append)(f((0, exports.last)(as))));\n    };\n};\nexports.modifyLast = modifyLast;\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nvar updateLast = function (a) { return (0, exports.modifyLast)(function () { return a; }); };\nexports.updateLast = updateLast;\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nvar intercalate = function (S) {\n    var concatAllS = (0, exports.concatAll)(S);\n    return function (middle) { return (0, function_1.flow)((0, exports.intersperse)(middle), concatAllS); };\n};\nexports.intercalate = intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexports.chain = exports.flatMap;\nfunction groupSort(O) {\n    var sortO = (0, exports.sort)(O);\n    var groupO = group(O);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? groupO(sortO(as)) : exports.empty); };\n}\nexports.groupSort = groupSort;\nfunction filter(predicate) {\n    return (0, exports.filterWithIndex)(function (_, a) { return predicate(a); });\n}\nexports.filter = filter;\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nvar filterWithIndex = function (predicate) {\n    return function (as) {\n        return (0, exports.fromReadonlyArray)(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\nexports.filterWithIndex = filterWithIndex;\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexports.uncons = exports.unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexports.unsnoc = exports.unappend;\nfunction cons(head, tail) {\n    return tail === undefined ? (0, exports.prepend)(head) : (0, function_1.pipe)(tail, (0, exports.prepend)(head));\n}\nexports.cons = cons;\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nvar snoc = function (init, end) { return (0, function_1.pipe)(init, concat([end])); };\nexports.snoc = snoc;\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nvar insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some((0, exports.unsafeInsertAt)(i, a, as));\n    };\n};\nexports.insertAt = insertAt;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexports.prependToAll = exports.prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.fold = exports.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.readonlyNonEmptyArray = {\n    URI: exports.URI,\n    of: exports.of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: exports.flatMap,\n    extend: _extend,\n    extract: exports.extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "\"use strict\";\n/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nvar separated = function (left, right) { return ({ left: left, right: right }); };\nexports.separated = separated;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\nvar _bimap = function (fa, g, f) { return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar map = function (f) {\n    return function (fa) {\n        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));\n    };\n};\nexports.map = map;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nvar mapLeft = function (f) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));\n    };\n};\nexports.mapLeft = mapLeft;\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nvar bimap = function (f, g) {\n    return function (fa) {\n        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));\n    };\n};\nexports.bimap = bimap;\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexports.URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar left = function (s) { return s.left; };\nexports.left = left;\n/**\n * @since 2.10.0\n */\nvar right = function (s) { return s.right; };\nexports.right = right;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.filterE = exports.witherDefault = exports.wiltDefault = void 0;\nvar _ = __importStar(require(\"./internal\"));\nfunction wiltDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };\n    };\n}\nexports.wiltDefault = wiltDefault;\nfunction witherDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };\n    };\n}\nexports.witherDefault = witherDefault;\nfunction filterE(W) {\n    return function (F) {\n        var witherF = W.wither(F);\n        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };\n    };\n}\nexports.filterE = filterE;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.guard = void 0;\nfunction guard(F, P) {\n    return function (b) { return (b ? P.of(undefined) : F.zero()); };\n}\nexports.guard = guard;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;\nexports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.flatMap = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;\nexports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;\nexports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.chain = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;\nvar Apply_1 = require(\"./Apply\");\nvar Chain_1 = require(\"./Chain\");\nvar Eq_1 = require(\"./Eq\");\nvar FromEither_1 = require(\"./FromEither\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\nvar N = __importStar(require(\"./number\"));\nvar Ord_1 = require(\"./Ord\");\nvar RNEA = __importStar(require(\"./ReadonlyNonEmptyArray\"));\nvar Separated_1 = require(\"./Separated\");\nvar Witherable_1 = require(\"./Witherable\");\nvar Zero_1 = require(\"./Zero\");\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nvar isEmpty = function (as) { return as.length === 0; };\nexports.isEmpty = isEmpty;\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexports.isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexports.prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexports.prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexports.append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexports.appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nvar makeBy = function (n, f) { return (n <= 0 ? exports.empty : RNEA.makeBy(f)(n)); };\nexports.makeBy = makeBy;\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nvar replicate = function (n, a) { return (0, exports.makeBy)(n, function () { return a; }); };\nexports.replicate = replicate;\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : exports.empty); };\n}\nexports.fromPredicate = fromPredicate;\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nvar fromOption = function (ma) { return (_.isNone(ma) ? exports.empty : [ma.value]); };\nexports.fromOption = fromOption;\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nvar fromEither = function (e) { return (_.isLeft(e) ? exports.empty : [e.right]); };\nexports.fromEither = fromEither;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nvar matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return (0, exports.isNonEmpty)(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\nexports.matchW = matchW;\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexports.match = exports.matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nvar matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\nexports.matchLeftW = matchLeftW;\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.matchLeft = exports.matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexports.foldLeft = exports.matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nvar matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return (0, exports.isNonEmpty)(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\nexports.matchRightW = matchRightW;\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.matchRight = exports.matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexports.foldRight = exports.matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nvar chainWithIndex = function (f) {\n    return function (as) {\n        if ((0, exports.isEmpty)(as)) {\n            return exports.empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\nexports.chainWithIndex = chainWithIndex;\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nvar scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\nexports.scanLeft = scanLeft;\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nvar scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\nexports.scanRight = scanRight;\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nvar size = function (as) { return as.length; };\nexports.size = size;\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexports.isOutOfBound = RNEA.isOutOfBound;\nfunction lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : (0, exports.isOutOfBound)(i, as) ? _.none : _.some(as[i]);\n}\nexports.lookup = lookup;\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nvar head = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(RNEA.head(as)) : _.none); };\nexports.head = head;\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nvar last = function (as) { return ((0, exports.isNonEmpty)(as) ? _.some(RNEA.last(as)) : _.none); };\nexports.last = last;\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nvar tail = function (as) {\n    return (0, exports.isNonEmpty)(as) ? _.some(RNEA.tail(as)) : _.none;\n};\nexports.tail = tail;\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nvar init = function (as) {\n    return (0, exports.isNonEmpty)(as) ? _.some(RNEA.init(as)) : _.none;\n};\nexports.init = init;\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nvar takeLeft = function (n) {\n    return function (as) {\n        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(0, n);\n    };\n};\nexports.takeLeft = takeLeft;\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nvar takeRight = function (n) {\n    return function (as) {\n        return (0, exports.isOutOfBound)(n, as) ? as : n === 0 ? exports.empty : as.slice(-n);\n    };\n};\nexports.takeRight = takeRight;\nfunction takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? exports.empty : out;\n    };\n}\nexports.takeLeftWhile = takeLeftWhile;\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nfunction spanLeft(predicate) {\n    return function (as) {\n        var _a = (0, exports.splitAt)(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\nexports.spanLeft = spanLeft;\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nvar dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(n, as.length);\n    };\n};\nexports.dropLeft = dropLeft;\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nvar dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || (0, exports.isEmpty)(as) ? as : n >= as.length ? exports.empty : as.slice(0, as.length - n);\n    };\n};\nexports.dropRight = dropRight;\nfunction dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? exports.empty : as.slice(i);\n    };\n}\nexports.dropLeftWhile = dropLeftWhile;\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nvar findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexports.findIndex = findIndex;\nfunction findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\nexports.findFirst = findFirst;\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nvar findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexports.findFirstMap = findFirstMap;\nfunction findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\nexports.findLast = findLast;\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nvar findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexports.findLastMap = findLastMap;\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nvar findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexports.findLastIndex = findLastIndex;\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nvar insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\nexports.insertAt = insertAt;\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nvar updateAt = function (i, a) {\n    return (0, exports.modifyAt)(i, function () { return a; });\n};\nexports.updateAt = updateAt;\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nvar deleteAt = function (i) {\n    return function (as) {\n        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeDeleteAt)(i, as));\n    };\n};\nexports.deleteAt = deleteAt;\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nvar modifyAt = function (i, f) {\n    return function (as) {\n        return (0, exports.isOutOfBound)(i, as) ? _.none : _.some((0, exports.unsafeUpdateAt)(i, f(as[i]), as));\n    };\n};\nexports.modifyAt = modifyAt;\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nvar reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\nexports.reverse = reverse;\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nvar rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\nexports.rights = rights;\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nvar lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\nexports.lefts = lefts;\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nvar sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\nexports.sort = sort;\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nvar zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexports.zipWith = zipWith;\nfunction zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return (0, exports.zipWith)(as, bs, function (a, b) { return [a, b]; });\n}\nexports.zip = zip;\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nvar unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\nexports.unzip = unzip;\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nvar prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };\n};\nexports.prependAll = prependAll;\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nvar intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };\n};\nexports.intersperse = intersperse;\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nvar rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };\n};\nexports.rotate = rotate;\nfunction elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.elem = elem;\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nvar uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };\n};\nexports.uniq = uniq;\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nvar sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : as); };\n};\nexports.sortBy = sortBy;\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nvar chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? g(as) : exports.empty); };\n};\nexports.chop = chop;\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nvar splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && (0, exports.isNonEmpty)(as) ? RNEA.splitAt(n)(as) : (0, exports.isEmpty)(as) ? [as, exports.empty] : [exports.empty, as];\n    };\n};\nexports.splitAt = splitAt;\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nvar chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return ((0, exports.isNonEmpty)(as) ? f(as) : exports.empty); };\n};\nexports.chunksOf = chunksOf;\n/**\n * @category lifting\n * @since 2.11.0\n */\nvar fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return (0, exports.fromOption)(f.apply(void 0, a));\n    };\n};\nexports.fromOptionK = fromOptionK;\nfunction comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return (0, exports.isNonEmpty)(input)\n            ? (0, exports.flatMap)(RNEA.head(input), function (a) { return go((0, function_1.pipe)(scope, (0, exports.append)(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : exports.empty;\n    };\n    return go(exports.empty, input);\n}\nexports.comprehension = comprehension;\n/**\n * @since 2.11.0\n */\nvar concatW = function (second) {\n    return function (first) {\n        return (0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second);\n    };\n};\nexports.concatW = concatW;\n/**\n * @since 2.11.0\n */\nexports.concat = exports.concatW;\nfunction union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return (0, exports.isNonEmpty)(first) && (0, exports.isNonEmpty)(second) ? unionE(second)(first) : (0, exports.isNonEmpty)(first) ? first : second;\n    };\n}\nexports.union = union;\nfunction intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexports.intersection = intersection;\nfunction difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nexports.difference = difference;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapWithIndex)(f)); };\nvar _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };\nvar _filter = function (fa, predicate) {\n    return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));\n};\nvar _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };\nvar _partition = function (fa, predicate) {\n    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));\n};\nvar _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.partitionWithIndex)(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMapWithIndex)(f)); };\nvar _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return (0, function_1.pipe)(fa, (0, exports.reduceWithIndex)(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return (0, function_1.pipe)(fa, (0, exports.reduceRightWithIndex)(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMapWithIndex)(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, (0, exports.filterWithIndex)(predicateWithIndex)); };\nvar _extend = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.extend)(f)); };\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nvar _chainRecDepthFirst = function (a, f) { return (0, function_1.pipe)(a, (0, exports.chainRecDepthFirst)(f)); };\nexports._chainRecDepthFirst = _chainRecDepthFirst;\n/** @internal */\nvar _chainRecBreadthFirst = function (a, f) { return (0, function_1.pipe)(a, (0, exports.chainRecBreadthFirst)(f)); };\nexports._chainRecBreadthFirst = _chainRecBreadthFirst;\n/**\n * @category constructors\n * @since 2.5.0\n */\nexports.of = RNEA.of;\n/**\n * @since 2.7.0\n */\nvar zero = function () { return exports.empty; };\nexports.zero = zero;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nvar altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\nexports.altW = altW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexports.alt = exports.altW;\n/**\n * @since 2.5.0\n */\nvar ap = function (fa) {\n    return (0, exports.flatMap)(function (f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); });\n};\nexports.ap = ap;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexports.flatMap = (0, function_1.dual)(2, function (ma, f) {\n    return (0, function_1.pipe)(ma, (0, exports.chainWithIndex)(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexports.flatten = (0, exports.flatMap)(function_1.identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nvar map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\nexports.map = map;\n/**\n * @category mapping\n * @since 2.5.0\n */\nvar mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\nexports.mapWithIndex = mapWithIndex;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return (0, Separated_1.separated)(left, right);\n};\nexports.separate = separate;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\nexports.filter = filter;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\nexports.filterMapWithIndex = filterMapWithIndex;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar filterMap = function (f) {\n    return (0, exports.filterMapWithIndex)(function (_, a) { return f(a); });\n};\nexports.filterMap = filterMap;\n/**\n * @category filtering\n * @since 2.5.0\n */\nexports.compact = (0, exports.filterMap)(function_1.identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar partition = function (predicate) {\n    return (0, exports.partitionWithIndex)(function (_, a) { return predicate(a); });\n};\nexports.partition = partition;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return (0, Separated_1.separated)(left, right);\n    };\n};\nexports.partitionWithIndex = partitionWithIndex;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar partitionMap = function (f) {\n    return (0, exports.partitionMapWithIndex)(function (_, a) { return f(a); });\n};\nexports.partitionMap = partitionMap;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return (0, Separated_1.separated)(left, right);\n    };\n};\nexports.partitionMapWithIndex = partitionMapWithIndex;\n/**\n * @category filtering\n * @since 2.5.0\n */\nvar filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\nexports.filterWithIndex = filterWithIndex;\n/**\n * @since 2.5.0\n */\nvar extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\nexports.extend = extend;\n/**\n * @since 2.5.0\n */\nexports.duplicate = (0, exports.extend)(function_1.identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nvar foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\nexports.foldMapWithIndex = foldMapWithIndex;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduce = function (b, f) {\n    return (0, exports.reduceWithIndex)(b, function (_, b, a) { return f(b, a); });\n};\nexports.reduce = reduce;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar foldMap = function (M) {\n    var foldMapWithIndexM = (0, exports.foldMapWithIndex)(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\nexports.foldMap = foldMap;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\nexports.reduceWithIndex = reduceWithIndex;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceRight = function (b, f) {\n    return (0, exports.reduceRightWithIndex)(b, function (_, a, b) { return f(a, b); });\n};\nexports.reduceRight = reduceRight;\n/**\n * @category folding\n * @since 2.5.0\n */\nvar reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\nexports.reduceRightWithIndex = reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    var traverseWithIndexF = (0, exports.traverseWithIndex)(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\nexports.traverse = traverse;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of((0, exports.zero)()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return (0, function_1.pipe)(as, (0, exports.append)(a)); }; }), fa);\n        });\n    };\n};\nexports.sequence = sequence;\n/**\n * @category sequencing\n * @since 2.6.3\n */\nvar traverseWithIndex = function (F) {\n    return function (f) {\n        return (0, exports.reduceWithIndex)(F.of((0, exports.zero)()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return (0, function_1.pipe)(bs, (0, exports.append)(b)); }; }), f(i, a));\n        });\n    };\n};\nexports.traverseWithIndex = traverseWithIndex;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\nexports.wither = wither;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\nexports.wilt = wilt;\n/**\n * @since 2.6.6\n */\nvar unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\nexports.unfold = unfold;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexports.URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nvar getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\nexports.getShow = getShow;\n/**\n * @category instances\n * @since 2.5.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (first, second) { return ((0, exports.isEmpty)(first) ? second : (0, exports.isEmpty)(second) ? first : first.concat(second)); }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: exports.empty\n}); };\nexports.getMonoid = getMonoid;\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nvar getEq = function (E) {\n    return (0, Eq_1.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\nexports.getEq = getEq;\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nvar getOrd = function (O) {\n    return (0, Ord_1.fromCompare)(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\nexports.getOrd = getOrd;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\nexports.getUnionSemigroup = getUnionSemigroup;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getUnionMonoid = function (E) { return ({\n    concat: (0, exports.getUnionSemigroup)(E).concat,\n    empty: exports.empty\n}); };\nexports.getUnionMonoid = getUnionMonoid;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\nexports.getIntersectionSemigroup = getIntersectionSemigroup;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\nexports.getDifferenceMagma = getDifferenceMagma;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FunctorWithIndex = {\n    URI: exports.URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Apply = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexports.apFirst = (0, Apply_1.apFirst)(exports.Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexports.apSecond = (0, Apply_1.apSecond)(exports.Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Chain = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexports.chainFirst = \n/*#__PURE__*/ (0, Chain_1.chainFirst)(exports.Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Unfoldable = {\n    URI: exports.URI,\n    unfold: exports.unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.Zero = {\n    URI: exports.URI,\n    zero: exports.zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alternative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    alt: _alt,\n    zero: exports.zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Extend = {\n    URI: exports.URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Compactable = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Filterable = {\n    URI: exports.URI,\n    map: _map,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FilterableWithIndex = {\n    URI: exports.URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FoldableWithIndex = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.TraversableWithIndex = {\n    URI: exports.URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nvar chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\nexports.chainRecDepthFirst = chainRecDepthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.ChainRecDepthFirst = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap,\n    chainRec: exports._chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nvar chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\nexports.chainRecBreadthFirst = chainRecBreadthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.ChainRecBreadthFirst = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap,\n    chainRec: exports._chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);\nvar _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Witherable = {\n    URI: exports.URI,\n    map: _map,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexports.filterE = (0, Witherable_1.filterE)(exports.Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.FromEither = {\n    URI: exports.URI,\n    fromEither: exports.fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexports.unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nvar unsafeUpdateAt = function (i, a, as) {\n    return (0, exports.isNonEmpty)(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\nexports.unsafeUpdateAt = unsafeUpdateAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nvar unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\nexports.unsafeDeleteAt = unsafeDeleteAt;\n/**\n * @category conversions\n * @since 2.5.0\n */\nvar toArray = function (as) { return as.slice(); };\nexports.toArray = toArray;\n/**\n * @category conversions\n * @since 2.5.0\n */\nvar fromArray = function (as) { return ((0, exports.isEmpty)(as) ? exports.empty : as.slice()); };\nexports.fromArray = fromArray;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexports.empty = RNEA.empty;\nfunction every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\nexports.every = every;\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nvar some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\nexports.some = some;\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexports.exists = exports.some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nvar intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return (0, exports.match)(function () { return M.empty; }, intercalateM(middle)); };\n};\nexports.intercalate = intercalate;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexports.Do = (0, exports.of)(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bindTo = (0, Functor_1.bindTo)(exports.Functor);\nvar let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);\nexports.let = let_;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bind = (0, Chain_1.bind)(exports.Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.apS = (0, Apply_1.apS)(exports.Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexports.chain = exports.flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexports.prependToAll = exports.prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.readonlyArray = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: exports.zero,\n    unfold: exports.unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.empty = exports.Semigroup = exports.Eq = void 0;\nvar ReadonlyNonEmptyArray_1 = require(\"./ReadonlyNonEmptyArray\");\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)\n * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * `string` semigroup under concatenation.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.10.0\n */\nexports.Semigroup = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * An empty `string`.\n *\n * @since 2.10.0\n */\nexports.empty = '';\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')\n * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')\n *\n * @category instances\n * @since 2.10.0\n */\nexports.Monoid = {\n    concat: exports.Semigroup.concat,\n    empty: exports.empty\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)\n * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)\n * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexports.Ord = {\n    equals: exports.Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Show.show('a'), '\"a\"')\n *\n * @category instances\n * @since 2.10.0\n */\nexports.Show = {\n    show: function (s) { return JSON.stringify(s); }\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.isString('a'), true)\n * assert.deepStrictEqual(S.isString(1), false)\n *\n * @category refinements\n * @since 2.11.0\n */\nvar isString = function (u) { return typeof u === 'string'; };\nexports.isString = isString;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 2.11.0\n */\nvar toUpperCase = function (s) { return s.toUpperCase(); };\nexports.toUpperCase = toUpperCase;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 2.11.0\n */\nvar toLowerCase = function (s) { return s.toLowerCase(); };\nexports.toLowerCase = toLowerCase;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 2.11.0\n */\nvar replace = function (searchValue, replaceValue) {\n    return function (s) {\n        return s.replace(searchValue, replaceValue);\n    };\n};\nexports.replace = replace;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n *\n * @since 2.11.0\n */\nvar trim = function (s) { return s.trim(); };\nexports.trim = trim;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')\n *\n * @since 2.11.0\n */\nvar trimLeft = function (s) { return s.trimLeft(); };\nexports.trimLeft = trimLeft;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')\n *\n * @since 2.11.0\n */\nvar trimRight = function (s) { return s.trimRight(); };\nexports.trimRight = trimRight;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 2.11.0\n */\nvar slice = function (start, end) {\n    return function (s) {\n        return s.slice(start, end);\n    };\n};\nexports.slice = slice;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('', S.isEmpty), true)\n * assert.deepStrictEqual(pipe('a', S.isEmpty), false)\n *\n * @since 2.10.0\n */\nvar isEmpty = function (s) { return s.length === 0; };\nexports.isEmpty = isEmpty;\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.size), 3)\n *\n * @since 2.10.0\n */\nvar size = function (s) { return s.length; };\nexports.size = size;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.11.0\n */\nvar split = function (separator) {\n    return function (s) {\n        var out = s.split(separator);\n        return (0, ReadonlyNonEmptyArray_1.isNonEmpty)(out) ? out : [s];\n    };\n};\nexports.split = split;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)\n * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n *\n * @since 2.11.0\n */\nvar includes = function (searchString, position) {\n    return function (s) {\n        return s.includes(searchString, position);\n    };\n};\nexports.includes = includes;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\n * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n *\n * @since 2.11.0\n */\nvar startsWith = function (searchString, position) {\n    return function (s) {\n        return s.startsWith(searchString, position);\n    };\n};\nexports.startsWith = startsWith;\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\n * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n *\n * @since 2.11.0\n */\nvar endsWith = function (searchString, position) {\n    return function (s) {\n        return s.endsWith(searchString, position);\n    };\n};\nexports.endsWith = endsWith;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromEntries = exports.toEntries = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;\nexports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = exports._reduceWithIndex = exports._partitionMap = void 0;\nvar Eq_1 = require(\"./Eq\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\nvar Separated_1 = require(\"./Separated\");\nvar S = __importStar(require(\"./string\"));\nvar Witherable_1 = require(\"./Witherable\");\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nvar fromRecord = function (r) { return Object.assign({}, r); };\nexports.fromRecord = fromRecord;\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nvar toRecord = function (r) { return Object.assign({}, r); };\nexports.toRecord = toRecord;\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nvar size = function (r) { return Object.keys(r).length; };\nexports.size = size;\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nvar isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.isEmpty = isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexports.keys = keys_(S.Ord);\nfunction collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\nexports.collect = collect;\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexports.toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nfunction toUnfoldable(U) {\n    return function (r) {\n        var sas = (0, exports.toReadonlyArray)(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\nexports.toUnfoldable = toUnfoldable;\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nvar upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\nexports.upsertAt = upsertAt;\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nvar has = function (k, r) { return _.has.call(r, k); };\nexports.has = has;\nfunction deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\nexports.deleteAt = deleteAt;\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nvar updateAt = function (k, a) {\n    return function (r) {\n        if (!(0, exports.has)(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\nexports.updateAt = updateAt;\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nvar modifyAt = function (k, f) {\n    return function (r) {\n        if (!(0, exports.has)(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexports.modifyAt = modifyAt;\nfunction pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexports.pop = pop;\nfunction isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexports.isSubrecord = isSubrecord;\nfunction lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\nexports.lookup = lookup;\n/**\n * @since 2.5.0\n */\nexports.empty = {};\nfunction mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexports.mapWithIndex = mapWithIndex;\nfunction map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexports.map = map;\nfunction reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexports.reduceWithIndex = reduceWithIndex;\nfunction foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexports.foldMapWithIndex = foldMapWithIndex;\nfunction reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\nexports.reduceRightWithIndex = reduceRightWithIndex;\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nvar singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexports.singleton = singleton;\nfunction traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexports.traverseWithIndex = traverseWithIndex;\nfunction traverse(F) {\n    var traverseOF = (0, exports._traverse)(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexports.traverse = traverse;\nfunction sequence(F) {\n    return (0, exports._sequence)(S.Ord)(F);\n}\nexports.sequence = sequence;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.compact); }; };\n};\nexports.wither = wither;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map((0, function_1.pipe)(fa, traverseF(f)), exports.separate); }; };\n};\nexports.wilt = wilt;\nfunction partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return (0, Separated_1.separated)(left, right);\n    };\n}\nexports.partitionMapWithIndex = partitionMapWithIndex;\nfunction partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return (0, Separated_1.separated)(left, right);\n    };\n}\nexports.partitionWithIndex = partitionWithIndex;\nfunction filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexports.filterMapWithIndex = filterMapWithIndex;\nfunction filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexports.filterWithIndex = filterWithIndex;\nfunction fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, function_1.identity); };\n}\nexports.fromFoldable = fromFoldable;\nfunction fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\nexports.fromFoldableMap = fromFoldableMap;\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexports.toEntries = exports.toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nvar fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexports.fromEntries = fromEntries;\nfunction every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexports.every = every;\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nfunction some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.some = some;\nfunction elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.elem = elem;\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nvar union = function (M) {\n    return function (second) {\n        return function (first) {\n            if ((0, exports.isEmpty)(first)) {\n                return second;\n            }\n            if ((0, exports.isEmpty)(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if ((0, exports.has)(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!(0, exports.has)(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\nexports.union = union;\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nvar intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if ((0, exports.isEmpty)(first) || (0, exports.isEmpty)(second)) {\n                return exports.empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if ((0, exports.has)(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\nexports.intersection = intersection;\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nvar difference = function (second) {\n    return function (first) {\n        if ((0, exports.isEmpty)(first)) {\n            return second;\n        }\n        if ((0, exports.isEmpty)(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!(0, exports.has)(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!(0, exports.has)(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\nexports.difference = difference;\n/** @internal */\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, map(f)); };\nexports._map = _map;\n/** @internal */\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, mapWithIndex(f)); };\nexports._mapWithIndex = _mapWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return (0, function_1.pipe)(fa, reduceO(b, f)); };\n};\nexports._reduce = _reduce;\n/** @internal */\nvar _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n}; };\nexports._foldMap = _foldMap;\n/** @internal */\n/* istanbul ignore next */\nvar _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return (0, function_1.pipe)(fa, reduceRightO(b, f)); };\n};\nexports._reduceRight = _reduceRight;\n/** @internal */\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) {\n    return (0, function_1.pipe)(fa, (0, exports.filter)(predicate));\n};\nexports._filter = _filter;\n/** @internal */\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };\nexports._filterMap = _filterMap;\n/** @internal */\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) { return (0, function_1.pipe)(fa, (0, exports.partition)(predicate)); };\nexports._partition = _partition;\n/** @internal */\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };\nexports._partitionMap = _partitionMap;\n/** @internal */\n/* istanbul ignore next */\nvar _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return (0, function_1.pipe)(fa, reduceWithIndexO(b, f)); };\n};\nexports._reduceWithIndex = _reduceWithIndex;\n/** @internal */\nvar _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return (0, function_1.pipe)(fa, foldMapWithIndexM(f)); };\n    };\n};\nexports._foldMapWithIndex = _foldMapWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return (0, function_1.pipe)(fa, reduceRightWithIndexO(b, f)); };\n};\nexports._reduceRightWithIndex = _reduceRightWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _partitionMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, partitionMapWithIndex(f)); };\nexports._partitionMapWithIndex = _partitionMapWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _partitionWithIndex = function (fa, predicateWithIndex) {\n    return (0, function_1.pipe)(fa, partitionWithIndex(predicateWithIndex));\n};\nexports._partitionWithIndex = _partitionWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _filterMapWithIndex = function (fa, f) { return (0, function_1.pipe)(fa, filterMapWithIndex(f)); };\nexports._filterMapWithIndex = _filterMapWithIndex;\n/** @internal */\n/* istanbul ignore next */\nvar _filterWithIndex = function (fa, predicateWithIndex) { return (0, function_1.pipe)(fa, filterWithIndex(predicateWithIndex)); };\nexports._filterWithIndex = _filterWithIndex;\n/** @internal */\nvar _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, (0, function_1.flow)(function_1.SK, f)); };\n    };\n};\nexports._traverse = _traverse;\n/** @internal */\nvar _sequence = function (O) {\n    var traverseO = (0, exports._traverse)(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, function_1.identity); };\n    };\n};\nexports._sequence = _sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(exports.empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nvar filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\nexports.filter = filter;\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nvar filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\nexports.filterMap = filterMap;\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nvar partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\nexports.partition = partition;\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nvar partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexports.partitionMap = partitionMap;\nfunction reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexports.reduce = reduce;\nfunction foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexports.foldMap = foldMap;\nfunction reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\nexports.reduceRight = reduceRight;\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nvar compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\nexports.compact = compact;\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nvar separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return (0, Separated_1.separated)(left, right);\n};\nexports.separate = separate;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexports.URI = 'ReadonlyRecord';\nfunction getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexports.getShow = getShow;\nfunction getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return (0, Eq_1.fromEquals)(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexports.getEq = getEq;\nfunction getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if ((0, exports.isEmpty)(first)) {\n                return second;\n            }\n            if ((0, exports.isEmpty)(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: exports.empty\n    };\n}\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: exports._map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FunctorWithIndex = {\n    URI: exports.URI,\n    map: exports._map,\n    mapWithIndex: exports._mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nvar getFoldable = function (O) { return ({\n    URI: exports.URI,\n    reduce: (0, exports._reduce)(O),\n    foldMap: (0, exports._foldMap)(O),\n    reduceRight: (0, exports._reduceRight)(O)\n}); };\nexports.getFoldable = getFoldable;\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nvar getFoldableWithIndex = function (O) { return ({\n    URI: exports.URI,\n    reduce: (0, exports._reduce)(O),\n    foldMap: (0, exports._foldMap)(O),\n    reduceRight: (0, exports._reduceRight)(O),\n    reduceWithIndex: (0, exports._reduceWithIndex)(O),\n    foldMapWithIndex: (0, exports._foldMapWithIndex)(O),\n    reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O)\n}); };\nexports.getFoldableWithIndex = getFoldableWithIndex;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Compactable = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Filterable = {\n    URI: exports.URI,\n    map: exports._map,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: exports._filter,\n    filterMap: exports._filterMap,\n    partition: exports._partition,\n    partitionMap: exports._partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.FilterableWithIndex = {\n    URI: exports.URI,\n    map: exports._map,\n    mapWithIndex: exports._mapWithIndex,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: exports._filter,\n    filterMap: exports._filterMap,\n    partition: exports._partition,\n    partitionMap: exports._partitionMap,\n    filterMapWithIndex: exports._filterMapWithIndex,\n    filterWithIndex: exports._filterWithIndex,\n    partitionMapWithIndex: exports._partitionMapWithIndex,\n    partitionWithIndex: exports._partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar getTraversable = function (O) { return ({\n    URI: exports.URI,\n    map: exports._map,\n    reduce: (0, exports._reduce)(O),\n    foldMap: (0, exports._foldMap)(O),\n    reduceRight: (0, exports._reduceRight)(O),\n    traverse: (0, exports._traverse)(O),\n    sequence: (0, exports._sequence)(O)\n}); };\nexports.getTraversable = getTraversable;\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar getTraversableWithIndex = function (O) { return ({\n    URI: exports.URI,\n    map: exports._map,\n    mapWithIndex: exports._mapWithIndex,\n    reduce: (0, exports._reduce)(O),\n    foldMap: (0, exports._foldMap)(O),\n    reduceRight: (0, exports._reduceRight)(O),\n    reduceWithIndex: (0, exports._reduceWithIndex)(O),\n    foldMapWithIndex: (0, exports._foldMapWithIndex)(O),\n    reduceRightWithIndex: (0, exports._reduceRightWithIndex)(O),\n    traverse: (0, exports._traverse)(O),\n    sequence: (0, exports._sequence)(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\nexports.getTraversableWithIndex = getTraversableWithIndex;\n/**\n * @category filtering\n * @since 2.11.0\n */\nvar getWitherable = function (O) {\n    var T = (0, exports.getTraversable)(O);\n    return {\n        URI: exports.URI,\n        map: exports._map,\n        reduce: (0, exports._reduce)(O),\n        foldMap: (0, exports._foldMap)(O),\n        reduceRight: (0, exports._reduceRight)(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: exports.compact,\n        separate: exports.separate,\n        filter: exports._filter,\n        filterMap: exports._filterMap,\n        partition: exports._partition,\n        partitionMap: exports._partitionMap,\n        wither: (0, Witherable_1.witherDefault)(T, exports.Compactable),\n        wilt: (0, Witherable_1.wiltDefault)(T, exports.Compactable)\n    };\n};\nexports.getWitherable = getWitherable;\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nvar getUnionSemigroup = function (S) {\n    var unionS = (0, exports.union)(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\nexports.getUnionSemigroup = getUnionSemigroup;\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nvar getUnionMonoid = function (S) { return ({\n    concat: (0, exports.getUnionSemigroup)(S).concat,\n    empty: exports.empty\n}); };\nexports.getUnionMonoid = getUnionMonoid;\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nvar getIntersectionSemigroup = function (S) {\n    var intersectionS = (0, exports.intersection)(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\nexports.getIntersectionSemigroup = getIntersectionSemigroup;\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nvar getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return (0, exports.difference)(second)(first); }\n}); };\nexports.getDifferenceMagma = getDifferenceMagma;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexports.FoldableWithIndex = {\n    URI: exports.URI,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ (0, exports._reduceWithIndex)(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ (0, exports._foldMapWithIndex)(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ (0, exports._reduceRightWithIndex)(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: exports._map,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord),\n    traverse: /*#__PURE__*/ (0, exports._traverse)(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexports.TraversableWithIndex = {\n    URI: exports.URI,\n    map: exports._map,\n    mapWithIndex: exports._mapWithIndex,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ (0, exports._reduceWithIndex)(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ (0, exports._foldMapWithIndex)(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ (0, exports._reduceRightWithIndex)(S.Ord),\n    traverse: /*#__PURE__*/ (0, exports._traverse)(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);\nvar _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexports.Witherable = {\n    URI: exports.URI,\n    map: exports._map,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord),\n    traverse: /*#__PURE__*/ (0, exports._traverse)(S.Ord),\n    sequence: sequence,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: exports._filter,\n    filterMap: exports._filterMap,\n    partition: exports._partition,\n    partitionMap: exports._partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.insertAt = exports.upsertAt;\nfunction hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\nexports.hasOwnProperty = hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexports.readonlyRecord = {\n    URI: exports.URI,\n    map: exports._map,\n    reduce: /*#__PURE__*/ (0, exports._reduce)(S.Ord),\n    foldMap: /*#__PURE__*/ (0, exports._foldMap)(S.Ord),\n    reduceRight: /*#__PURE__*/ (0, exports._reduceRight)(S.Ord),\n    traverse: /*#__PURE__*/ (0, exports._traverse)(S.Ord),\n    sequence: sequence,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: exports._filter,\n    filterMap: exports._filterMap,\n    partition: exports._partition,\n    partitionMap: exports._partitionMap,\n    mapWithIndex: exports._mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ (0, exports._reduceWithIndex)(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ (0, exports._foldMapWithIndex)(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ (0, exports._reduceRightWithIndex)(S.Ord),\n    filterMapWithIndex: exports._filterMapWithIndex,\n    filterWithIndex: exports._filterWithIndex,\n    partitionMapWithIndex: exports._partitionMapWithIndex,\n    partitionWithIndex: exports._partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;\n/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nvar Apply_1 = require(\"./Apply\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nfunction getApplicativeMonoid(F) {\n    var f = (0, Apply_1.getApplySemigroup)(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\nexports.getApplicativeMonoid = getApplicativeMonoid;\n/** @deprecated */\nfunction getApplicativeComposition(F, G) {\n    var map = (0, Functor_1.getFunctorComposition)(F, G).map;\n    var _ap = (0, Apply_1.ap)(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return (0, function_1.pipe)(fgab, _ap(fga)); }\n    };\n}\nexports.getApplicativeComposition = getApplicativeComposition;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;\nvar function_1 = require(\"./function\");\nvar contramap_ = function (predicate, f) { return (0, function_1.pipe)(predicate, (0, exports.contramap)(f)); };\n/**\n * @since 2.11.0\n */\nvar contramap = function (f) {\n    return function (predicate) {\n        return (0, function_1.flow)(f, predicate);\n    };\n};\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexports.URI = 'Predicate';\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getSemigroupAny = function () { return ({\n    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.or)(second)); }\n}); };\nexports.getSemigroupAny = getSemigroupAny;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getMonoidAny = function () { return ({\n    concat: (0, exports.getSemigroupAny)().concat,\n    empty: function_1.constFalse\n}); };\nexports.getMonoidAny = getMonoidAny;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getSemigroupAll = function () { return ({\n    concat: function (first, second) { return (0, function_1.pipe)(first, (0, exports.and)(second)); }\n}); };\nexports.getSemigroupAll = getSemigroupAll;\n/**\n * @category instances\n * @since 2.11.0\n */\nvar getMonoidAll = function () { return ({\n    concat: (0, exports.getSemigroupAll)().concat,\n    empty: function_1.constTrue\n}); };\nexports.getMonoidAll = getMonoidAll;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar not = function (predicate) {\n    return function (a) {\n        return !predicate(a);\n    };\n};\nexports.not = not;\n/**\n * @since 2.11.0\n */\nvar or = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) || second(a);\n        };\n    };\n};\nexports.or = or;\n/**\n * @since 2.11.0\n */\nvar and = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) && second(a);\n        };\n    };\n};\nexports.and = and;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.orElse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.flatMap = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;\nexports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.chainFirst = exports.chain = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.tapEither = exports.tap = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = exports.fromEither = exports.MonadThrow = exports.throwError = void 0;\nexports.getLastMonoid = void 0;\nvar Applicative_1 = require(\"./Applicative\");\nvar Apply_1 = require(\"./Apply\");\nvar chainable = __importStar(require(\"./Chain\"));\nvar FromEither_1 = require(\"./FromEither\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\nvar Predicate_1 = require(\"./Predicate\");\nvar Semigroup_1 = require(\"./Semigroup\");\nvar Separated_1 = require(\"./Separated\");\nvar Witherable_1 = require(\"./Witherable\");\nvar Zero_1 = require(\"./Zero\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.some = _.some;\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? (0, exports.some)(a) : exports.none); };\n}\nexports.fromPredicate = fromPredicate;\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nvar getLeft = function (ma) { return (ma._tag === 'Right' ? exports.none : (0, exports.some)(ma.left)); };\nexports.getLeft = getLeft;\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nvar getRight = function (ma) { return (ma._tag === 'Left' ? exports.none : (0, exports.some)(ma.right)); };\nexports.getRight = getRight;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };\nvar _filter = function (fa, predicate) { return (0, function_1.pipe)(fa, (0, exports.filter)(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.filterMap)(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return (0, function_1.pipe)(fa, (0, exports.partition)(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.partitionMap)(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nvar getShow = function (S) { return ({\n    show: function (ma) { return ((0, exports.isNone)(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\nexports.getShow = getShow;\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nvar getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || ((0, exports.isNone)(x) ? (0, exports.isNone)(y) : (0, exports.isNone)(y) ? false : E.equals(x.value, y.value)); }\n}); };\nexports.getEq = getEq;\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nvar getOrd = function (O) { return ({\n    equals: (0, exports.getEq)(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : (0, exports.isSome)(x) ? ((0, exports.isSome)(y) ? O.compare(x.value, y.value) : 1) : -1); }\n}); };\nexports.getOrd = getOrd;\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nvar getMonoid = function (S) { return ({\n    concat: function (x, y) { return ((0, exports.isNone)(x) ? y : (0, exports.isNone)(y) ? x : (0, exports.some)(S.concat(x.value, y.value))); },\n    empty: exports.none\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category mapping\n * @since 2.0.0\n */\nvar map = function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(f(fa.value));\n}; };\nexports.map = map;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.asUnit = (0, Functor_1.asUnit)(exports.Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexports.of = exports.some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * @since 2.0.0\n */\nvar ap = function (fa) { return function (fab) {\n    return (0, exports.isNone)(fab) ? exports.none : (0, exports.isNone)(fa) ? exports.none : (0, exports.some)(fab.value(fa.value));\n}; };\nexports.ap = ap;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Apply = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexports.flatMap = (0, function_1.dual)(2, function (ma, f) { return ((0, exports.isNone)(ma) ? exports.none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Chain = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduce = function (b, f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? b : f(b, fa.value);\n}; };\nexports.reduce = reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar foldMap = function (M) { return function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? M.empty : f(fa.value);\n}; }; };\nexports.foldMap = foldMap;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduceRight = function (b, f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? b : f(fa.value, b);\n}; };\nexports.reduceRight = reduceRight;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexports.orElse = (0, function_1.dual)(2, function (self, that) { return ((0, exports.isNone)(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexports.altW = exports.orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.alt = exports.orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nvar zero = function () { return exports.none; };\nexports.zero = zero;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.Zero = {\n    URI: exports.URI,\n    zero: exports.zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexports.guard = (0, Zero_1.guard)(exports.Zero, exports.Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alternative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    alt: _alt,\n    zero: exports.zero\n};\n/**\n * @since 2.0.0\n */\nvar extend = function (f) { return function (wa) {\n    return (0, exports.isNone)(wa) ? exports.none : (0, exports.some)(f(wa));\n}; };\nexports.extend = extend;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Extend = {\n    URI: exports.URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexports.compact = (0, exports.flatMap)(function_1.identity);\nvar defaultSeparated = /*#__PURE__*/ (0, Separated_1.separated)(exports.none, exports.none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar separate = function (ma) {\n    return (0, exports.isNone)(ma) ? defaultSeparated : (0, Separated_1.separated)((0, exports.getLeft)(ma.value), (0, exports.getRight)(ma.value));\n};\nexports.separate = separate;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Compactable = {\n    URI: exports.URI,\n    compact: exports.compact,\n    separate: exports.separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar filter = function (predicate) {\n    return function (fa) {\n        return (0, exports.isNone)(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;\n    };\n};\nexports.filter = filter;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar filterMap = function (f) { return function (fa) {\n    return (0, exports.isNone)(fa) ? exports.none : f(fa.value);\n}; };\nexports.filterMap = filterMap;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar partition = function (predicate) {\n    return function (fa) {\n        return (0, Separated_1.separated)(_filter(fa, (0, Predicate_1.not)(predicate)), _filter(fa, predicate));\n    };\n};\nexports.partition = partition;\n/**\n * @category filtering\n * @since 2.0.0\n */\nvar partitionMap = function (f) { return (0, function_1.flow)((0, exports.map)(f), exports.separate); };\nexports.partitionMap = partitionMap;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Filterable = {\n    URI: exports.URI,\n    map: _map,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);\n        };\n    };\n};\nexports.traverse = traverse;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) {\n    return function (ta) {\n        return (0, exports.isNone)(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);\n    };\n};\nexports.sequence = sequence;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\nvar _wither = /*#__PURE__*/ (0, Witherable_1.witherDefault)(exports.Traversable, exports.Compactable);\nvar _wilt = /*#__PURE__*/ (0, Witherable_1.wiltDefault)(exports.Traversable, exports.Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\nexports.wither = wither;\n/**\n * @category filtering\n * @since 2.6.5\n */\nvar wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\nexports.wilt = wilt;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Witherable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nvar throwError = function () { return exports.none; };\nexports.throwError = throwError;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.MonadThrow = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap,\n    throwError: exports.throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.fromEither = exports.getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.FromEither = {\n    URI: exports.URI,\n    fromEither: exports.fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexports.isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nvar matchW = function (onNone, onSome) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? onNone() : onSome(ma.value);\n    };\n};\nexports.matchW = matchW;\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.foldW = exports.matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.match = exports.matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexports.fold = exports.match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nvar getOrElseW = function (onNone) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? onNone() : ma.value;\n    };\n};\nexports.getOrElseW = getOrElseW;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexports.getOrElse = exports.getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexports.apFirst = (0, Apply_1.apFirst)(exports.Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexports.apSecond = (0, Apply_1.apSecond)(exports.Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexports.flatten = exports.compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexports.tapEither = (0, function_1.dual)(2, (0, FromEither_1.tapEither)(exports.FromEither, exports.Chain));\n/**\n * @since 2.0.0\n */\nexports.duplicate = (0, exports.extend)(function_1.identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexports.fromEitherK = (0, FromEither_1.fromEitherK)(exports.FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexports.chainEitherK = \n/*#__PURE__*/ (0, FromEither_1.chainEitherK)(exports.FromEither, exports.Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexports.chainFirstEitherK = exports.tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nvar fromNullable = function (a) { return (a == null ? exports.none : (0, exports.some)(a)); };\nexports.fromNullable = fromNullable;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nvar tryCatch = function (f) {\n    try {\n        return (0, exports.some)(f());\n    }\n    catch (e) {\n        return exports.none;\n    }\n};\nexports.tryCatch = tryCatch;\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nvar tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); });\n    };\n};\nexports.tryCatchK = tryCatchK;\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nvar fromNullableK = function (f) { return (0, function_1.flow)(f, exports.fromNullable); };\nexports.fromNullableK = fromNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nvar chainNullableK = function (f) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? exports.none : (0, exports.fromNullable)(f(ma.value));\n    };\n};\nexports.chainNullableK = chainNullableK;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.toNullable = (0, exports.match)(function_1.constNull, function_1.identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.toUndefined = (0, exports.match)(function_1.constUndefined, function_1.identity);\nfunction elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return (0, exports.isNone)(ma) ? false : E.equals(a, ma.value);\n    };\n}\nexports.elem = elem;\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nvar exists = function (predicate) {\n    return function (ma) {\n        return (0, exports.isNone)(ma) ? false : predicate(ma.value);\n    };\n};\nexports.exists = exists;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexports.Do = (0, exports.of)(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bindTo = (0, Functor_1.bindTo)(exports.Functor);\nvar let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);\nexports.let = let_;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bind = chainable.bind(exports.Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.apS = (0, Apply_1.apS)(exports.Apply);\n/**\n * @since 2.11.0\n */\nexports.ApT = (0, exports.of)(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if ((0, exports.isNone)(o)) {\n            return exports.none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if ((0, exports.isNone)(o_1)) {\n                return exports.none;\n            }\n            out.push(o_1.value);\n        }\n        return (0, exports.some)(out);\n    };\n};\nexports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyArrayWithIndex = function (f) {\n    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };\n};\nexports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nvar traverseArray = function (f) {\n    return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); });\n};\nexports.traverseArray = traverseArray;\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.sequenceArray = \n/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chain = exports.flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chainFirst = exports.tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction getRefinement(getOption) {\n    return function (a) { return (0, exports.isSome)(getOption(a)); };\n}\nexports.getRefinement = getRefinement;\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.mapNullable = exports.chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.option = {\n    URI: exports.URI,\n    map: _map,\n    of: exports.of,\n    ap: _ap,\n    chain: exports.flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    zero: exports.zero,\n    alt: _alt,\n    extend: _extend,\n    compact: exports.compact,\n    separate: exports.separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: exports.throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getFirstMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.first)()); };\nexports.getFirstMonoid = getFirstMonoid;\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getLastMonoid = function () { return (0, exports.getMonoid)((0, Semigroup_1.last)()); };\nexports.getLastMonoid = getLastMonoid;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tailRec = void 0;\n/**\n * @since 2.0.0\n */\nvar tailRec = function (startWith, f) {\n    var ab = f(startWith);\n    while (ab._tag === 'Left') {\n        ab = f(ab.left);\n    }\n    return ab.right;\n};\nexports.tailRec = tailRec;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.flatMap = exports.right = exports.left = void 0;\nexports.chainFirstW = exports.chainFirst = exports.chain = exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.tap = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = void 0;\nexports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = void 0;\nvar Applicative_1 = require(\"./Applicative\");\nvar Apply_1 = require(\"./Apply\");\nvar chainable = __importStar(require(\"./Chain\"));\nvar ChainRec_1 = require(\"./ChainRec\");\nvar FromEither_1 = require(\"./FromEither\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\nvar Separated_1 = require(\"./Separated\");\nvar Witherable_1 = require(\"./Witherable\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexports.right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexports.flatMap = (0, function_1.dual)(2, function (ma, f) { return ((0, exports.isLeft)(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\nvar _ap = function (fab, fa) { return (0, function_1.pipe)(fab, (0, exports.ap)(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return (0, function_1.pipe)(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g)); };\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return (0, function_1.pipe)(fa, (0, exports.alt)(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return (0, function_1.pipe)(wa, (0, exports.extend)(f)); };\nvar _chainRec = function (a, f) {\n    return (0, ChainRec_1.tailRec)(f(a), function (e) {\n        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nvar getShow = function (SE, SA) { return ({\n    show: function (ma) { return ((0, exports.isLeft)(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\nexports.getShow = getShow;\n/**\n * @category instances\n * @since 2.0.0\n */\nvar getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));\n    }\n}); };\nexports.getEq = getEq;\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nvar getSemigroup = function (S) { return ({\n    concat: function (x, y) { return ((0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right))); }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nvar getCompactable = function (M) {\n    var empty = (0, exports.left)(M.empty);\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        compact: function (ma) { return ((0, exports.isLeft)(ma) ? ma : ma.right._tag === 'None' ? empty : (0, exports.right)(ma.right.value)); },\n        separate: function (ma) {\n            return (0, exports.isLeft)(ma)\n                ? (0, Separated_1.separated)(ma, ma)\n                : (0, exports.isLeft)(ma.right)\n                    ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty)\n                    : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));\n        }\n    };\n};\nexports.getCompactable = getCompactable;\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nvar getFilterable = function (M) {\n    var empty = (0, exports.left)(M.empty);\n    var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return (0, exports.isLeft)(ma)\n            ? (0, Separated_1.separated)(ma, ma)\n            : p(ma.right)\n                ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right))\n                : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);\n    };\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if ((0, exports.isLeft)(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : (0, exports.right)(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if ((0, exports.isLeft)(ma)) {\n                return (0, Separated_1.separated)(ma, ma);\n            }\n            var e = f(ma.right);\n            return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));\n        }\n    };\n};\nexports.getFilterable = getFilterable;\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nvar getWitherable = function (M) {\n    var F_ = (0, exports.getFilterable)(M);\n    var C = (0, exports.getCompactable)(M);\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: exports.sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),\n        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)\n    };\n};\nexports.getWitherable = getWitherable;\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nvar getApplicativeValidation = function (SE) { return ({\n    URI: exports.URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return (0, exports.isLeft)(fab)\n            ? (0, exports.isLeft)(fa)\n                ? (0, exports.left)(SE.concat(fab.left, fa.left))\n                : fab\n            : (0, exports.isLeft)(fa)\n                ? fa\n                : (0, exports.right)(fab.right(fa.right));\n    },\n    of: exports.of\n}); };\nexports.getApplicativeValidation = getApplicativeValidation;\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nvar getAltValidation = function (SE) { return ({\n    URI: exports.URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if ((0, exports.isRight)(me)) {\n            return me;\n        }\n        var ea = that();\n        return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\nexports.getAltValidation = getAltValidation;\n/**\n * @category mapping\n * @since 2.0.0\n */\nvar map = function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));\n}; };\nexports.map = map;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexports.asUnit = (0, Functor_1.asUnit)(exports.Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexports.of = exports.right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nvar apW = function (fa) { return function (fab) {\n    return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));\n}; };\nexports.apW = apW;\n/**\n * @since 2.0.0\n */\nexports.ap = exports.apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Apply = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Applicative = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Chain = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Monad = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nvar reduce = function (b, f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? b : f(b, fa.right);\n}; };\nexports.reduce = reduce;\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nvar foldMap = function (M) { return function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);\n}; }; };\nexports.foldMap = foldMap;\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nvar reduceRight = function (b, f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? b : f(fa.right, b);\n}; };\nexports.reduceRight = reduceRight;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);\n        };\n    };\n};\nexports.traverse = traverse;\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);\n    };\n};\nexports.sequence = sequence;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nvar bimap = function (f, g) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));\n}; };\nexports.bimap = bimap;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nvar mapLeft = function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;\n}; };\nexports.mapLeft = mapLeft;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nvar altW = function (that) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? that() : fa;\n}; };\nexports.altW = altW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexports.alt = exports.altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Alt = {\n    URI: exports.URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nvar extend = function (f) { return function (wa) {\n    return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));\n}; };\nexports.extend = extend;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Extend = {\n    URI: exports.URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.ChainRec = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    chain: exports.flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexports.throwError = exports.left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.MonadThrow = {\n    URI: exports.URI,\n    map: _map,\n    ap: _ap,\n    of: exports.of,\n    chain: exports.flatMap,\n    throwError: exports.throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.FromEither = {\n    URI: exports.URI,\n    fromEither: function_1.identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexports.fromOption = \n/*#__PURE__*/ (0, FromEither_1.fromOption)(exports.FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexports.isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexports.isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nvar matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\nexports.matchW = matchW;\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.foldW = exports.matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.match = exports.matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexports.fold = exports.match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nvar getOrElseW = function (onLeft) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\nexports.getOrElseW = getOrElseW;\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexports.getOrElse = exports.getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexports.apFirst = (0, Apply_1.apFirst)(exports.Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexports.apFirstW = exports.apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexports.apSecond = (0, Apply_1.apSecond)(exports.Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexports.apSecondW = exports.apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexports.flattenW = \n/*#__PURE__*/ (0, exports.flatMap)(function_1.identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexports.flatten = exports.flattenW;\n/**\n * @since 2.0.0\n */\nexports.duplicate = (0, exports.extend)(function_1.identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexports.fromOptionK = \n/*#__PURE__*/ (0, FromEither_1.fromOptionK)(exports.FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexports.chainOptionKW = exports.chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: exports.FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexports.liftNullable = _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexports.liftOption = _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: exports.flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexports.filterOrElseW = exports.filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nvar swap = function (ma) { return ((0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right)); };\nexports.swap = swap;\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nvar orElseW = function (onLeft) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;\n    };\n};\nexports.orElseW = orElseW;\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexports.orElse = exports.orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nvar fromNullable = function (e) {\n    return function (a) {\n        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);\n    };\n};\nexports.fromNullable = fromNullable;\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nvar tryCatch = function (f, onThrow) {\n    try {\n        return (0, exports.right)(f());\n    }\n    catch (e) {\n        return (0, exports.left)(onThrow(e));\n    }\n};\nexports.tryCatch = tryCatch;\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nvar tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return (0, exports.tryCatch)(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\nexports.tryCatchK = tryCatchK;\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nvar fromNullableK = function (e) {\n    var from = (0, exports.fromNullable)(e);\n    return function (f) { return (0, function_1.flow)(f, from); };\n};\nexports.fromNullableK = fromNullableK;\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nvar chainNullableK = function (e) {\n    var from = (0, exports.fromNullableK)(e);\n    return function (f) { return (0, exports.flatMap)(from(f)); };\n};\nexports.chainNullableK = chainNullableK;\n/**\n * @category conversions\n * @since 2.10.0\n */\nexports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nfunction toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexports.toError = toError;\nfunction elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);\n    };\n}\nexports.elem = elem;\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nvar exists = function (predicate) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);\n    };\n};\nexports.exists = exists;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexports.Do = (0, exports.of)(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bindTo = (0, Functor_1.bindTo)(exports.Functor);\nvar let_ = /*#__PURE__*/ (0, Functor_1.let)(exports.Functor);\nexports.let = let_;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.bind = chainable.bind(exports.Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexports.bindW = exports.bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexports.apS = (0, Apply_1.apS)(exports.Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexports.apSW = exports.apS;\n/**\n * @since 2.11.0\n */\nexports.ApT = (0, exports.of)(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if ((0, exports.isLeft)(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if ((0, exports.isLeft)(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return (0, exports.right)(out);\n    };\n};\nexports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyArrayWithIndex = function (f) {\n    var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };\n};\nexports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nvar traverseArray = function (f) { return (0, exports.traverseReadonlyArrayWithIndex)(function (_, a) { return f(a); }); };\nexports.traverseArray = traverseArray;\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexports.sequenceArray = \n/*#__PURE__*/ (0, exports.traverseArray)(function_1.identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexports.chainW = exports.flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chain = exports.flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexports.chainFirst = exports.tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexports.chainFirstW = exports.tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction parseJSON(s, onError) {\n    return (0, exports.tryCatch)(function () { return JSON.parse(s); }, onError);\n}\nexports.parseJSON = parseJSON;\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar stringifyJSON = function (u, onError) {\n    return (0, exports.tryCatch)(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\nexports.stringifyJSON = stringifyJSON;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.either = {\n    URI: exports.URI,\n    map: _map,\n    of: exports.of,\n    ap: _ap,\n    chain: exports.flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: exports.throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplySemigroup = \n/*#__PURE__*/ (0, Apply_1.getApplySemigroup)(exports.Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getApplyMonoid = \n/*#__PURE__*/ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getValidationSemigroup = function (SE, SA) {\n    return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);\n};\nexports.getValidationSemigroup = getValidationSemigroup;\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar getValidationMonoid = function (SE, MA) {\n    return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);\n};\nexports.getValidationMonoid = getValidationMonoid;\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction getValidation(SE) {\n    var ap = (0, exports.getApplicativeValidation)(SE).ap;\n    var alt = (0, exports.getAltValidation)(SE).alt;\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        of: exports.of,\n        chain: exports.flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: exports.sequence,\n        chainRec: _chainRec,\n        throwError: exports.throwError,\n        ap: ap,\n        alt: alt\n    };\n}\nexports.getValidation = getValidation;\n",
  "\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.atReadonlyRecord = exports.at = exports.indexReadonlyRecord = exports.indexReadonlyNonEmptyArray = exports.indexReadonlyArray = exports.index = exports.traversalTraverse = exports.fromTraversable = exports.ApplicativeIdentity = exports.traversalComposeTraversal = exports.traversal = exports.optionalFindFirstNonEmpty = exports.optionalFindFirst = exports.optionalKey = exports.optionalIndexNonEmpty = exports.optionalIndex = exports.optionalComposeOptional = exports.optionalModify = exports.optionalModifyOption = exports.optionalAsTraversal = exports.optional = exports.prismLeft = exports.prismRight = exports.prismSome = exports.prismFromPredicate = exports.prismFromNullable = exports.prismComposeLens = exports.prismSet = exports.prismModify = exports.prismModifyOption = exports.prismAsTraversal = exports.prismAsOptional = exports.prism = exports.lensAtKey = exports.lensComponent = exports.lensProps = exports.lensProp = exports.lensId = exports.lensComposePrism = exports.prismComposePrism = exports.lensComposeLens = exports.lensAsTraversal = exports.lensAsOptional = exports.lens = exports.isoAsTraversal = exports.isoAsOptional = exports.isoAsPrism = exports.isoAsLens = exports.iso = void 0;\nvar RA = require(\"fp-ts/lib/ReadonlyArray\");\nvar RR = require(\"fp-ts/lib/ReadonlyRecord\");\nvar function_1 = require(\"fp-ts/lib/function\");\nvar O = require(\"fp-ts/lib/Option\");\nvar E = require(\"fp-ts/lib/Either\");\nvar pipeable_1 = require(\"fp-ts/lib/pipeable\");\n// -------------------------------------------------------------------------------------\n// Iso\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar iso = function (get, reverseGet) { return ({\n    get: get,\n    reverseGet: reverseGet\n}); };\nexports.iso = iso;\n/** @internal */\nvar isoAsLens = function (sa) { return (0, exports.lens)(sa.get, (0, function_1.flow)(sa.reverseGet, function_1.constant)); };\nexports.isoAsLens = isoAsLens;\n/** @internal */\nvar isoAsPrism = function (sa) { return (0, exports.prism)((0, function_1.flow)(sa.get, O.some), sa.reverseGet); };\nexports.isoAsPrism = isoAsPrism;\n/** @internal */\nvar isoAsOptional = function (sa) {\n    return (0, exports.optional)((0, function_1.flow)(sa.get, O.some), (0, function_1.flow)(sa.reverseGet, function_1.constant));\n};\nexports.isoAsOptional = isoAsOptional;\n/** @internal */\nvar isoAsTraversal = function (sa) {\n    return (0, exports.traversal)(function (F) { return function (f) { return function (s) {\n        return F.map(f(sa.get(s)), function (a) { return sa.reverseGet(a); });\n    }; }; });\n};\nexports.isoAsTraversal = isoAsTraversal;\n// -------------------------------------------------------------------------------------\n// Lens\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar lens = function (get, set) { return ({ get: get, set: set }); };\nexports.lens = lens;\n/** @internal */\nvar lensAsOptional = function (sa) { return (0, exports.optional)((0, function_1.flow)(sa.get, O.some), sa.set); };\nexports.lensAsOptional = lensAsOptional;\n/** @internal */\nvar lensAsTraversal = function (sa) {\n    return (0, exports.traversal)(function (F) { return function (f) { return function (s) { return F.map(f(sa.get(s)), function (a) { return sa.set(a)(s); }); }; }; });\n};\nexports.lensAsTraversal = lensAsTraversal;\n/** @internal */\nvar lensComposeLens = function (ab) { return function (sa) {\n    return (0, exports.lens)(function (s) { return ab.get(sa.get(s)); }, function (b) { return function (s) { return sa.set(ab.set(b)(sa.get(s)))(s); }; });\n}; };\nexports.lensComposeLens = lensComposeLens;\n/** @internal */\nvar prismComposePrism = function (ab) { return function (sa) {\n    return (0, exports.prism)((0, function_1.flow)(sa.getOption, O.chain(ab.getOption)), (0, function_1.flow)(ab.reverseGet, sa.reverseGet));\n}; };\nexports.prismComposePrism = prismComposePrism;\n/** @internal */\nvar lensComposePrism = function (ab) { return function (sa) {\n    return (0, exports.optionalComposeOptional)((0, exports.prismAsOptional)(ab))((0, exports.lensAsOptional)(sa));\n}; };\nexports.lensComposePrism = lensComposePrism;\n/** @internal */\nvar lensId = function () { return (0, exports.lens)(function_1.identity, function_1.constant); };\nexports.lensId = lensId;\n/** @internal */\nvar lensProp = function (prop) { return function (sa) {\n    return (0, exports.lens)(function (s) { return sa.get(s)[prop]; }, function (ap) { return function (s) {\n        var _a;\n        var oa = sa.get(s);\n        if (ap === oa[prop]) {\n            return s;\n        }\n        return sa.set(Object.assign({}, oa, (_a = {}, _a[prop] = ap, _a)))(s);\n    }; });\n}; };\nexports.lensProp = lensProp;\n/** @internal */\nvar lensProps = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return function (sa) {\n        return (0, exports.lens)(function (s) {\n            var a = sa.get(s);\n            var r = {};\n            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\n                var k = props_1[_i];\n                r[k] = a[k];\n            }\n            return r;\n        }, function (a) { return function (s) {\n            var oa = sa.get(s);\n            for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {\n                var k = props_2[_i];\n                if (a[k] !== oa[k]) {\n                    return sa.set(Object.assign({}, oa, a))(s);\n                }\n            }\n            return s;\n        }; });\n    };\n};\nexports.lensProps = lensProps;\n/** @internal */\nvar lensComponent = function (prop) { return function (sa) {\n    return (0, exports.lens)(function (s) { return sa.get(s)[prop]; }, function (ap) { return function (s) {\n        var oa = sa.get(s);\n        if (ap === oa[prop]) {\n            return s;\n        }\n        var copy = oa.slice();\n        copy[prop] = ap;\n        return sa.set(copy)(s);\n    }; });\n}; };\nexports.lensComponent = lensComponent;\n/** @internal */\nvar lensAtKey = function (key) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.lensComposeLens)(atReadonlyRecord().at(key)));\n}; };\nexports.lensAtKey = lensAtKey;\n// -------------------------------------------------------------------------------------\n// Prism\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar prism = function (getOption, reverseGet) { return ({ getOption: getOption, reverseGet: reverseGet }); };\nexports.prism = prism;\n/** @internal */\nvar prismAsOptional = function (sa) { return (0, exports.optional)(sa.getOption, function (a) { return (0, exports.prismSet)(a)(sa); }); };\nexports.prismAsOptional = prismAsOptional;\n/** @internal */\nvar prismAsTraversal = function (sa) {\n    return (0, exports.traversal)(function (F) { return function (f) { return function (s) {\n        return (0, pipeable_1.pipe)(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return (0, exports.prismSet)(a)(sa)(s); }); }));\n    }; }; });\n};\nexports.prismAsTraversal = prismAsTraversal;\n/** @internal */\nvar prismModifyOption = function (f) { return function (sa) { return function (s) {\n    return (0, pipeable_1.pipe)(sa.getOption(s), O.map(function (o) {\n        var n = f(o);\n        return n === o ? s : sa.reverseGet(n);\n    }));\n}; }; };\nexports.prismModifyOption = prismModifyOption;\n/** @internal */\nvar prismModify = function (f) { return function (sa) {\n    var g = (0, exports.prismModifyOption)(f)(sa);\n    return function (s) {\n        return (0, pipeable_1.pipe)(g(s), O.getOrElse(function () { return s; }));\n    };\n}; };\nexports.prismModify = prismModify;\n/** @internal */\nvar prismSet = function (a) { return (0, exports.prismModify)(function () { return a; }); };\nexports.prismSet = prismSet;\n/** @internal */\nvar prismComposeLens = function (ab) { return function (sa) {\n    return (0, exports.optionalComposeOptional)((0, exports.lensAsOptional)(ab))((0, exports.prismAsOptional)(sa));\n}; };\nexports.prismComposeLens = prismComposeLens;\n/** @internal */\nvar prismFromNullable = function () { return (0, exports.prism)(O.fromNullable, function_1.identity); };\nexports.prismFromNullable = prismFromNullable;\n/** @internal */\nvar prismFromPredicate = function (predicate) {\n    return (0, exports.prism)(O.fromPredicate(predicate), function_1.identity);\n};\nexports.prismFromPredicate = prismFromPredicate;\n/** @internal */\nvar prismSome = function () { return (0, exports.prism)(function_1.identity, O.some); };\nexports.prismSome = prismSome;\n/** @internal */\nvar prismRight = function () { return (0, exports.prism)(O.fromEither, E.right); };\nexports.prismRight = prismRight;\n/** @internal */\nvar prismLeft = function () {\n    return (0, exports.prism)(function (s) { return (E.isLeft(s) ? O.some(s.left) : O.none); }, // TODO: replace with E.getLeft in v3\n    E.left);\n};\nexports.prismLeft = prismLeft;\n// -------------------------------------------------------------------------------------\n// Optional\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar optional = function (getOption, set) { return ({\n    getOption: getOption,\n    set: set\n}); };\nexports.optional = optional;\n/** @internal */\nvar optionalAsTraversal = function (sa) {\n    return (0, exports.traversal)(function (F) { return function (f) { return function (s) {\n        return (0, pipeable_1.pipe)(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; });\n};\nexports.optionalAsTraversal = optionalAsTraversal;\n/** @internal */\nvar optionalModifyOption = function (f) { return function (optional) { return function (s) {\n    return (0, pipeable_1.pipe)(optional.getOption(s), O.map(function (a) {\n        var n = f(a);\n        return n === a ? s : optional.set(n)(s);\n    }));\n}; }; };\nexports.optionalModifyOption = optionalModifyOption;\n/** @internal */\nvar optionalModify = function (f) { return function (optional) {\n    var g = (0, exports.optionalModifyOption)(f)(optional);\n    return function (s) {\n        return (0, pipeable_1.pipe)(g(s), O.getOrElse(function () { return s; }));\n    };\n}; };\nexports.optionalModify = optionalModify;\n/** @internal */\nvar optionalComposeOptional = function (ab) { return function (sa) {\n    return (0, exports.optional)((0, function_1.flow)(sa.getOption, O.chain(ab.getOption)), function (b) { return (0, exports.optionalModify)(ab.set(b))(sa); });\n}; };\nexports.optionalComposeOptional = optionalComposeOptional;\n/** @internal */\nvar optionalIndex = function (i) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyArray)().index(i)));\n}; };\nexports.optionalIndex = optionalIndex;\n/** @internal */\nvar optionalIndexNonEmpty = function (i) { return function (sa) { return (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyNonEmptyArray)().index(i))); }; };\nexports.optionalIndexNonEmpty = optionalIndexNonEmpty;\n/** @internal */\nvar optionalKey = function (key) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.optionalComposeOptional)((0, exports.indexReadonlyRecord)().index(key)));\n}; };\nexports.optionalKey = optionalKey;\n/** @internal */\nvar optionalFindFirst = function (predicate) {\n    return (0, exports.optional)(RA.findFirst(predicate), function (a) { return function (s) {\n        return (0, pipeable_1.pipe)(RA.findIndex(predicate)(s), O.fold(function () { return s; }, function (i) { return RA.unsafeUpdateAt(i, a, s); }));\n    }; });\n};\nexports.optionalFindFirst = optionalFindFirst;\nvar unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = __spreadArray([as[0]], as.slice(1), true);\n        xs[i] = a;\n        return xs;\n    }\n};\n/** @internal */\nvar optionalFindFirstNonEmpty = function (predicate) {\n    return (0, exports.optional)(RA.findFirst(predicate), function (a) { return function (as) {\n        return (0, pipeable_1.pipe)(RA.findIndex(predicate)(as), O.fold(function () { return as; }, function (i) { return unsafeUpdateAt(i, a, as); }));\n    }; });\n};\nexports.optionalFindFirstNonEmpty = optionalFindFirstNonEmpty;\n// -------------------------------------------------------------------------------------\n// Traversal\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar traversal = function (modifyF) { return ({\n    modifyF: modifyF\n}); };\nexports.traversal = traversal;\n/** @internal */\nfunction traversalComposeTraversal(ab) {\n    return function (sa) { return (0, exports.traversal)(function (F) { return function (f) { return sa.modifyF(F)(ab.modifyF(F)(f)); }; }); };\n}\nexports.traversalComposeTraversal = traversalComposeTraversal;\n/** @internal */\nexports.ApplicativeIdentity = {\n    URI: 'Identity',\n    map: function (fa, f) { return f(fa); },\n    of: function_1.identity,\n    ap: \n    /* istanbul ignore next */\n    function (fab, fa) { return fab(fa); }\n};\nvar isIdentity = function (F) { return F.URI === 'Identity'; };\nfunction fromTraversable(T) {\n    return function () {\n        return (0, exports.traversal)(function (F) {\n            // if `F` is `Identity` then `traverseF = map`\n            var traverseF = isIdentity(F)\n                ? T.map\n                : T.traverse(F);\n            return function (f) { return function (s) { return traverseF(s, f); }; };\n        });\n    };\n}\nexports.fromTraversable = fromTraversable;\n/** @internal */\nfunction traversalTraverse(T) {\n    return traversalComposeTraversal(fromTraversable(T)());\n}\nexports.traversalTraverse = traversalTraverse;\n// -------------------------------------------------------------------------------------\n// Ix\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar index = function (index) { return ({ index: index }); };\nexports.index = index;\n/** @internal */\nvar indexReadonlyArray = function () {\n    return (0, exports.index)(function (i) {\n        return (0, exports.optional)(function (as) { return RA.lookup(i, as); }, function (a) { return function (as) {\n            return (0, pipeable_1.pipe)(RA.lookup(i, as), O.fold(function () { return as; }, function () { return RA.unsafeUpdateAt(i, a, as); }));\n        }; });\n    });\n};\nexports.indexReadonlyArray = indexReadonlyArray;\n/** @internal */\nvar indexReadonlyNonEmptyArray = function () {\n    return (0, exports.index)(function (i) {\n        return (0, exports.optional)(function (as) { return RA.lookup(i, as); }, function (a) { return function (as) {\n            return (0, pipeable_1.pipe)(RA.lookup(i, as), O.fold(function () { return as; }, function () { return unsafeUpdateAt(i, a, as); }));\n        }; });\n    });\n};\nexports.indexReadonlyNonEmptyArray = indexReadonlyNonEmptyArray;\n/** @internal */\nvar indexReadonlyRecord = function () {\n    return (0, exports.index)(function (k) {\n        return (0, exports.optional)(function (r) { return RR.lookup(k, r); }, function (a) { return function (r) {\n            if (r[k] === a || O.isNone(RR.lookup(k, r))) {\n                return r;\n            }\n            return RR.insertAt(k, a)(r);\n        }; });\n    });\n};\nexports.indexReadonlyRecord = indexReadonlyRecord;\n// -------------------------------------------------------------------------------------\n// At\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar at = function (at) { return ({ at: at }); };\nexports.at = at;\n/** @internal */\nfunction atReadonlyRecord() {\n    return (0, exports.at)(function (key) {\n        return (0, exports.lens)(function (r) { return RR.lookup(key, r); }, O.fold(function () { return RR.deleteAt(key); }, function (a) { return RR.insertAt(key, a); }));\n    });\n}\nexports.atReadonlyRecord = atReadonlyRecord;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Category = exports.Semigroupoid = exports.URI = exports.getAll = exports.fold = exports.foldMap = exports.findFirstNonEmpty = exports.findFirst = exports.traverse = exports.left = exports.right = exports.some = exports.atKey = exports.key = exports.indexNonEmpty = exports.index = exports.component = exports.props = exports.prop = exports.filter = exports.fromNullable = exports.set = exports.modify = exports.composeOptional = exports.composePrism = exports.composeLens = exports.composeIso = exports.composeTraversal = exports.compose = exports.fromTraversable = exports.id = exports.traversal = void 0;\nvar C = require(\"fp-ts/lib/Const\");\nvar function_1 = require(\"fp-ts/lib/function\");\nvar pipeable_1 = require(\"fp-ts/lib/pipeable\");\nvar RA = require(\"fp-ts/lib/ReadonlyArray\");\nvar _ = require(\"./internal\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexports.traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nvar id = function () { return (0, exports.traversal)(function (_) { return function (f) { return f; }; }); };\nexports.id = id;\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexports.fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexports.compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeTraversal = exports.compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeIso = \n/*#__PURE__*/\n(0, function_1.flow)(_.isoAsTraversal, exports.compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeLens = \n/*#__PURE__*/\n(0, function_1.flow)(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composePrism = \n/*#__PURE__*/\n(0, function_1.flow)(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeOptional = \n/*#__PURE__*/\n(0, function_1.flow)(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nvar modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\nexports.modify = modify;\n/**\n * @category combinators\n * @since 2.3.0\n */\nvar set = function (a) { return (0, exports.modify)(function () { return a; }); };\nexports.set = set;\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar fromNullable = function (sa) {\n    return (0, exports.composePrism)(_.prismFromNullable())(sa);\n};\nexports.fromNullable = fromNullable;\nfunction filter(predicate) {\n    return (0, exports.compose)(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\nexports.filter = filter;\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar prop = function (prop) {\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\nexports.prop = prop;\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\nexports.props = props;\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar component = function (prop) {\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\nexports.component = component;\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar index = function (i) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.compose)(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\nexports.index = index;\n/**\n * @category combinators\n * @since 2.3.8\n */\nvar indexNonEmpty = function (i) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.compose)(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\nexports.indexNonEmpty = indexNonEmpty;\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar key = function (key) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.compose)(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\nexports.key = key;\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar atKey = function (key) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.compose)(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\nexports.atKey = atKey;\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.some = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.right = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.left = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.traverse = _.traversalTraverse;\nfunction findFirst(predicate) {\n    return (0, exports.composeOptional)(_.optionalFindFirst(predicate));\n}\nexports.findFirst = findFirst;\nfunction findFirstNonEmpty(predicate) {\n    return (0, exports.composeOptional)(_.optionalFindFirstNonEmpty(predicate));\n}\nexports.findFirstNonEmpty = findFirstNonEmpty;\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\nexports.foldMap = foldMap;\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar fold = function (M) { return (0, exports.foldMap)(M)(function_1.identity); };\nexports.fold = fold;\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar getAll = function (s) { return function (sa) {\n    return (0, exports.foldMap)(RA.getMonoid())(RA.of)(sa)(s);\n}; };\nexports.getAll = getAll;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexports.Semigroupoid = {\n    URI: exports.URI,\n    compose: function (ab, ea) { return (0, exports.compose)(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.Category = {\n    URI: exports.URI,\n    compose: exports.Semigroupoid.compose,\n    id: exports.id\n};\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Category = exports.Semigroupoid = exports.Invariant = exports.URI = exports.imap = exports.findFirstNonEmpty = exports.findFirst = exports.traverse = exports.left = exports.right = exports.some = exports.atKey = exports.key = exports.indexNonEmpty = exports.index = exports.component = exports.props = exports.prop = exports.filter = exports.fromNullable = exports.modifyF = exports.modify = exports.composeTraversal = exports.composeOptional = exports.composePrism = exports.composeIso = exports.composeLens = exports.compose = exports.asTraversal = exports.asOptional = exports.id = exports.lens = void 0;\nvar function_1 = require(\"fp-ts/lib/function\");\nvar pipeable_1 = require(\"fp-ts/lib/pipeable\");\nvar _ = require(\"./internal\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexports.lens = _.lens;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexports.id = _.lensId;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Lens` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexports.asOptional = _.lensAsOptional;\n/**\n * View a `Lens` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexports.asTraversal = _.lensAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Lens` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexports.compose = _.lensComposeLens;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeLens = exports.compose;\n/**\n * Compose a `Lens` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeIso = \n/*#__PURE__*/\n(0, function_1.flow)(_.isoAsLens, exports.compose);\n/**\n * Compose a `Lens` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexports.composePrism = _.lensComposePrism;\n/**\n * Compose a `Lens` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nvar composeOptional = function (ab) {\n    return (0, function_1.flow)(exports.asOptional, _.optionalComposeOptional(ab));\n};\nexports.composeOptional = composeOptional;\n/**\n * Compose a `Lens` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nvar composeTraversal = function (ab) {\n    return (0, function_1.flow)(exports.asTraversal, _.traversalComposeTraversal(ab));\n};\nexports.composeTraversal = composeTraversal;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nvar modify = function (f) { return function (sa) { return function (s) {\n    var o = sa.get(s);\n    var n = f(o);\n    return o === n ? s : sa.set(n)(s);\n}; }; };\nexports.modify = modify;\nfunction modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return (0, pipeable_1.pipe)(sa.get(s), f, function (fa) { return F.map(fa, function (a) { return sa.set(a)(s); }); }); }; }; };\n}\nexports.modifyF = modifyF;\n/**\n * Return a `Optional` from a `Lens` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar fromNullable = function (sa) {\n    return (0, exports.composePrism)(_.prismFromNullable())(sa);\n};\nexports.fromNullable = fromNullable;\nfunction filter(predicate) {\n    return (0, exports.composePrism)(_.prismFromPredicate(predicate));\n}\nexports.filter = filter;\n/**\n * Return a `Lens` from a `Lens` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.prop = _.lensProp;\n/**\n * Return a `Lens` from a `Lens` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.props = _.lensProps;\n/**\n * Return a `Lens` from a `Lens` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.component = _.lensComponent;\n/**\n * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar index = function (i) {\n    return (0, function_1.flow)(exports.asOptional, _.optionalIndex(i));\n};\nexports.index = index;\n/**\n * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nvar indexNonEmpty = function (i) {\n    return (0, function_1.flow)(exports.asOptional, _.optionalIndexNonEmpty(i));\n};\nexports.indexNonEmpty = indexNonEmpty;\n/**\n * Return a `Optional` from a `Lens` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar key = function (key) {\n    return (0, function_1.flow)(exports.asOptional, _.optionalKey(key));\n};\nexports.key = key;\n/**\n * Return a `Lens` from a `Lens` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.atKey = _.lensAtKey;\n/**\n * Return a `Optional` from a `Lens` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.some = \n/*#__PURE__*/\n(0, exports.composePrism)(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Optional` from a `Lens` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.right = \n/*#__PURE__*/\n(0, exports.composePrism)(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Optional` from a `Lens` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.left = \n/*#__PURE__*/\n(0, exports.composePrism)(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Lens` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nfunction traverse(T) {\n    return (0, function_1.flow)(exports.asTraversal, _.traversalTraverse(T));\n}\nexports.traverse = traverse;\nfunction findFirst(predicate) {\n    return (0, exports.composeOptional)(_.optionalFindFirst(predicate));\n}\nexports.findFirst = findFirst;\nfunction findFirstNonEmpty(predicate) {\n    return (0, exports.composeOptional)(_.optionalFindFirstNonEmpty(predicate));\n}\nexports.findFirstNonEmpty = findFirstNonEmpty;\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nvar imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\nexports.imap = imap;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return (0, exports.lens)((0, function_1.flow)(ea.get, ab), (0, function_1.flow)(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.URI = 'monocle-ts/Lens';\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.Invariant = {\n    URI: exports.URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexports.Semigroupoid = {\n    URI: exports.URI,\n    compose: function (ab, ea) { return (0, exports.compose)(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.Category = {\n    URI: exports.URI,\n    compose: exports.Semigroupoid.compose,\n    id: exports.id\n};\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Category = exports.Semigroupoid = exports.Invariant = exports.URI = exports.imap = exports.findFirstNonEmpty = exports.findFirst = exports.traverse = exports.left = exports.right = exports.some = exports.atKey = exports.key = exports.indexNonEmpty = exports.index = exports.component = exports.props = exports.prop = exports.filter = exports.fromNullable = exports.modifyF = exports.modify = exports.setOption = exports.modifyOption = exports.composeTraversal = exports.composePrism = exports.composeLens = exports.composeIso = exports.composeOptional = exports.compose = exports.asTraversal = exports.id = exports.optional = void 0;\nvar function_1 = require(\"fp-ts/lib/function\");\nvar O = require(\"fp-ts/lib/Option\");\nvar pipeable_1 = require(\"fp-ts/lib/pipeable\");\nvar _ = require(\"./internal\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexports.optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nvar id = function () { return (0, exports.optional)(O.some, function_1.constant); };\nexports.id = id;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexports.asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexports.compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeOptional = exports.compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexports.composeIso = \n/*#__PURE__*/\n(0, function_1.flow)(_.isoAsOptional, exports.compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexports.composeLens = \n/*#__PURE__*/\n(0, function_1.flow)(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexports.composePrism = \n/*#__PURE__*/\n(0, function_1.flow)(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nvar composeTraversal = function (ab) {\n    return (0, function_1.flow)(exports.asTraversal, _.traversalComposeTraversal(ab));\n};\nexports.composeTraversal = composeTraversal;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexports.modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nvar setOption = function (a) { return (0, exports.modifyOption)(function () { return a; }); };\nexports.setOption = setOption;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexports.modify = _.optionalModify;\nfunction modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return (0, pipeable_1.pipe)(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\nexports.modifyF = modifyF;\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexports.fromNullable = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nfunction filter(predicate) {\n    return (0, exports.compose)(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\nexports.filter = filter;\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar prop = function (prop) {\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\nexports.prop = prop;\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\nexports.props = props;\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar component = function (prop) {\n    return (0, exports.compose)((0, pipeable_1.pipe)(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\nexports.component = component;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexports.indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nvar atKey = function (key) { return function (sa) {\n    return (0, pipeable_1.pipe)(sa, (0, exports.compose)(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\nexports.atKey = atKey;\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.some = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.right = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexports.left = \n/*#__PURE__*/\n(0, exports.compose)(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nfunction traverse(T) {\n    return (0, function_1.flow)(exports.asTraversal, _.traversalTraverse(T));\n}\nexports.traverse = traverse;\nfunction findFirst(predicate) {\n    return (0, exports.compose)(_.optionalFindFirst(predicate));\n}\nexports.findFirst = findFirst;\nfunction findFirstNonEmpty(predicate) {\n    return (0, exports.compose)(_.optionalFindFirstNonEmpty(predicate));\n}\nexports.findFirstNonEmpty = findFirstNonEmpty;\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nvar imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\nexports.imap = imap;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return (0, exports.optional)((0, function_1.flow)(ea.getOption, O.map(ab)), (0, function_1.flow)(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.Invariant = {\n    URI: exports.URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexports.Semigroupoid = {\n    URI: exports.URI,\n    compose: function (ab, ea) { return (0, exports.compose)(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexports.Category = {\n    URI: exports.URI,\n    compose: exports.Semigroupoid.compose,\n    id: exports.id\n};\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lensFromPath = exports.traversalFromPath = exports.optionalFromPath = exports.isPathTraversal = exports.isPathLens = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst A = __importStar(require(\"fp-ts/ReadonlyArray\"));\nconst R = __importStar(require(\"fp-ts/ReadonlyRecord\"));\nconst string_1 = require(\"fp-ts/string\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Op = __importStar(require(\"monocle-ts/lib/Optional\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst isPathLens = (path) => !split(path).some((s) => [\"?\", \"?some\", \"?left\", \"right\", \"[]>\", \"{}>\", \"[number]\", \"[string]\"].includes(s) ||\n    (!s.startsWith(\"(\") && s.includes(\":\")));\nexports.isPathLens = isPathLens;\nconst isPathTraversal = (path) => split(path).some((s) => [\"[]>\", \"{}>\"].includes(s));\nexports.isPathTraversal = isPathTraversal;\nconst lastSegment = (path) => {\n    if (path === \"\") {\n        return path;\n    }\n    const escapeable = path.match(/\\((.*)\\*(.*)\\)$/);\n    if (escapeable) {\n        return escapeable[2];\n    }\n    const escapeable2 = path.match(/\\((.*)\\)$/);\n    if (escapeable2) {\n        return escapeable2[0];\n    }\n    const finalSegment = path.match(/(.*)\\.(.*)/);\n    if (finalSegment) {\n        return finalSegment[2];\n    }\n    return path;\n};\nconst initSegment = (path) => {\n    if (path === \"\") {\n        return path;\n    }\n    const escapeable = path.match(/(.*)\\.\\((.*)\\*(.*)\\)$/);\n    if (escapeable) {\n        return escapeable[1];\n    }\n    return path.substring(0, path.lastIndexOf(lastSegment(path)) - 1);\n};\nconst splitIntoSegments = (path, acc = []) => {\n    const init = initSegment(path);\n    const last = lastSegment(path);\n    if (init === \"\") {\n        return [last, ...acc];\n    }\n    return splitIntoSegments(init, [last, ...acc]);\n};\nconst split = (path) => {\n    const segments = splitIntoSegments(path, []);\n    return segments.flatMap((segment) => {\n        if (segment.includes(\"?some\") ||\n            segment.includes(\"?left\") ||\n            segment.includes(\"?right\") ||\n            !segment.includes(\"?\")) {\n            return [segment];\n        }\n        else {\n            const before = segment.substring(0, segment.length - 1);\n            if (before.length > 0) {\n                return [before, \"?\"];\n            }\n            return [\"?\"];\n        }\n    });\n};\nconst optionalFromPath = (path, _indicies) => {\n    const indicies = [..._indicies];\n    const opt = split(path).reduce((acc, cur) => {\n        if (cur === \"?\") {\n            return (0, function_1.pipe)(acc, Op.fromNullable);\n        }\n        else if (cur === \"?some\") {\n            return (0, function_1.pipe)(acc, Op.some);\n        }\n        else if (cur === \"?left\") {\n            return (0, function_1.pipe)(acc, Op.left);\n        }\n        else if (cur === \"?right\") {\n            return (0, function_1.pipe)(acc, Op.left);\n        }\n        else if (cur === \"[number]\") {\n            return (0, function_1.pipe)(acc, Op.index(indicies.shift()));\n        }\n        else if (cur === \"[string]\") {\n            return (0, function_1.pipe)(acc, Op.key(indicies.shift()));\n        }\n        else if (cur.includes(\"[\") && cur.includes(\"]\") && cur.indexOf(\"[\") < cur.indexOf(\"]\")) {\n            const component = Number.parseInt(cur.substring(cur.indexOf(\"[\") + 1, cur.indexOf(\"]\")), 10);\n            return (0, function_1.pipe)(acc, Op.component(component));\n        }\n        else if (cur.includes(\":\")) {\n            const i = cur.indexOf(\":\");\n            const discriminant = cur.substring(0, i);\n            const member = cur.substring(i + 1, cur.length);\n            return (0, function_1.pipe)(acc, Op.filter((a) => a[discriminant] === member));\n        }\n        return (0, function_1.pipe)(acc, Op.prop(cur));\n    }, Op.id());\n    return opt;\n};\nexports.optionalFromPath = optionalFromPath;\nconst traversalFromPath = (path, _indicies) => {\n    const indicies = [..._indicies];\n    const opt = split(path).reduce((acc, cur) => {\n        if (cur === \"?\") {\n            return (0, function_1.pipe)(acc, Tr.fromNullable);\n        }\n        else if (cur === \"?some\") {\n            return (0, function_1.pipe)(acc, Tr.some);\n        }\n        else if (cur === \"?left\") {\n            return (0, function_1.pipe)(acc, Tr.left);\n        }\n        else if (cur === \"?right\") {\n            return (0, function_1.pipe)(acc, Tr.left);\n        }\n        else if (cur === \"[number]\") {\n            return (0, function_1.pipe)(acc, Tr.index(indicies.shift()));\n        }\n        else if (cur === \"[string]\") {\n            return (0, function_1.pipe)(acc, Tr.key(indicies.shift()));\n        }\n        else if (cur === \"[]>\") {\n            const a = (0, function_1.pipe)(acc, Tr.traverse(A.Traversable));\n            return a;\n        }\n        else if (cur === \"{}>\") {\n            const a = (0, function_1.pipe)(acc, Tr.traverse(R.getTraversable(string_1.Ord)));\n            return a;\n        }\n        else if (cur.includes(\"[\") && cur.includes(\"]\") && cur.indexOf(\"[\") < cur.indexOf(\"]\")) {\n            const component = Number.parseInt(cur.substring(cur.indexOf(\"[\") + 1, cur.indexOf(\"]\")), 10);\n            return (0, function_1.pipe)(acc, Tr.component(component));\n        }\n        else if (cur.includes(\":\")) {\n            const i = cur.indexOf(\":\");\n            const discriminant = cur.substring(0, i);\n            const member = cur.substring(i + 1, cur.length);\n            return (0, function_1.pipe)(acc, Tr.filter((a) => a[discriminant] === member));\n        }\n        return (0, function_1.pipe)(acc, Tr.prop(cur));\n    }, Tr.id());\n    return opt;\n};\nexports.traversalFromPath = traversalFromPath;\nconst lensFromPath = (path) => {\n    const lens = split(path).reduce((acc, cur) => {\n        if (cur.includes(\"[\") && cur.includes(\"]\") && cur.indexOf(\"[\") < cur.indexOf(\"]\")) {\n            const component = cur.substring(cur.indexOf(\"[\") + 1, cur.indexOf(\"]\"));\n            return (0, function_1.pipe)(acc, L.component(Number.parseInt(component, 10)));\n        }\n        return (0, function_1.pipe)(acc, L.prop(cur));\n    }, L.id());\n    return lens;\n};\nexports.lensFromPath = lensFromPath;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.get = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst get = (path, ...indicies) => {\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, monocle_1.lensFromPath)(path).get;\n    }\n    if ((0, monocle_1.isPathTraversal)(path)) {\n        return (v) => {\n            return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), Tr.getAll(v));\n        };\n    }\n    return (0, monocle_1.optionalFromPath)(path, indicies).getOption;\n};\nexports.get = get;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.set = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst set = (path, ...args) => (obj) => {\n    const indicies = args.slice(0, args.length - 1);\n    const val = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, monocle_1.lensFromPath)(path).set(val)(obj);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), Tr.set(val))(obj);\n};\nexports.set = set;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setOption = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst Optional_1 = require(\"monocle-ts/Optional\");\nconst Traversal_1 = require(\"monocle-ts/Traversal\");\nconst monocle_1 = require(\"../util/monocle\");\nconst setOption = (path, ...args) => (obj) => {\n    const indicies = args.slice(0, args.length - 1);\n    const val = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, monocle_1.lensFromPath)(path).set(val)(obj);\n    }\n    if ((0, monocle_1.isPathTraversal)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), (0, Traversal_1.set)(val))(obj);\n    }\n    return (0, function_1.pipe)((0, monocle_1.optionalFromPath)(path, indicies), (0, Optional_1.setOption)(val))(obj);\n};\nexports.setOption = setOption;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modify = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Traversal_1 = require(\"monocle-ts/Traversal\");\nconst monocle_1 = require(\"../util/monocle\");\nconst modify = (path, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const modFunc = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify(modFunc))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), (0, Traversal_1.modify)(modFunc))(a);\n};\nexports.modify = modify;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modifyOption = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Op = __importStar(require(\"monocle-ts/lib/Optional\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst modifyOption = (path, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const modFunc = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify(modFunc))(a);\n    }\n    if ((0, monocle_1.isPathTraversal)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), Tr.modify(modFunc))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.optionalFromPath)(path, indicies), Op.modifyOption(modFunc))(a);\n};\nexports.modifyOption = modifyOption;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modifyW = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Traversal_1 = require(\"monocle-ts/Traversal\");\nconst monocle_1 = require(\"../util/monocle\");\nconst modifyW = (path, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const modFunc = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify(modFunc))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), (0, Traversal_1.modify)(modFunc))(a);\n};\nexports.modifyW = modifyW;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modifyOptionW = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Op = __importStar(require(\"monocle-ts/lib/Optional\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst modifyOptionW = (path, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const modFunc = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify(modFunc))(a);\n    }\n    if ((0, monocle_1.isPathTraversal)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), Tr.modify(modFunc))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.optionalFromPath)(path, indicies), Op.modifyOption(modFunc))(a);\n};\nexports.modifyOptionW = modifyOptionW;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modifyF = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst modifyF = (F) => (path, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const modFunc = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modifyF(F)(modFunc))(a);\n    }\n    return (0, monocle_1.traversalFromPath)(path, indicies).modifyF(F)(modFunc)(a);\n};\nexports.modifyF = modifyF;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.upsert = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst upsert = (path, final, ...args) => (a) => {\n    const indicies = args.slice(0, args.length - 1);\n    const val = args[args.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify((obj) => ({ ...obj, [final]: val })))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, indicies), Tr.modify((obj) => ({ ...obj, [final]: val })))(a);\n};\nexports.upsert = upsert;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.remove = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst remove = (fullPath) => (a) => {\n    const segments = fullPath.split(\".\");\n    const path = segments.slice(0, segments.length - 1).join(\".\");\n    const final = segments[segments.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify((obj) => {\n            const omitted = { ...obj };\n            delete omitted[final];\n            return omitted;\n        }))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, []), Tr.modify((obj) => {\n        const omitted = { ...obj };\n        delete omitted[final];\n        return omitted;\n    }))(a);\n};\nexports.remove = remove;\n",
  "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rename = void 0;\nconst function_1 = require(\"fp-ts/function\");\nconst L = __importStar(require(\"monocle-ts/lib/Lens\"));\nconst Tr = __importStar(require(\"monocle-ts/lib/Traversal\"));\nconst monocle_1 = require(\"../util/monocle\");\nconst rename = (fullPath, newKey) => (a) => {\n    const segments = fullPath.split(\".\");\n    const path = segments.slice(0, segments.length - 1).join(\".\");\n    const final = segments[segments.length - 1];\n    if ((0, monocle_1.isPathLens)(path)) {\n        return (0, function_1.pipe)((0, monocle_1.lensFromPath)(path), L.modify(({ [final]: val, ...rest }) => ({ ...rest, [newKey]: val })))(a);\n    }\n    return (0, function_1.pipe)((0, monocle_1.traversalFromPath)(path, []), Tr.modify(({ [final]: val, ...rest }) => ({ ...rest, [newKey]: val })))(a);\n};\nexports.rename = rename;\n",
  "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rename = exports.remove = exports.upsert = exports.modifyF = exports.modifyOptionW = exports.modifyW = exports.modifyOption = exports.modify = exports.setOption = exports.set = exports.get = void 0;\nconst get_1 = require(\"./values/get\");\nObject.defineProperty(exports, \"get\", { enumerable: true, get: function () { return get_1.get; } });\nconst set_1 = require(\"./values/set\");\nObject.defineProperty(exports, \"set\", { enumerable: true, get: function () { return set_1.set; } });\nconst setOption_1 = require(\"./values/setOption\");\nObject.defineProperty(exports, \"setOption\", { enumerable: true, get: function () { return setOption_1.setOption; } });\nconst modify_1 = require(\"./values/modify\");\nObject.defineProperty(exports, \"modify\", { enumerable: true, get: function () { return modify_1.modify; } });\nconst modifyOption_1 = require(\"./values/modifyOption\");\nObject.defineProperty(exports, \"modifyOption\", { enumerable: true, get: function () { return modifyOption_1.modifyOption; } });\nconst modifyW_1 = require(\"./values/modifyW\");\nObject.defineProperty(exports, \"modifyW\", { enumerable: true, get: function () { return modifyW_1.modifyW; } });\nconst modifyOptionW_1 = require(\"./values/modifyOptionW\");\nObject.defineProperty(exports, \"modifyOptionW\", { enumerable: true, get: function () { return modifyOptionW_1.modifyOptionW; } });\nconst modifyF_1 = require(\"./values/modifyF\");\nObject.defineProperty(exports, \"modifyF\", { enumerable: true, get: function () { return modifyF_1.modifyF; } });\nconst upsert_1 = require(\"./values/upsert\");\nObject.defineProperty(exports, \"upsert\", { enumerable: true, get: function () { return upsert_1.upsert; } });\nconst remove_1 = require(\"./values/remove\");\nObject.defineProperty(exports, \"remove\", { enumerable: true, get: function () { return remove_1.remove; } });\nconst rename_1 = require(\"./values/rename\");\nObject.defineProperty(exports, \"rename\", { enumerable: true, get: function () { return rename_1.rename; } });\n",
  "module.exports = Spicetify.React",
  "module.exports = Spicetify.ReactDOM",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    /*#__PURE__*/ return dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    /*#__PURE__*/ return dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n",
  "/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nimport { tuple } from './function';\nimport * as _ from './internal';\nexport function ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexport function apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexport function apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexport function apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexport function getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nexport function sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nexport function sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n",
  "/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n",
  "/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n",
  "/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n    var f = getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n    var map = getFunctorComposition(F, G).map;\n    var _ap = ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return pipe(fgab, _ap(fga)); }\n    };\n}\n",
  "export function chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nexport function tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexport function bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n",
  "/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nimport * as _ from './internal';\nexport function fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nexport function fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nexport function fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return flow(f, from); };\n    };\n}\nexport function chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nexport function fromEitherK(F) {\n    return function (f) { return flow(f, F.fromEither); };\n}\nexport function chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nexport function chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nexport function filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nexport function tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = tap(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n",
  "/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nimport * as _ from './internal';\nexport function fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nexport function fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nexport function fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return flow(f, from); };\n    };\n}\nexport function chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nexport function fromEitherK(F) {\n    return function (f) { return flow(f, F.fromEither); };\n}\nexport function chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nexport function chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nexport function filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nexport function tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = tap(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n",
  "import { pipe } from './function';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var struct = function (eqs) {\n    return fromEquals(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleEq = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructEq = struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var strictEqual = eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eq = Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqBoolean = eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqString = eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqNumber = eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n",
  "import { eqStrict } from './Eq';\nimport { constant, constTrue, pipe } from './function';\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nexport var equalsDefault = function (compare) {\n    return function (first, second) {\n        return first === second || compare(first, second) === 0;\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromCompare = function (compare) { return ({\n    equals: equalsDefault(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return fromCompare(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\n/**\n * @since 2.10.0\n */\nexport var reverse = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return fromCompare(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: fromCompare(function () { return 0; })\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var trivial = {\n    equals: constTrue,\n    compare: /*#__PURE__*/ constant(0)\n};\n/**\n * @since 2.11.0\n */\nexport var equals = function (O) {\n    return function (second) {\n        return function (first) {\n            return first === second || O.compare(first, second) === 0;\n        };\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var lt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var gt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var leq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var geq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var min = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) < 1 ? first : second;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var max = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) > -1 ? first : second;\n    };\n};\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport var clamp = function (O) {\n    var minO = min(O);\n    var maxO = max(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport var between = function (O) {\n    var ltO = lt(O);\n    var gtO = gt(O);\n    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleOrd = tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualOrd = reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ord = Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordDate = /*#__PURE__*/ pipe(ordNumber, \n/*#__PURE__*/\ncontramap(function (date) { return date.valueOf(); }));\n",
  "/**\n * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`\n *\n * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.\n *\n * @since 2.0.0\n */\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Magma`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse, concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(reverse(N.MagmaSub))(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), 2)\n *\n * @since 2.11.0\n */\nexport var reverse = function (M) { return ({\n    concat: function (first, second) { return M.concat(second, first); }\n}); };\n/**\n * @since 2.11.0\n */\nexport var filterFirst = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }\n    }); };\n};\n/**\n * @since 2.11.0\n */\nexport var filterSecond = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }\n    }); };\n};\n/**\n * @since 2.11.0\n */\nexport var endo = function (f) {\n    return function (M) { return ({\n        concat: function (first, second) { return M.concat(f(first), f(second)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(N.MagmaSub)(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), -6)\n *\n * @since 2.11.0\n */\nexport var concatAll = function (M) {\n    return function (startWith) {\n        return function (as) {\n            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);\n        };\n    };\n};\n",
  "/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nimport { getSemigroup, identity } from './function';\nimport * as _ from './internal';\nimport * as M from './Magma';\nimport * as Or from './Ord';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (O) { return ({\n    concat: Or.min(O)\n}); };\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (O) { return ({\n    concat: Or.max(O)\n}); };\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nexport var intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var first = function () { return ({ concat: identity }); };\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var last = function () { return ({ concat: function (_, y) { return y; } }); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupVoid = constant(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastSemigroup = last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstSemigroup = first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleSemigroup = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructSemigroup = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualSemigroup = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinSemigroup = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetSemigroup = min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var getIntercalateSemigroup = intercalate;\nexport function fold(S) {\n    var concatAllS = concatAll(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionSemigroup = getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n",
  "/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nimport { getSemigroup, identity } from './function';\nimport * as _ from './internal';\nimport * as M from './Magma';\nimport * as Or from './Ord';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (O) { return ({\n    concat: Or.min(O)\n}); };\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (O) { return ({\n    concat: Or.max(O)\n}); };\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nexport var intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var first = function () { return ({ concat: identity }); };\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var last = function () { return ({ concat: function (_, y) { return y; } }); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupVoid = constant(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastSemigroup = last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstSemigroup = first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleSemigroup = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructSemigroup = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualSemigroup = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinSemigroup = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetSemigroup = min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var getIntercalateSemigroup = intercalate;\nexport function fold(S) {\n    var concatAllS = concatAll(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionSemigroup = getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n",
  "/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nimport { getSemigroup, identity } from './function';\nimport * as _ from './internal';\nimport * as M from './Magma';\nimport * as Or from './Ord';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (O) { return ({\n    concat: Or.min(O)\n}); };\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (O) { return ({\n    concat: Or.max(O)\n}); };\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nexport var intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var first = function () { return ({ concat: identity }); };\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var last = function () { return ({ concat: function (_, y) { return y; } }); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupVoid = constant(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastSemigroup = last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstSemigroup = first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleSemigroup = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructSemigroup = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualSemigroup = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinSemigroup = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetSemigroup = min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var getIntercalateSemigroup = intercalate;\nexport function fold(S) {\n    var concatAllS = concatAll(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionSemigroup = getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n",
  "/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nimport { getSemigroup, identity } from './function';\nimport * as _ from './internal';\nimport * as M from './Magma';\nimport * as Or from './Ord';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (O) { return ({\n    concat: Or.min(O)\n}); };\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (O) { return ({\n    concat: Or.max(O)\n}); };\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nexport var intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var first = function () { return ({ concat: identity }); };\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var last = function () { return ({ concat: function (_, y) { return y; } }); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupVoid = constant(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastSemigroup = last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstSemigroup = first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleSemigroup = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructSemigroup = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualSemigroup = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinSemigroup = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetSemigroup = min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var getIntercalateSemigroup = intercalate;\nexport function fold(S) {\n    var concatAllS = concatAll(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionSemigroup = getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n",
  "// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @category refinements\n * @since 2.11.0\n */\nexport var isNumber = function (u) { return typeof u === 'number'; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bounded = {\n    equals: Eq.equals,\n    compare: Ord.compare,\n    top: Infinity,\n    bottom: -Infinity\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (n) { return JSON.stringify(n); }\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var MagmaSub = {\n    concat: function (first, second) { return first - second; }\n};\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupSum = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupProduct = {\n    concat: function (first, second) { return first * second; }\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidSum = {\n    concat: SemigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidProduct = {\n    concat: SemigroupProduct.concat,\n    empty: 1\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Field = {\n    add: SemigroupSum.concat,\n    zero: 0,\n    mul: SemigroupProduct.concat,\n    one: 1,\n    sub: MagmaSub.concat,\n    degree: function (_) { return 1; },\n    div: function (first, second) { return first / second; },\n    mod: function (first, second) { return first % second; }\n};\n",
  "/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function (left, right) { return ({ left: left, right: right }); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\nvar _bimap = function (fa, g, f) { return pipe(fa, bimap(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = function (f) {\n    return function (fa) {\n        return separated(left(fa), f(right(fa)));\n    };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var mapLeft = function (f) {\n    return function (fa) {\n        return separated(f(left(fa)), right(fa));\n    };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var bimap = function (f, g) {\n    return function (fa) {\n        return separated(f(left(fa)), g(right(fa)));\n    };\n};\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function (s) { return s.left; };\n/**\n * @since 2.10.0\n */\nexport var right = function (s) { return s.right; };\n",
  "import * as _ from './internal';\nexport function wiltDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };\n    };\n}\nexport function witherDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };\n    };\n}\nexport function filterE(W) {\n    return function (F) {\n        var witherF = W.wither(F);\n        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };\n    };\n}\n",
  "export function guard(F, P) {\n    return function (b) { return (b ? P.of(undefined) : F.zero()); };\n}\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as NEA from './NonEmptyArray';\nimport * as RA from './ReadonlyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isEmpty([]), true)\n * assert.strictEqual(isEmpty(['a']), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`\n *\n * @example\n * import { isNonEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isNonEmpty([]), false)\n * assert.strictEqual(isNonEmpty(['a']), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNonEmpty = NEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = NEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @example\n * import { prependW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prependW(\"a\")), [\"a\", 2, 3, 4]);\n *\n * @since 2.11.0\n */\nexport var prependW = NEA.prependW;\n/**\n * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = NEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @example\n * import { appendW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], appendW(\"d\")), [1, 2, 3, \"d\"]);\n *\n * @since 2.11.0\n */\nexport var appendW = NEA.appendW;\n/**\n * Return a `Array` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/Array'\n *\n * const double = (i: number): number => i * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n * assert.deepStrictEqual(makeBy(-3, double), [])\n * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? [] : NEA.makeBy(f)(n)); };\n/**\n * Create a `Array` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n * assert.deepStrictEqual(replicate(-3, 'a'), [])\n * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : []); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * Create an array from an `Option`. The resulting array will contain the content of the\n * `Option` if it is `Some` and it will be empty if the `Option` is `None`.\n *\n * @example\n * import { fromOption } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(option.some(\"a\"), fromOption),[\"a\"])\n * assert.deepStrictEqual(pipe(option.none, fromOption),[])\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? [] : [ma.value]); };\n/**\n * Create an array from an `Either`. The resulting array will contain the content of the\n * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.\n *\n * @example\n * import { fromEither } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(either.right(\"r\"), fromEither), [\"r\"]);\n * assert.deepStrictEqual(pipe(either.left(\"l\"), fromEither), []);\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? [] : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @example\n * import { matchW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcherW = matchW(\n *   () => \"No elements\",\n *   (as) => as.length\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);\n * assert.deepStrictEqual(pipe([], matcherW), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` and returns the result.\n *\n * @example\n * import { match } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcher = match(\n *   () => \"No elements\",\n *   (as) => `Found ${as.length} element(s)`\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), \"Found 4 element(s)\");\n * assert.deepStrictEqual(pipe([], matcher), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchLeftW } from 'fp-ts/Array'\n *\n * const f = matchLeftW(\n *   () => 0,\n *   (head: string, tail: string[]) => `Found \"${head}\" followed by ${tail.length} elements`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found \"a\" followed by 2 elements');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchRightW } from 'fp-ts/Array'\n *\n * const f = matchRightW(\n *   () => 0,\n *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by \"${tail}\"`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found 2 elements folllowed by \"c\"');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.\n *\n * @example\n * import { matchRight } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchRight(\n *   () => 0,\n *   (head, _) => 1 + len(head)\n * );\n * assert.strictEqual(len([1, 2, 3]), 3);\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Same as [`chain`](#chain), but passing also the index to the iterating function.\n *\n * @example\n * import { chainWithIndex, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (index: number, x: string) => replicate(2, `${x}${index}`);\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], chainWithIndex(f)), [\"a0\", \"a0\", \"b1\", \"b1\", \"c2\", \"c2\"]);\n *\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * @example\n * import { scanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.0.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.0.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `Array`.\n *\n * @example\n * import { size } from 'fp-ts/Array'\n *\n * assert.strictEqual(size([\"a\",\"b\",\"c\"]),3)\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @example\n * import { isOutOfBound } from 'fp-ts/Array'\n *\n * assert.strictEqual(isOutOfBound(1,[\"a\",\"b\",\"c\"]),false)\n * assert.strictEqual(isOutOfBound(-1,[\"a\",\"b\",\"c\"]),true)\n * assert.strictEqual(isOutOfBound(3,[\"a\",\"b\",\"c\"]),true)\n *\n * @since 2.0.0\n */\nexport var isOutOfBound = NEA.isOutOfBound;\n// TODO: remove non-curried overloading in v3\n/**\n * This function provides a safe way to read a value at a particular index from an array.\n * It returns a `none` if the index is out of bounds, and a `some` of the element if the\n * index is valid.\n *\n * @example\n * import { lookup } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.0.0\n */\nexport var lookup = RA.lookup;\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.0.0\n */\nexport var head = RA.head;\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.0.0\n */\nexport var last = RA.last;\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.0.0\n */\nexport var tail = function (as) { return (isNonEmpty(as) ? _.some(NEA.tail(as)) : _.none); };\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.0.0\n */\nexport var init = function (as) { return (isNonEmpty(as) ? _.some(NEA.init(as)) : _.none); };\n/**\n * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);\n * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);\n * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        return out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);\n * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length);\n    };\n};\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);\n * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };\n}\n/**\n * `findIndex` returns an `Option` containing the first index for which a predicate holds.\n * It returns `None` if no element satisfies the predicate.\n * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.\n *\n * @example\n * import { findIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.0.0\n */\nexport var findIndex = RA.findIndex;\nexport function findFirst(predicate) {\n    return RA.findFirst(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array and\n * returns the first `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findFirstMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some(\"Mary\"));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findFirstMap = RA.findFirstMap;\nexport function findLast(predicate) {\n    return RA.findLast(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array starting from the\n * end and returns the last `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findLastMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some(\"Joey\"));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findLastMap = RA.findLastMap;\n/**\n * Returns the index of the last element of the list which matches the predicate.\n * It returns an `Option` containing the index or `None` if not found.\n *\n * @example\n * import { findLastIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n * @since 2.0.0\n */\nexport var findLastIndex = RA.findLastIndex;\n/**\n * This function takes an array and makes a new array containing the same elements.\n *\n * @since 2.0.0\n */\nexport var copy = function (as) { return as.slice(); };\n/**\n * Insert an element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { insertAt } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { updateAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) { return modifyAt(i, function () { return a; }); };\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.\n *\n * @example\n * import { deleteAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.0.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds.\n *\n * @example\n * import { modifyAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.0.0\n */\nexport var reverse = function (as) { return (isEmpty(as) ? [] : as.slice().reverse()); };\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Right` elements in the same order.\n *\n * @example\n * import { rights } from 'fp-ts/Array'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Left` elements in the same order.\n *\n * @example\n * import { lefts } from 'fp-ts/Array'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.0.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? copy(as) : as.slice().sort(O.compare);\n    };\n};\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.0.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.0.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Creates a new `Array`, prepending an element to every member of the input `Array`.\n *\n * @example\n * import { prependAll } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = NEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * Creates a new `Array` placing an element in between members of the input `Array`.\n *\n * @example\n * import { intersperse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = NEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Creates a new `Array` rotating the input `Array` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var rotate = function (n) {\n    var f = NEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an `Array<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.0.0\n */\nexport var elem = RA.elem;\n/**\n * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,\n * based on a `Eq<A>`.\n *\n * @example\n * import { uniq } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var uniq = function (E) {\n    var f = NEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/Array'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.0.0\n */\nexport var sortBy = function (ords) {\n    var f = NEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as A from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {\n *   return A.chop(as => {\n *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.0.0\n */\nexport var chop = function (f) {\n    var g = NEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : []); };\n};\n/**\n * Splits an `Array` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.0.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? NEA.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)];\n    };\n};\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.0.0\n */\nexport var chunksOf = function (n) {\n    var f = NEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(NEA.head(input), function (a) { return go(pipe(scope, append(a)), NEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : [];\n    };\n    return go([], input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? copy(second) : isEmpty(second) ? copy(first) : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = NEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second)\n            ? unionE(second)(first)\n            : isNonEmpty(first)\n                ? copy(first)\n                : copy(second);\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\nvar _chainRecDepthFirst = RA._chainRecDepthFirst;\nvar _chainRecBreadthFirst = RA._chainRecBreadthFirst;\n/**\n * Given an element of the base type, `of` builds an `Array` containing just that\n * element of the base type (this is useful for building a `Monad`).\n *\n * @example\n * import { of } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(of(\"a\"), [\"a\"]);\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var of = NEA.of;\n/**\n * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)\n *\n * @since 2.7.0\n */\nexport var zero = function () { return []; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.\n * In practice it applies the base function to each element of the array and collects the\n * results in a new array.\n *\n * @example\n * import { map } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => n * 2;\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };\n/**\n * @example\n * import { ap, map, of } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * // a curried function with 3 input parameteres\n * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;\n *\n * // let's use `ap` to iterate `f` over an array for each input parameter\n * assert.deepStrictEqual(pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"])), [\n *   \"a1\", \"a1\", \"a1\",\n *   \"a2\", \"a2\", \"a2\",\n *   \"b1\", \"b1\", \"b1\",\n *   \"b2\", \"b2\", \"b2\",\n * ]);\n *\n * // given Array implements the Applicative interface with the `of` method,\n * // we can write exactly the same thing in a more symmetric way\n * // using `of` on `f` and `ap` on each array in input\n * assert.deepStrictEqual(\n *   pipe(of(f), ap([\"a\", \"b\"]), ap([1, 2]), ap([\"\", \"\", \"\"])),\n *   pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"]))\n * );\n *\n * @since 2.0.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to\n * determine the next computation.\n *\n * In other words it takes a function `f` that produces an array from a single element of\n * the base type `A` and returns a new function which applies `f` to each element of the\n * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the\n * results into a single array (like [`flatten`](#flatten)).\n *\n * @example\n * import { flatMap, map, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => replicate(n, `${n}`);\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [[\"1\"], [\"2\", \"2\"], [\"3\", \"3\", \"3\"]]);\n * assert.deepStrictEqual(pipe([1, 2, 3], flatMap(f)), [\"1\", \"2\", \"2\", \"3\", \"3\", \"3\"]);\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * Takes an array of arrays of `A` and flattens them into an array of `A`\n * by concatenating the elements of each array in order.\n *\n * @example\n * import { flatten } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(flatten([[\"a\"], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]]), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * Same as [`map`](#map), but the iterating function takes both the index and the value\n * of the element.\n *\n * @example\n * import { mapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (i: number, s: string) => `${s} - ${i}`;\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], mapWithIndex(f)), [\"a - 0\", \"b - 1\", \"c - 2\"]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * Maps an array with an iterating function that takes the index and the value of\n * each element and returns an `Option`. It keeps only the `Some` values discarding\n * the `None`s.\n *\n * Same as [`filterMap`](#filterMap), but with an iterating function which takes also\n * the index as input.\n *\n * @example\n * import { filterMapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMapWithIndex(f)), [\"NO\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * Maps an array with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMap(f)), [\"A\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Compact an array of `Option`s discarding the `None` values and\n * keeping the `Some` values. It returns a new array containing the values of\n * the `Some` options.\n *\n * @example\n * import { compact } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n *\n * assert.deepStrictEqual(compact([option.some(\"a\"), option.none, option.some(\"b\")]), [\"a\", \"b\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:\n * one containing all the left values and one containing all the right values.\n *\n * @example\n * import { separate } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n *\n * assert.deepStrictEqual(separate([either.right(\"r1\"), either.left(\"l1\"), either.right(\"r2\")]), {\n *   left: [\"l1\"],\n *   right: [\"r1\", \"r2\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `filter` creates a new `Array` containing the elements of the original\n * `Array` for which the iterating function is `true`.\n *\n * @example\n * import { filter } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(filter(isString)([\"a\", 1, {}, \"b\", 5]), [\"a\", \"b\"]);\n * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `partition` creates two new `Array`s: `right` containing the elements of the original\n * `Array` for which the iterating function is `true`, `left` containing the elements\n * for which it is false.\n *\n * @example\n * import { partition } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(partition(isString)([\"a\", 1, {}, \"b\", 5]), { left: [1, {}, 5], right: [\"a\", \"b\"] });\n * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Same as [`partition`](#partition), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionWithIndex } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {\n *   left: [-2, 7],\n *   right: [5, 6],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var b = as[i];\n            if (predicateWithIndex(i, b)) {\n                right.push(b);\n            }\n            else {\n                left.push(b);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Given an iterating function that returns an `Either`,\n * `partitionMap` applies the iterating function to each element and it creates two `Array`s:\n * `right` containing the values of `Right` results, `left` containing the values of `Left` results.\n *\n * @example\n * import { partitionMap } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfString = <B>(x: B): Either<B, string> =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMap(upperIfString)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7],\n *   right: [ 'HELLO', 'WORLD' ],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return partitionMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionMapWithIndex } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>\n *   index < 3 && typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7, \"world\"],\n *   right: [\"HELLO\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Array` concatenates the inputs into a single array.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * Same as [`filter`](#filter), but passing also the index to the iterating function.\n *\n * @example\n * import { filterWithIndex } from 'fp-ts/Array';\n *\n * const f = (index: number, x: number) => x > 0 && index <= 2;\n * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (b, i) { return predicateWithIndex(i, b); });\n    };\n};\n/**\n * Given an iterating function that takes `Array<A>` as input, `extend` returns\n * an array containing the results of the iterating function applied to the whole input\n * `Array`, then to the input `Array` without the first element, then to the input\n * `Array` without the first two elements, etc.\n *\n * @example\n * import { extend } from 'fp-ts/Array'\n *\n * const f = (a: string[]) => a.join(\",\");\n * assert.deepStrictEqual(extend(f)([\"a\", \"b\", \"c\"]), [\"a,b,c\", \"b,c\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * `duplicate` returns an array containing the whole input `Array`,\n * then to the input `Array` dropping the first element, then to the input\n * `Array` dropping the first two elements, etc.\n *\n * @example\n * import { duplicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(duplicate([\"a\", \"b\", \"c\"]), [[\"a\", \"b\", \"c\"], [\"b\", \"c\"], [\"c\"]]);\n *\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Map and fold an `Array`.\n * Map the `Array` passing each value to the iterating function.\n * Then fold the results using the provided `Monoid`.\n *\n * @example\n * import { foldMap } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (s: string) => s.toUpperCase()\n * assert.deepStrictEqual(foldMap(monoid)(f)([\"a\", \"b\", \"c\"]), \"ABC\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RA.foldMap;\n/**\n * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.\n *\n * @example\n * import { foldMapWithIndex } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`\n * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)([\"a\", \"b\", \"c\"]), \"A(0)B(1)C(2)\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RA.foldMapWithIndex;\n/**\n * Reduces an `Array`.\n *\n * `reduce` executes the supplied iterating function on each element of the array,\n * in order, passing in the element and the return value from the calculation on the preceding element.\n *\n * The first time that the iterating function is called there is no \"return value of the\n * previous calculation\", the initial value is used in its place.\n *\n * @example\n * import { reduce } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RA.reduce;\n/**\n * Same as [`reduce`](#reduce) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, acc: string, cur: unknown) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"A1B2\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RA.reduceWithIndex;\n/**\n * Same as [`reduce`](#reduce) but applied from the end to the start.\n *\n * *Note*: the iterating function in this case takes the accumulator as the last argument.\n *\n * @example\n * import { reduceRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduceRight(\"\", (cur: string, acc: string) => acc + cur)([\"a\", \"b\", \"c\"]), \"cba\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RA.reduceRight;\n/**\n * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceRightWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, cur: unknown, acc: string) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceRightWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"B2A1\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RA.reduceRightWithIndex;\n/**\n * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`\n * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s\n * the results using the provided `Applicative`.\n *\n * E.g. suppose you have an `Array` and you want to format each element with a function\n * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`\n * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`\n * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results\n * are `Error`s.\n *\n * @example\n * import { traverse } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (x: unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", \"b\"]), right([\"A\", \"B\"]));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,\n * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.\n * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.\n *\n * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an\n * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an\n * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,\n * it needs an `Applicative` for `Option`.\n *\n * @example\n * import { sequence } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * assert.deepStrictEqual(sequence(Applicative)([right(\"a\"), right(\"b\")]), right([\"a\", \"b\"]));\n * assert.deepStrictEqual(\n *   sequence(Applicative)([right(\"a\"), left(new Error(\"not a string\"))]),\n *   left(new Error(\"not a string\"))\n * );\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * Same as [`traverse`](#traverse) but passing also the index to the iterating function.\n *\n * @example\n * import { traverseWithIndex } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (index:number, x:unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase() + index) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", \"b\"]), right([\"A0\", \"B1\"]));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome\n * value and an input for the following iteration.\n * `unfold` applies `f` to the initial value `b` and then recursively to the second\n * element of the tuple contained in the returned `option` of the previous\n * calculation until `f` returns `Option.none`.\n *\n * @example\n * import { unfold } from 'fp-ts/Array'\n * import { option } from 'fp-ts'\n *\n * const f = (n: number) => {\n *   if (n <= 0) return option.none;\n *   const returnValue = n * 2;\n *   const inputForNextRound = n - 1;\n *   return option.some([returnValue, inputForNextRound] as const);\n * };\n * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);\n *\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Array';\n/**\n * `getShow` makes a `Show` for an `Array<A>` from a `Show` for\n * an `A`.\n *\n * @example\n * import { getShow } from 'fp-ts/Array'\n *\n * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };\n * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), \"[(2), (1), 0, 1]\");\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RA.getShow;\n/**\n * Get a `Semigroup` based on the concatenation of `Array`s.\n * See also [`getMonoid`](#getMonoid).\n *\n * @example\n * import { getSemigroup } from 'fp-ts/Array'\n *\n * const S = getSemigroup<number>();\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return first.concat(second); }\n}); };\n/**\n * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.\n *\n * @example\n * import { getMonoid } from 'fp-ts/Array'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: []\n}); };\n/**\n * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/Array'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RA.getEq;\n/**\n * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/Array'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = RA.getOrd;\n/**\n * Get a `Semigroup` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n * See also [`getUnionMonoid`](#getUnionMonoid).\n *\n * @example\n * import { getUnionSemigroup } from 'fp-ts/Array';\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getUnionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * Get a `Monoid` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n *\n * @example\n * import { getUnionMonoid } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const M = getUnionMonoid<number>(Eq);\n * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(M.empty,[]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: []\n}); };\n/**\n * Get a `Semigroup` based on the intersection of the elements of `Array`s.\n * Only elements present in the two arrays which are equal according to the\n * provided `Eq` are included in the result.\n *\n * @example\n * import { getIntersectionSemigroup } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getIntersectionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * Get a `Magma` for `Array` where the `concat` function is the differnce between\n * the first and the second array, i.e. the result contains all the elements of the\n * first array for which their is no equal element in the second array according\n * to the `Eq` provided.\n *\n *\n * @example\n * import { getDifferenceMagma } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getDifferenceMagma<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Given an input an `Array` of functions, `flap` returns an `Array` containing\n * the results of applying each function to the given input.\n *\n * @example\n * import { flap } from 'fp-ts/Array'\n *\n * const funs = [\n *   (n: number) => `Double: ${n * 2}`,\n *   (n: number) => `Triple: ${n * 3}`,\n *   (n: number) => `Square: ${n * n}`,\n * ];\n * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = RA.chainRecDepthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = RA.chainRecBreadthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\n/**\n * Filter values inside a context.\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeInsertAt = NEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? NEA.unsafeUpdateAt(i, a, as) : [];\n};\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * `every` tells if the provided predicate holds true for every element in the `Array`.\n *\n * @example\n * import { every } from 'fp-ts/Array'\n *\n * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var every = RA.every;\n/**\n * `some` tells if the provided predicate holds true at least for one element in the `Array`.\n *\n * @example\n * import { some } from 'fp-ts/Array'\n *\n * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RA.intercalate;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `NonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var range = NEA.range;\n/**\n * Use a new `[]` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = [];\n/**\n * Use `prepend` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var cons = NEA.cons;\n/**\n * Use `append` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = NEA.snoc;\n/**\n * Use `prependAll` instead\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `A.Functor` instead of `A.array`\n * (where `A` is from `import A from 'fp-ts/Array'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var array = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as NEA from './NonEmptyArray';\nimport * as RA from './ReadonlyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isEmpty([]), true)\n * assert.strictEqual(isEmpty(['a']), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`\n *\n * @example\n * import { isNonEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isNonEmpty([]), false)\n * assert.strictEqual(isNonEmpty(['a']), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNonEmpty = NEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = NEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @example\n * import { prependW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prependW(\"a\")), [\"a\", 2, 3, 4]);\n *\n * @since 2.11.0\n */\nexport var prependW = NEA.prependW;\n/**\n * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = NEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @example\n * import { appendW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], appendW(\"d\")), [1, 2, 3, \"d\"]);\n *\n * @since 2.11.0\n */\nexport var appendW = NEA.appendW;\n/**\n * Return a `Array` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/Array'\n *\n * const double = (i: number): number => i * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n * assert.deepStrictEqual(makeBy(-3, double), [])\n * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? [] : NEA.makeBy(f)(n)); };\n/**\n * Create a `Array` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n * assert.deepStrictEqual(replicate(-3, 'a'), [])\n * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : []); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * Create an array from an `Option`. The resulting array will contain the content of the\n * `Option` if it is `Some` and it will be empty if the `Option` is `None`.\n *\n * @example\n * import { fromOption } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(option.some(\"a\"), fromOption),[\"a\"])\n * assert.deepStrictEqual(pipe(option.none, fromOption),[])\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? [] : [ma.value]); };\n/**\n * Create an array from an `Either`. The resulting array will contain the content of the\n * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.\n *\n * @example\n * import { fromEither } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(either.right(\"r\"), fromEither), [\"r\"]);\n * assert.deepStrictEqual(pipe(either.left(\"l\"), fromEither), []);\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? [] : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @example\n * import { matchW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcherW = matchW(\n *   () => \"No elements\",\n *   (as) => as.length\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);\n * assert.deepStrictEqual(pipe([], matcherW), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` and returns the result.\n *\n * @example\n * import { match } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcher = match(\n *   () => \"No elements\",\n *   (as) => `Found ${as.length} element(s)`\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), \"Found 4 element(s)\");\n * assert.deepStrictEqual(pipe([], matcher), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchLeftW } from 'fp-ts/Array'\n *\n * const f = matchLeftW(\n *   () => 0,\n *   (head: string, tail: string[]) => `Found \"${head}\" followed by ${tail.length} elements`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found \"a\" followed by 2 elements');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchRightW } from 'fp-ts/Array'\n *\n * const f = matchRightW(\n *   () => 0,\n *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by \"${tail}\"`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found 2 elements folllowed by \"c\"');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.\n *\n * @example\n * import { matchRight } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchRight(\n *   () => 0,\n *   (head, _) => 1 + len(head)\n * );\n * assert.strictEqual(len([1, 2, 3]), 3);\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Same as [`chain`](#chain), but passing also the index to the iterating function.\n *\n * @example\n * import { chainWithIndex, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (index: number, x: string) => replicate(2, `${x}${index}`);\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], chainWithIndex(f)), [\"a0\", \"a0\", \"b1\", \"b1\", \"c2\", \"c2\"]);\n *\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            out.push.apply(out, f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * @example\n * import { scanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.0.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.0.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `Array`.\n *\n * @example\n * import { size } from 'fp-ts/Array'\n *\n * assert.strictEqual(size([\"a\",\"b\",\"c\"]),3)\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @example\n * import { isOutOfBound } from 'fp-ts/Array'\n *\n * assert.strictEqual(isOutOfBound(1,[\"a\",\"b\",\"c\"]),false)\n * assert.strictEqual(isOutOfBound(-1,[\"a\",\"b\",\"c\"]),true)\n * assert.strictEqual(isOutOfBound(3,[\"a\",\"b\",\"c\"]),true)\n *\n * @since 2.0.0\n */\nexport var isOutOfBound = NEA.isOutOfBound;\n// TODO: remove non-curried overloading in v3\n/**\n * This function provides a safe way to read a value at a particular index from an array.\n * It returns a `none` if the index is out of bounds, and a `some` of the element if the\n * index is valid.\n *\n * @example\n * import { lookup } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.0.0\n */\nexport var lookup = RA.lookup;\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.0.0\n */\nexport var head = RA.head;\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.0.0\n */\nexport var last = RA.last;\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.0.0\n */\nexport var tail = function (as) { return (isNonEmpty(as) ? _.some(NEA.tail(as)) : _.none); };\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.0.0\n */\nexport var init = function (as) { return (isNonEmpty(as) ? _.some(NEA.init(as)) : _.none); };\n/**\n * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);\n * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);\n * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        return out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);\n * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length);\n    };\n};\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);\n * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };\n}\n/**\n * `findIndex` returns an `Option` containing the first index for which a predicate holds.\n * It returns `None` if no element satisfies the predicate.\n * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.\n *\n * @example\n * import { findIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.0.0\n */\nexport var findIndex = RA.findIndex;\nexport function findFirst(predicate) {\n    return RA.findFirst(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array and\n * returns the first `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findFirstMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some(\"Mary\"));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findFirstMap = RA.findFirstMap;\nexport function findLast(predicate) {\n    return RA.findLast(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array starting from the\n * end and returns the last `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findLastMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some(\"Joey\"));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findLastMap = RA.findLastMap;\n/**\n * Returns the index of the last element of the list which matches the predicate.\n * It returns an `Option` containing the index or `None` if not found.\n *\n * @example\n * import { findLastIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n * @since 2.0.0\n */\nexport var findLastIndex = RA.findLastIndex;\n/**\n * This function takes an array and makes a new array containing the same elements.\n *\n * @since 2.0.0\n */\nexport var copy = function (as) { return as.slice(); };\n/**\n * Insert an element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { insertAt } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { updateAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) { return modifyAt(i, function () { return a; }); };\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.\n *\n * @example\n * import { deleteAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.0.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds.\n *\n * @example\n * import { modifyAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.0.0\n */\nexport var reverse = function (as) { return (isEmpty(as) ? [] : as.slice().reverse()); };\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Right` elements in the same order.\n *\n * @example\n * import { rights } from 'fp-ts/Array'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Left` elements in the same order.\n *\n * @example\n * import { lefts } from 'fp-ts/Array'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.0.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? copy(as) : as.slice().sort(O.compare);\n    };\n};\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.0.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.0.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Creates a new `Array`, prepending an element to every member of the input `Array`.\n *\n * @example\n * import { prependAll } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = NEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * Creates a new `Array` placing an element in between members of the input `Array`.\n *\n * @example\n * import { intersperse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = NEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Creates a new `Array` rotating the input `Array` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var rotate = function (n) {\n    var f = NEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an `Array<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.0.0\n */\nexport var elem = RA.elem;\n/**\n * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,\n * based on a `Eq<A>`.\n *\n * @example\n * import { uniq } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var uniq = function (E) {\n    var f = NEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/Array'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.0.0\n */\nexport var sortBy = function (ords) {\n    var f = NEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as A from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {\n *   return A.chop(as => {\n *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.0.0\n */\nexport var chop = function (f) {\n    var g = NEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : []); };\n};\n/**\n * Splits an `Array` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.0.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? NEA.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)];\n    };\n};\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.0.0\n */\nexport var chunksOf = function (n) {\n    var f = NEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(NEA.head(input), function (a) { return go(pipe(scope, append(a)), NEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : [];\n    };\n    return go([], input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? copy(second) : isEmpty(second) ? copy(first) : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = NEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second)\n            ? unionE(second)(first)\n            : isNonEmpty(first)\n                ? copy(first)\n                : copy(second);\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\nvar _chainRecDepthFirst = RA._chainRecDepthFirst;\nvar _chainRecBreadthFirst = RA._chainRecBreadthFirst;\n/**\n * Given an element of the base type, `of` builds an `Array` containing just that\n * element of the base type (this is useful for building a `Monad`).\n *\n * @example\n * import { of } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(of(\"a\"), [\"a\"]);\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var of = NEA.of;\n/**\n * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)\n *\n * @since 2.7.0\n */\nexport var zero = function () { return []; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.\n * In practice it applies the base function to each element of the array and collects the\n * results in a new array.\n *\n * @example\n * import { map } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => n * 2;\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };\n/**\n * @example\n * import { ap, map, of } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * // a curried function with 3 input parameteres\n * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;\n *\n * // let's use `ap` to iterate `f` over an array for each input parameter\n * assert.deepStrictEqual(pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"])), [\n *   \"a1\", \"a1\", \"a1\",\n *   \"a2\", \"a2\", \"a2\",\n *   \"b1\", \"b1\", \"b1\",\n *   \"b2\", \"b2\", \"b2\",\n * ]);\n *\n * // given Array implements the Applicative interface with the `of` method,\n * // we can write exactly the same thing in a more symmetric way\n * // using `of` on `f` and `ap` on each array in input\n * assert.deepStrictEqual(\n *   pipe(of(f), ap([\"a\", \"b\"]), ap([1, 2]), ap([\"\", \"\", \"\"])),\n *   pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"]))\n * );\n *\n * @since 2.0.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to\n * determine the next computation.\n *\n * In other words it takes a function `f` that produces an array from a single element of\n * the base type `A` and returns a new function which applies `f` to each element of the\n * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the\n * results into a single array (like [`flatten`](#flatten)).\n *\n * @example\n * import { flatMap, map, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => replicate(n, `${n}`);\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [[\"1\"], [\"2\", \"2\"], [\"3\", \"3\", \"3\"]]);\n * assert.deepStrictEqual(pipe([1, 2, 3], flatMap(f)), [\"1\", \"2\", \"2\", \"3\", \"3\", \"3\"]);\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * Takes an array of arrays of `A` and flattens them into an array of `A`\n * by concatenating the elements of each array in order.\n *\n * @example\n * import { flatten } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(flatten([[\"a\"], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]]), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * Same as [`map`](#map), but the iterating function takes both the index and the value\n * of the element.\n *\n * @example\n * import { mapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (i: number, s: string) => `${s} - ${i}`;\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], mapWithIndex(f)), [\"a - 0\", \"b - 1\", \"c - 2\"]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * Maps an array with an iterating function that takes the index and the value of\n * each element and returns an `Option`. It keeps only the `Some` values discarding\n * the `None`s.\n *\n * Same as [`filterMap`](#filterMap), but with an iterating function which takes also\n * the index as input.\n *\n * @example\n * import { filterMapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMapWithIndex(f)), [\"NO\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * Maps an array with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMap(f)), [\"A\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Compact an array of `Option`s discarding the `None` values and\n * keeping the `Some` values. It returns a new array containing the values of\n * the `Some` options.\n *\n * @example\n * import { compact } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n *\n * assert.deepStrictEqual(compact([option.some(\"a\"), option.none, option.some(\"b\")]), [\"a\", \"b\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:\n * one containing all the left values and one containing all the right values.\n *\n * @example\n * import { separate } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n *\n * assert.deepStrictEqual(separate([either.right(\"r1\"), either.left(\"l1\"), either.right(\"r2\")]), {\n *   left: [\"l1\"],\n *   right: [\"r1\", \"r2\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `filter` creates a new `Array` containing the elements of the original\n * `Array` for which the iterating function is `true`.\n *\n * @example\n * import { filter } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(filter(isString)([\"a\", 1, {}, \"b\", 5]), [\"a\", \"b\"]);\n * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `partition` creates two new `Array`s: `right` containing the elements of the original\n * `Array` for which the iterating function is `true`, `left` containing the elements\n * for which it is false.\n *\n * @example\n * import { partition } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/lib/string\";\n *\n * assert.deepStrictEqual(partition(isString)([\"a\", 1, {}, \"b\", 5]), { left: [1, {}, 5], right: [\"a\", \"b\"] });\n * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Same as [`partition`](#partition), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionWithIndex } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {\n *   left: [-2, 7],\n *   right: [5, 6],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var b = as[i];\n            if (predicateWithIndex(i, b)) {\n                right.push(b);\n            }\n            else {\n                left.push(b);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Given an iterating function that returns an `Either`,\n * `partitionMap` applies the iterating function to each element and it creates two `Array`s:\n * `right` containing the values of `Right` results, `left` containing the values of `Left` results.\n *\n * @example\n * import { partitionMap } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfString = <B>(x: B): Either<B, string> =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMap(upperIfString)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7],\n *   right: [ 'HELLO', 'WORLD' ],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return partitionMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionMapWithIndex } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/lib/Either\";\n *\n * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>\n *   index < 3 && typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7, \"world\"],\n *   right: [\"HELLO\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Array` concatenates the inputs into a single array.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * Same as [`filter`](#filter), but passing also the index to the iterating function.\n *\n * @example\n * import { filterWithIndex } from 'fp-ts/Array';\n *\n * const f = (index: number, x: number) => x > 0 && index <= 2;\n * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (b, i) { return predicateWithIndex(i, b); });\n    };\n};\n/**\n * Given an iterating function that takes `Array<A>` as input, `extend` returns\n * an array containing the results of the iterating function applied to the whole input\n * `Array`, then to the input `Array` without the first element, then to the input\n * `Array` without the first two elements, etc.\n *\n * @example\n * import { extend } from 'fp-ts/Array'\n *\n * const f = (a: string[]) => a.join(\",\");\n * assert.deepStrictEqual(extend(f)([\"a\", \"b\", \"c\"]), [\"a,b,c\", \"b,c\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * `duplicate` returns an array containing the whole input `Array`,\n * then to the input `Array` dropping the first element, then to the input\n * `Array` dropping the first two elements, etc.\n *\n * @example\n * import { duplicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(duplicate([\"a\", \"b\", \"c\"]), [[\"a\", \"b\", \"c\"], [\"b\", \"c\"], [\"c\"]]);\n *\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Map and fold an `Array`.\n * Map the `Array` passing each value to the iterating function.\n * Then fold the results using the provided `Monoid`.\n *\n * @example\n * import { foldMap } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (s: string) => s.toUpperCase()\n * assert.deepStrictEqual(foldMap(monoid)(f)([\"a\", \"b\", \"c\"]), \"ABC\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RA.foldMap;\n/**\n * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.\n *\n * @example\n * import { foldMapWithIndex } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`\n * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)([\"a\", \"b\", \"c\"]), \"A(0)B(1)C(2)\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RA.foldMapWithIndex;\n/**\n * Reduces an `Array`.\n *\n * `reduce` executes the supplied iterating function on each element of the array,\n * in order, passing in the element and the return value from the calculation on the preceding element.\n *\n * The first time that the iterating function is called there is no \"return value of the\n * previous calculation\", the initial value is used in its place.\n *\n * @example\n * import { reduce } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RA.reduce;\n/**\n * Same as [`reduce`](#reduce) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, acc: string, cur: unknown) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"A1B2\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RA.reduceWithIndex;\n/**\n * Same as [`reduce`](#reduce) but applied from the end to the start.\n *\n * *Note*: the iterating function in this case takes the accumulator as the last argument.\n *\n * @example\n * import { reduceRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduceRight(\"\", (cur: string, acc: string) => acc + cur)([\"a\", \"b\", \"c\"]), \"cba\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RA.reduceRight;\n/**\n * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceRightWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, cur: unknown, acc: string) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceRightWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"B2A1\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RA.reduceRightWithIndex;\n/**\n * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`\n * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s\n * the results using the provided `Applicative`.\n *\n * E.g. suppose you have an `Array` and you want to format each element with a function\n * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`\n * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`\n * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results\n * are `Error`s.\n *\n * @example\n * import { traverse } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (x: unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", \"b\"]), right([\"A\", \"B\"]));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,\n * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.\n * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.\n *\n * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an\n * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an\n * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,\n * it needs an `Applicative` for `Option`.\n *\n * @example\n * import { sequence } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * assert.deepStrictEqual(sequence(Applicative)([right(\"a\"), right(\"b\")]), right([\"a\", \"b\"]));\n * assert.deepStrictEqual(\n *   sequence(Applicative)([right(\"a\"), left(new Error(\"not a string\"))]),\n *   left(new Error(\"not a string\"))\n * );\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * Same as [`traverse`](#traverse) but passing also the index to the iterating function.\n *\n * @example\n * import { traverseWithIndex } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/lib/Either\";\n *\n * const f = (index:number, x:unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase() + index) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", \"b\"]), right([\"A0\", \"B1\"]));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome\n * value and an input for the following iteration.\n * `unfold` applies `f` to the initial value `b` and then recursively to the second\n * element of the tuple contained in the returned `option` of the previous\n * calculation until `f` returns `Option.none`.\n *\n * @example\n * import { unfold } from 'fp-ts/Array'\n * import { option } from 'fp-ts'\n *\n * const f = (n: number) => {\n *   if (n <= 0) return option.none;\n *   const returnValue = n * 2;\n *   const inputForNextRound = n - 1;\n *   return option.some([returnValue, inputForNextRound] as const);\n * };\n * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);\n *\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Array';\n/**\n * `getShow` makes a `Show` for an `Array<A>` from a `Show` for\n * an `A`.\n *\n * @example\n * import { getShow } from 'fp-ts/Array'\n *\n * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };\n * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), \"[(2), (1), 0, 1]\");\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RA.getShow;\n/**\n * Get a `Semigroup` based on the concatenation of `Array`s.\n * See also [`getMonoid`](#getMonoid).\n *\n * @example\n * import { getSemigroup } from 'fp-ts/Array'\n *\n * const S = getSemigroup<number>();\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return first.concat(second); }\n}); };\n/**\n * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.\n *\n * @example\n * import { getMonoid } from 'fp-ts/Array'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: []\n}); };\n/**\n * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/Array'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RA.getEq;\n/**\n * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/Array'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = RA.getOrd;\n/**\n * Get a `Semigroup` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n * See also [`getUnionMonoid`](#getUnionMonoid).\n *\n * @example\n * import { getUnionSemigroup } from 'fp-ts/Array';\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getUnionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * Get a `Monoid` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n *\n * @example\n * import { getUnionMonoid } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const M = getUnionMonoid<number>(Eq);\n * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(M.empty,[]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: []\n}); };\n/**\n * Get a `Semigroup` based on the intersection of the elements of `Array`s.\n * Only elements present in the two arrays which are equal according to the\n * provided `Eq` are included in the result.\n *\n * @example\n * import { getIntersectionSemigroup } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getIntersectionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * Get a `Magma` for `Array` where the `concat` function is the differnce between\n * the first and the second array, i.e. the result contains all the elements of the\n * first array for which their is no equal element in the second array according\n * to the `Eq` provided.\n *\n *\n * @example\n * import { getDifferenceMagma } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getDifferenceMagma<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Given an input an `Array` of functions, `flap` returns an `Array` containing\n * the results of applying each function to the given input.\n *\n * @example\n * import { flap } from 'fp-ts/Array'\n *\n * const funs = [\n *   (n: number) => `Double: ${n * 2}`,\n *   (n: number) => `Triple: ${n * 3}`,\n *   (n: number) => `Square: ${n * n}`,\n * ];\n * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = RA.chainRecDepthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = RA.chainRecBreadthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\n/**\n * Filter values inside a context.\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeInsertAt = NEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? NEA.unsafeUpdateAt(i, a, as) : [];\n};\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * `every` tells if the provided predicate holds true for every element in the `Array`.\n *\n * @example\n * import { every } from 'fp-ts/Array'\n *\n * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var every = RA.every;\n/**\n * `some` tells if the provided predicate holds true at least for one element in the `Array`.\n *\n * @example\n * import { some } from 'fp-ts/Array'\n *\n * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RA.intercalate;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `NonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var range = NEA.range;\n/**\n * Use a new `[]` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = [];\n/**\n * Use `prepend` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var cons = NEA.cons;\n/**\n * Use `append` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = NEA.snoc;\n/**\n * Use `prependAll` instead\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `A.Functor` instead of `A.array`\n * (where `A` is from `import A from 'fp-ts/Array'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var array = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { constFalse, constTrue, flow, pipe } from './function';\nvar contramap_ = function (predicate, f) { return pipe(predicate, contramap(f)); };\n/**\n * @since 2.11.0\n */\nexport var contramap = function (f) {\n    return function (predicate) {\n        return flow(f, predicate);\n    };\n};\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexport var URI = 'Predicate';\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAny = function () { return ({\n    concat: function (first, second) { return pipe(first, or(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAny = function () { return ({\n    concat: getSemigroupAny().concat,\n    empty: constFalse\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAll = function () { return ({\n    concat: function (first, second) { return pipe(first, and(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAll = function () { return ({\n    concat: getSemigroupAll().concat,\n    empty: constTrue\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var not = function (predicate) {\n    return function (a) {\n        return !predicate(a);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var or = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) || second(a);\n        };\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var and = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) && second(a);\n        };\n    };\n};\n",
  "import { constFalse, constTrue, flow, pipe } from './function';\nvar contramap_ = function (predicate, f) { return pipe(predicate, contramap(f)); };\n/**\n * @since 2.11.0\n */\nexport var contramap = function (f) {\n    return function (predicate) {\n        return flow(f, predicate);\n    };\n};\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexport var URI = 'Predicate';\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAny = function () { return ({\n    concat: function (first, second) { return pipe(first, or(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAny = function () { return ({\n    concat: getSemigroupAny().concat,\n    empty: constFalse\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAll = function () { return ({\n    concat: function (first, second) { return pipe(first, and(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAll = function () { return ({\n    concat: getSemigroupAll().concat,\n    empty: constTrue\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var not = function (predicate) {\n    return function (a) {\n        return !predicate(a);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var or = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) || second(a);\n        };\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var and = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) && second(a);\n        };\n    };\n};\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n",
  "import { identity, pipe, unsafeCoerce } from './function';\nimport { flap as flap_ } from './Functor';\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var make = unsafeCoerce;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (c) { return \"make(\".concat(S.show(c), \")\"); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getOrd = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBounded = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemigroup = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemiring = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getRing = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getHeytingAlgebra = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBooleanAlgebra = identity;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply(S) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return make(S.concat(fab, fa)); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative(M) {\n    var A = getApply(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: A.map,\n        ap: A.ap,\n        of: function () { return make(M.empty); }\n    };\n}\nvar _contramap = function (fa, f) { return pipe(fa, contramap(f)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/**\n * @since 2.0.0\n */\nexport var contramap = function () { return unsafeCoerce; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function () { return unsafeCoerce; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.6.2\n */\nexport var bimap = function (f) { return function (fa) {\n    return make(f(fa));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var mapLeft = function (f) { return function (fa) { return make(f(fa)); }; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Const';\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: _contramap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `C.Functor` instead of `C.const_`\n * (where `C` is from `import C from 'fp-ts/Const'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var const_ = {\n    URI: URI,\n    map: _map,\n    contramap: _contramap,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n",
  "import { identity, pipe, unsafeCoerce } from './function';\nimport { flap as flap_ } from './Functor';\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var make = unsafeCoerce;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (c) { return \"make(\".concat(S.show(c), \")\"); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getOrd = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBounded = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemigroup = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemiring = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getRing = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getHeytingAlgebra = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBooleanAlgebra = identity;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply(S) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return make(S.concat(fab, fa)); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative(M) {\n    var A = getApply(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: A.map,\n        ap: A.ap,\n        of: function () { return make(M.empty); }\n    };\n}\nvar _contramap = function (fa, f) { return pipe(fa, contramap(f)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/**\n * @since 2.0.0\n */\nexport var contramap = function () { return unsafeCoerce; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function () { return unsafeCoerce; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.6.2\n */\nexport var bimap = function (f) { return function (fa) {\n    return make(f(fa));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var mapLeft = function (f) { return function (fa) { return make(f(fa)); }; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Const';\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: _contramap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `C.Functor` instead of `C.const_`\n * (where `C` is from `import C from 'fp-ts/Const'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var const_ = {\n    URI: URI,\n    map: _map,\n    contramap: _contramap,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n",
  "import { identity, pipe, unsafeCoerce } from './function';\nimport { flap as flap_ } from './Functor';\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var make = unsafeCoerce;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (c) { return \"make(\".concat(S.show(c), \")\"); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getOrd = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBounded = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemigroup = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemiring = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getRing = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getHeytingAlgebra = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBooleanAlgebra = identity;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply(S) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return make(S.concat(fab, fa)); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative(M) {\n    var A = getApply(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: A.map,\n        ap: A.ap,\n        of: function () { return make(M.empty); }\n    };\n}\nvar _contramap = function (fa, f) { return pipe(fa, contramap(f)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/**\n * @since 2.0.0\n */\nexport var contramap = function () { return unsafeCoerce; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function () { return unsafeCoerce; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.6.2\n */\nexport var bimap = function (f) { return function (fa) {\n    return make(f(fa));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var mapLeft = function (f) { return function (fa) { return make(f(fa)); }; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Const';\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: _contramap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `C.Functor` instead of `C.const_`\n * (where `C` is from `import C from 'fp-ts/Const'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var const_ = {\n    URI: URI,\n    map: _map,\n    contramap: _contramap,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n",
  "import { identity, pipe, unsafeCoerce } from './function';\nimport { flap as flap_ } from './Functor';\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var make = unsafeCoerce;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (c) { return \"make(\".concat(S.show(c), \")\"); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getOrd = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBounded = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemigroup = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getSemiring = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getRing = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getHeytingAlgebra = identity;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getBooleanAlgebra = identity;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApply(S) {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return make(S.concat(fab, fa)); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplicative(M) {\n    var A = getApply(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: A.map,\n        ap: A.ap,\n        of: function () { return make(M.empty); }\n    };\n}\nvar _contramap = function (fa, f) { return pipe(fa, contramap(f)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/**\n * @since 2.0.0\n */\nexport var contramap = function () { return unsafeCoerce; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function () { return unsafeCoerce; };\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.6.2\n */\nexport var bimap = function (f) { return function (fa) {\n    return make(f(fa));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var mapLeft = function (f) { return function (fa) { return make(f(fa)); }; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Const';\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: _contramap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `C.Functor` instead of `C.const_`\n * (where `C` is from `import C from 'fp-ts/Const'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var const_ = {\n    URI: URI,\n    map: _map,\n    contramap: _contramap,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = /*#__PURE__*/ chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    return e instanceof Error ? e : new Error(String(e));\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n",
  "/**\n * @since 2.11.0\n */\nimport { flow, identity } from './function';\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexport var URI = 'Endomorphism';\n/**\n * Endomorphism form a `Semigroup` where the `concat` operation is the usual function composition.\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return flow(first, second); }\n}); };\n/**\n * Endomorphism form a `Monoid` where the `empty` value is the `identity` function.\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: identity\n}); };\n",
  "/**\n * Lift a computation from the `IO` monad\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nexport function fromIOK(F) {\n    return function (f) { return flow(f, F.fromIO); };\n}\nexport function chainIOK(F, M) {\n    return function (f) {\n        var g = flow(f, F.fromIO);\n        return function (first) { return M.chain(first, g); };\n    };\n}\nexport function chainFirstIOK(F, M) {\n    var tapIOM = tapIO(F, M);\n    return function (f) { return function (first) { return tapIOM(first, f); }; };\n}\n/** @internal */\nexport function tapIO(F, M) {\n    var chainFirstM = tap(M);\n    return function (self, f) { return chainFirstM(self, flow(f, F.fromIO)); };\n}\n",
  "/**\n * Lift a computation from the `IO` monad\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nexport function fromIOK(F) {\n    return function (f) { return flow(f, F.fromIO); };\n}\nexport function chainIOK(F, M) {\n    return function (f) {\n        var g = flow(f, F.fromIO);\n        return function (first) { return M.chain(first, g); };\n    };\n}\nexport function chainFirstIOK(F, M) {\n    var tapIOM = tapIO(F, M);\n    return function (f) { return function (first) { return tapIOM(first, f); }; };\n}\n/** @internal */\nexport function tapIO(F, M) {\n    var chainFirstM = tap(M);\n    return function (self, f) { return chainFirstM(self, flow(f, F.fromIO)); };\n}\n",
  "import { fromEquals } from './Eq';\nimport { pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as O from './Option';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromMap = function (m) { return new Map(m); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport function toMap(m) {\n    return new Map(m);\n}\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getShow(SK, SA) {\n    return {\n        show: function (m) {\n            var entries = [];\n            m.forEach(function (a, k) {\n                entries.push(\"[\".concat(SK.show(k), \", \").concat(SA.show(a), \"]\"));\n            });\n            return \"new Map([\".concat(entries.sort().join(', '), \"])\");\n        }\n    };\n}\n/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.5.0\n */\nexport var size = function (m) { return m.size; };\n/**\n * Test whether or not a map is empty\n *\n * @since 2.5.0\n */\nexport var isEmpty = function (m) { return m.size === 0; };\nexport function member(E) {\n    var lookupE = lookup(E);\n    return function (k, m) {\n        if (m === undefined) {\n            var memberE_1 = member(E);\n            return function (m) { return memberE_1(k, m); };\n        }\n        return _.isSome(lookupE(k, m));\n    };\n}\nexport function elem(E) {\n    return function (a, m) {\n        if (m === undefined) {\n            var elemE_1 = elem(E);\n            return function (m) { return elemE_1(a, m); };\n        }\n        var values = m.values();\n        var e;\n        while (!(e = values.next()).done) {\n            var v = e.value;\n            if (E.equals(a, v)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the keys contained in a `ReadonlyMap`.\n *\n * @since 2.5.0\n */\nexport var keys = function (O) {\n    return function (m) {\n        return Array.from(m.keys()).sort(O.compare);\n    };\n};\n/**\n * Get a sorted `ReadonlyArray` of the values contained in a `ReadonlyMap`.\n *\n * @since 2.5.0\n */\nexport var values = function (O) {\n    return function (m) {\n        return Array.from(m.values()).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport function collect(O) {\n    var keysO = keys(O);\n    return function (f) {\n        return function (m) {\n            var out = [];\n            var ks = keysO(m);\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                out.push(f(key, m.get(key)));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyMap`.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = function (O) {\n    return collect(O)(function (k, a) { return [k, a]; });\n};\nexport function toUnfoldable(ord, U) {\n    var toReadonlyArrayO = toReadonlyArray(ord);\n    return function (d) {\n        var kas = toReadonlyArrayO(d);\n        var len = kas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([kas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyMap`.\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k, a) {\n        var lookupWithKeyEk = lookupWithKeyE(k);\n        return function (m) {\n            var found = lookupWithKeyEk(m);\n            if (_.isNone(found)) {\n                var out = new Map(m);\n                out.set(k, a);\n                return out;\n            }\n            else if (found.value[1] !== a) {\n                var out = new Map(m);\n                out.set(found.value[0], a);\n                return out;\n            }\n            return m;\n        };\n    };\n};\n/**\n * Delete a key and value from a map\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k) { return function (m) {\n        var found = lookupWithKeyE(k, m);\n        if (_.isSome(found)) {\n            var r = new Map(m);\n            r.delete(found.value[0]);\n            return r;\n        }\n        return m;\n    }; };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (E) {\n    var modifyAtE = modifyAt(E);\n    return function (k, a) { return modifyAtE(k, function () { return a; }); };\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k, f) { return function (m) {\n        var found = lookupWithKeyE(k, m);\n        if (_.isNone(found)) {\n            return _.none;\n        }\n        var _a = found.value, fk = _a[0], fv = _a[1];\n        var next = f(fv);\n        if (next === fv) {\n            return _.some(m);\n        }\n        var r = new Map(m);\n        r.set(fk, next);\n        return _.some(r);\n    }; };\n};\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.5.0\n */\nexport function pop(E) {\n    var lookupE = lookup(E);\n    var deleteAtE = deleteAt(E);\n    return function (k) {\n        var deleteAtEk = deleteAtE(k);\n        return function (m) {\n            return pipe(lookupE(k, m), O.map(function (a) { return [a, deleteAtEk(m)]; }));\n        };\n    };\n}\nexport function lookupWithKey(E) {\n    return function (k, m) {\n        if (m === undefined) {\n            var lookupWithKeyE_1 = lookupWithKey(E);\n            return function (m) { return lookupWithKeyE_1(k, m); };\n        }\n        var entries = m.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, ka = _a[0], a = _a[1];\n            if (E.equals(ka, k)) {\n                return _.some([ka, a]);\n            }\n        }\n        return _.none;\n    };\n}\nexport function lookup(E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k, m) {\n        if (m === undefined) {\n            var lookupE_1 = lookup(E);\n            return function (m) { return lookupE_1(k, m); };\n        }\n        return pipe(lookupWithKeyE(k, m), O.map(function (_a) {\n            var _ = _a[0], a = _a[1];\n            return a;\n        }));\n    };\n}\nexport function isSubmap(SK, SA) {\n    var lookupWithKeyS = lookupWithKey(SK);\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubmapSKSA_1 = isSubmap(SK, SA);\n            return function (that) { return isSubmapSKSA_1(that, me); };\n        }\n        var entries = me.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var d2OptA = lookupWithKeyS(k, that);\n            if (_.isNone(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * @since 2.5.0\n */\nexport var empty = \n// the type annotation here is intended (otherwise it doesn't type-check)\nnew Map();\n/**\n * @category instances\n * @since 2.5.0\n */\nexport function getEq(SK, SA) {\n    var isSubmapSKSA = isSubmap(SK, SA);\n    return fromEquals(function (x, y) { return isSubmapSKSA(x, y) && isSubmapSKSA(y, x); });\n}\n/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.5.0\n */\nexport function getMonoid(SK, SA) {\n    var lookupWithKeyS = lookupWithKey(SK);\n    return {\n        concat: function (mx, my) {\n            if (isEmpty(mx)) {\n                return my;\n            }\n            if (isEmpty(my)) {\n                return mx;\n            }\n            var r = new Map(mx);\n            var entries = my.entries();\n            var e;\n            while (!(e = entries.next()).done) {\n                var _a = e.value, k = _a[0], a = _a[1];\n                var mxOptA = lookupWithKeyS(k, mx);\n                if (_.isSome(mxOptA)) {\n                    r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));\n                }\n                else {\n                    r.set(k, a);\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * Create a map with one key/value pair\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) { return new Map([[k, a]]); };\nexport function fromFoldable(E, M, F) {\n    return function (fka) {\n        var lookupWithKeyE = lookupWithKey(E);\n        return F.reduce(fka, new Map(), function (b, _a) {\n            var k = _a[0], a = _a[1];\n            var bOpt = lookupWithKeyE(k, b);\n            if (_.isSome(bOpt)) {\n                b.set(bOpt.value[0], M.concat(bOpt.value[1], a));\n            }\n            else {\n                b.set(k, a);\n            }\n            return b;\n        });\n    };\n}\nvar _mapWithIndex = function (fa, f) {\n    var m = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, key = _a[0], a = _a[1];\n        m.set(key, f(key, a));\n    }\n    return m;\n};\n/**\n * @since 2.10.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = new Map();\n        var right = new Map();\n        var entries = fa.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var ei = f(k, a);\n            if (_.isLeft(ei)) {\n                left.set(k, ei.left);\n            }\n            else {\n                right.set(k, ei.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (m) {\n        var left = new Map();\n        var right = new Map();\n        var entries = m.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            if (predicateWithIndex(k, a)) {\n                right.set(k, a);\n            }\n            else {\n                left.set(k, a);\n            }\n        }\n        return separated(left, right);\n    };\n}\n/**\n * @since 2.10.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var m = new Map();\n        var entries = fa.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var o = f(k, a);\n            if (_.isSome(o)) {\n                m.set(k, o.value);\n            }\n        }\n        return m;\n    };\n};\nexport function filterWithIndex(predicateWithIndex) {\n    return function (m) {\n        var out = new Map();\n        var entries = m.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            if (predicateWithIndex(k, a)) {\n                out.set(k, a);\n            }\n        }\n        return out;\n    };\n}\nvar _map = function (fa, f) { return _mapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _filter = function (fa, p) {\n    return _filterWithIndex(fa, function (_, a) { return p(a); });\n};\nvar _filterMap = function (fa, f) { return _filterMapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _partition = function (fa, predicate) {\n    return _partitionWithIndex(fa, function (_, a) { return predicate(a); });\n};\nvar _partitionMap = function (fa, f) { return _partitionMapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _filterWithIndex = function (fa, p) { return pipe(fa, filterWithIndex(p)); };\nvar _filterMapWithIndex = function (fa, f) {\n    return pipe(fa, filterMapWithIndex(f));\n};\nvar _partitionWithIndex = function (fa, p) { return pipe(fa, partitionWithIndex(p)); };\nvar _partitionMapWithIndex = function (fa, f) {\n    return pipe(fa, partitionMapWithIndex(f));\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (fa) {\n    var m = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, k = _a[0], oa = _a[1];\n        if (_.isSome(oa)) {\n            m.set(k, oa.value);\n        }\n    }\n    return m;\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return _filter(fa, predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return _filterMap(fa, f);\n}; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) { return _map(fa, f); }; };\n/**\n * @category mapping\n * @since 2.7.1\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return _mapWithIndex(fa, f);\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return _partition(fa, predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) { return function (fa) { return _partitionMap(fa, f); }; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = new Map();\n    var right = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, k = _a[0], ei = _a[1];\n        if (_.isLeft(ei)) {\n            left.set(k, ei.left);\n        }\n        else {\n            right.set(k, ei.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyMap';\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E, S) {\n    var unionES = union(E, S);\n    return {\n        concat: function (first, second) { return unionES(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E, S) { return ({\n    concat: getUnionSemigroup(E, S).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E, S) {\n    var intersectionES = intersection(E, S);\n    return {\n        concat: function (first, second) { return intersectionES(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    return function () {\n        var differenceE = difference(E);\n        return {\n            concat: function (first, second) { return differenceE(second)(first); }\n        };\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport function getFilterableWithIndex() {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        mapWithIndex: _mapWithIndex,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        partitionMapWithIndex: _partitionMapWithIndex,\n        partitionWithIndex: _partitionWithIndex,\n        filterMapWithIndex: _filterMapWithIndex,\n        filterWithIndex: _filterWithIndex\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getFunctorWithIndex = function () { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduce = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (b, f) { return reduceWithIndexO(b, function (_, b, a) { return f(b, a); }); };\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var foldMap = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexOM = foldMapWithIndexO(M);\n        return function (f) { return foldMapWithIndexOM(function (_, a) { return f(a); }); };\n    };\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceRight = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (b, f) { return reduceRightWithIndexO(b, function (_, b, a) { return f(b, a); }); };\n};\n/**\n * @category folding\n * @since 2.10.0\n */\nexport var getFoldable = function (O) {\n    var reduceO = reduce(O);\n    var foldMapO = foldMap(O);\n    var reduceRightO = reduceRight(O);\n    return {\n        URI: URI,\n        _E: undefined,\n        reduce: function (fa, b, f) { return pipe(fa, reduceO(b, f)); },\n        foldMap: function (M) {\n            var foldMapOM = foldMapO(M);\n            return function (fa, f) { return pipe(fa, foldMapOM(f)); };\n        },\n        reduceRight: function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); }\n    };\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceWithIndex = function (O) {\n    var keysO = keys(O);\n    return function (b, f) { return function (m) {\n        var out = b;\n        for (var _i = 0, _a = keysO(m); _i < _a.length; _i++) {\n            var k = _a[_i];\n            out = f(k, out, m.get(k));\n        }\n        return out;\n    }; };\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var foldMapWithIndex = function (O) {\n    var keysO = keys(O);\n    return function (M) { return function (f) { return function (m) {\n        var out = M.empty;\n        for (var _i = 0, _a = keysO(m); _i < _a.length; _i++) {\n            var k = _a[_i];\n            out = M.concat(out, f(k, m.get(k)));\n        }\n        return out;\n    }; }; };\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceRightWithIndex = function (O) {\n    var keysO = keys(O);\n    return function (b, f) { return function (m) {\n        var out = b;\n        var ks = keysO(m);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, m.get(k), out);\n        }\n        return out;\n    }; };\n};\n/**\n * @category folding\n * @since 2.10.0\n */\nexport var getFoldableWithIndex = function (O) {\n    var F = getFoldable(O);\n    var reduceWithIndexO = reduceWithIndex(O);\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return {\n        URI: URI,\n        _E: undefined,\n        reduce: F.reduce,\n        foldMap: F.foldMap,\n        reduceRight: F.reduceRight,\n        reduceWithIndex: function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); },\n        foldMapWithIndex: function (M) {\n            var foldMapWithIndexOM = foldMapWithIndexO(M);\n            return function (fa, f) { return pipe(fa, foldMapWithIndexOM(f)); };\n        },\n        reduceRightWithIndex: function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); }\n    };\n};\n/**\n * @category traversing\n * @since 2.10.0\n */\nexport var getTraversable = function (O) {\n    var TWI = getTraversableWithIndex(O);\n    var F = getFoldable(O);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        reduce: F.reduce,\n        foldMap: F.foldMap,\n        reduceRight: F.reduceRight,\n        traverse: TWI.traverse,\n        sequence: TWI.sequence\n    };\n};\n/**\n * @category traversing\n * @since 2.10.0\n */\nexport var getTraversableWithIndex = function (O) {\n    var FWI = getFoldableWithIndex(O);\n    var keysO = keys(O);\n    var traverseWithIndex = function (F) {\n        return function (ta, f) {\n            var fm = F.of(new Map());\n            var ks = keysO(ta);\n            var len = ks.length;\n            var _loop_1 = function (i) {\n                var key = ks[i];\n                var a = ta.get(key);\n                fm = F.ap(F.map(fm, function (m) { return function (b) { return m.set(key, b); }; }), f(key, a));\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_1(i);\n            }\n            return fm;\n        };\n    };\n    var traverse = function (F) {\n        var traverseWithIndexF = traverseWithIndex(F);\n        return function (ta, f) { return traverseWithIndexF(ta, function (_, a) { return f(a); }); };\n    };\n    var sequence = function (F) {\n        var traverseWithIndexF = traverseWithIndex(F);\n        return function (ta) { return traverseWithIndexF(ta, SK); };\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        mapWithIndex: _mapWithIndex,\n        reduce: FWI.reduce,\n        foldMap: FWI.foldMap,\n        reduceRight: FWI.reduceRight,\n        reduceWithIndex: FWI.reduceWithIndex,\n        foldMapWithIndex: FWI.foldMapWithIndex,\n        reduceRightWithIndex: FWI.reduceRightWithIndex,\n        traverse: traverse,\n        sequence: sequence,\n        traverseWithIndex: traverseWithIndex\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport function getWitherable(O) {\n    var TWI = getTraversableWithIndex(O);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        reduce: TWI.reduce,\n        foldMap: TWI.foldMap,\n        reduceRight: TWI.reduceRight,\n        traverse: TWI.traverse,\n        sequence: TWI.sequence,\n        mapWithIndex: _mapWithIndex,\n        reduceWithIndex: TWI.reduceWithIndex,\n        foldMapWithIndex: TWI.foldMapWithIndex,\n        reduceRightWithIndex: TWI.reduceRightWithIndex,\n        traverseWithIndex: TWI.traverseWithIndex,\n        wilt: wiltDefault(TWI, Compactable),\n        wither: witherDefault(TWI, Compactable)\n    };\n}\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var union = function (E, M) {\n    var lookupE = lookup(E);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = new Map();\n        var firstEntries = first.entries();\n        var e;\n        while (!(e = firstEntries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var oka = lookupE(k)(second);\n            if (_.isSome(oka)) {\n                out.set(k, M.concat(a, oka.value));\n            }\n            else {\n                out.set(k, a);\n            }\n        }\n        var secondEntries = second.entries();\n        while (!(e = secondEntries.next()).done) {\n            var _b = e.value, k = _b[0], a = _b[1];\n            var oka = lookupE(k)(out);\n            if (_.isNone(oka)) {\n                out.set(k, a);\n            }\n        }\n        return out;\n    }; };\n};\n/**\n * @since 2.11.0\n */\nexport var intersection = function (E, M) {\n    var lookupE = lookup(E);\n    return function (second) { return function (first) {\n        if (isEmpty(first) || isEmpty(second)) {\n            return empty;\n        }\n        var out = new Map();\n        var entries = first.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var oka = lookupE(k)(second);\n            if (_.isSome(oka)) {\n                out.set(k, M.concat(a, oka.value));\n            }\n        }\n        return out;\n    }; };\n};\n/**\n * @since 2.11.0\n */\nexport var difference = function (E) {\n    var memberE = member(E);\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = new Map();\n            var firstEntries = first.entries();\n            var e;\n            while (!(e = firstEntries.next()).done) {\n                var _a = e.value, k = _a[0], a = _a[1];\n                if (!memberE(k)(second)) {\n                    out.set(k, a);\n                }\n            }\n            var secondEntries = second.entries();\n            while (!(e = secondEntries.next()).done) {\n                var _b = e.value, k = _b[0], a = _b[1];\n                if (!memberE(k)(first)) {\n                    out.set(k, a);\n                }\n            }\n            return out;\n        };\n    };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RM.Functor` instead of `RM.readonlyMap`\n * (where `RM` is from `import RM from 'fp-ts/ReadonlyMap'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyMap = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as O from './Option';\nimport * as RM from './ReadonlyMap';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RM.getShow;\n/**\n * Calculate the number of key/value pairs in a map\n *\n * @since 2.0.0\n */\nexport var size = RM.size;\n/**\n * Test whether or not a map is empty\n *\n * @since 2.0.0\n */\nexport var isEmpty = RM.isEmpty;\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not a key exists in a map\n *\n * @since 2.0.0\n */\nexport var member = RM.member;\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not a value is a member of a map\n *\n * @since 2.0.0\n */\nexport var elem = RM.elem;\n/**\n * Get a sorted `Array` of the keys contained in a `Map`.\n *\n * @since 2.0.0\n */\nexport var keys = function (O) {\n    return function (m) {\n        return Array.from(m.keys()).sort(O.compare);\n    };\n};\n/**\n * Get a sorted `Array` of the values contained in a `Map`.\n *\n * @since 2.0.0\n */\nexport var values = function (O) {\n    return function (m) {\n        return Array.from(m.values()).sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function collect(O) {\n    var keysO = keys(O);\n    return function (f) {\n        return function (m) {\n            var out = [];\n            var ks = keysO(m);\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                out.push(f(key, m.get(key)));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Map`.\n *\n * @since 2.0.0\n */\nexport function toArray(O) {\n    return collect(O)(function (k, a) { return [k, a]; });\n}\nexport function toUnfoldable(ord, U) {\n    var toArrayO = toArray(ord);\n    return function (d) {\n        var kas = toArrayO(d);\n        var len = kas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([kas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Map`.\n *\n * @since 2.0.0\n */\nexport var upsertAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k, a) {\n        var lookupWithKeyEk = lookupWithKeyE(k);\n        return function (m) {\n            var found = lookupWithKeyEk(m);\n            if (_.isNone(found)) {\n                var out = new Map(m);\n                out.set(k, a);\n                return out;\n            }\n            else if (found.value[1] !== a) {\n                var out = new Map(m);\n                out.set(found.value[0], a);\n                return out;\n            }\n            return m;\n        };\n    };\n};\n/**\n * Delete a key and value from a map\n *\n * @since 2.0.0\n */\nexport var deleteAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k) { return function (m) {\n        var found = lookupWithKeyE(k, m);\n        if (_.isSome(found)) {\n            var r = new Map(m);\n            r.delete(found.value[0]);\n            return r;\n        }\n        return m;\n    }; };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (E) {\n    var modifyAtE = modifyAt(E);\n    return function (k, a) { return modifyAtE(k, function () { return a; }); };\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (E) {\n    var lookupWithKeyE = lookupWithKey(E);\n    return function (k, f) { return function (m) {\n        var found = lookupWithKeyE(k, m);\n        if (_.isNone(found)) {\n            return _.none;\n        }\n        var r = new Map(m);\n        r.set(found.value[0], f(found.value[1]));\n        return _.some(r);\n    }; };\n};\n/**\n * Delete a key and value from a map, returning the value as well as the subsequent map\n *\n * @since 2.0.0\n */\nexport function pop(E) {\n    var lookupE = lookup(E);\n    var deleteAtE = deleteAt(E);\n    return function (k) {\n        var deleteAtEk = deleteAtE(k);\n        return function (m) {\n            return pipe(lookupE(k, m), O.map(function (a) { return [a, deleteAtEk(m)]; }));\n        };\n    };\n}\nexport function lookupWithKey(E) {\n    return function (k, m) {\n        if (m === undefined) {\n            var lookupWithKeyE_1 = lookupWithKey(E);\n            return function (m) { return lookupWithKeyE_1(k, m); };\n        }\n        var entries = m.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, ka = _a[0], a = _a[1];\n            if (E.equals(ka, k)) {\n                return _.some([ka, a]);\n            }\n        }\n        return _.none;\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Map`.\n *\n * @since 2.0.0\n */\nexport var lookup = RM.lookup;\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether or not one `Map` contains all of the keys and values contained in another `Map`\n *\n * @since 2.0.0\n */\nexport var isSubmap = RM.isSubmap;\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RM.getEq;\n/**\n * Gets `Monoid` instance for Maps given `Semigroup` instance for their values\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid(SK, SA) {\n    var lookupWithKeyS = lookupWithKey(SK);\n    return {\n        concat: function (mx, my) {\n            if (isEmpty(mx)) {\n                return my;\n            }\n            if (isEmpty(my)) {\n                return mx;\n            }\n            var r = new Map(mx);\n            var entries = my.entries();\n            var e;\n            while (!(e = entries.next()).done) {\n                var _a = e.value, k = _a[0], a = _a[1];\n                var mxOptA = lookupWithKeyS(k, mx);\n                if (_.isSome(mxOptA)) {\n                    r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));\n                }\n                else {\n                    r.set(k, a);\n                }\n            }\n            return r;\n        },\n        empty: new Map()\n    };\n}\n/**\n * Create a map with one key/value pair\n *\n * @since 2.0.0\n */\nexport var singleton = function (k, a) { return new Map([[k, a]]); };\nexport function fromFoldable(E, M, F) {\n    return function (fka) {\n        var lookupWithKeyE = lookupWithKey(E);\n        return F.reduce(fka, new Map(), function (b, _a) {\n            var k = _a[0], a = _a[1];\n            var bOpt = lookupWithKeyE(k, b);\n            if (_.isSome(bOpt)) {\n                b.set(bOpt.value[0], M.concat(bOpt.value[1], a));\n            }\n            else {\n                b.set(k, a);\n            }\n            return b;\n        });\n    };\n}\nvar _mapWithIndex = function (fa, f) {\n    var m = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, key = _a[0], a = _a[1];\n        m.set(key, f(key, a));\n    }\n    return m;\n};\n/**\n * @since 2.10.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = new Map();\n        var right = new Map();\n        var entries = fa.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var ei = f(k, a);\n            if (_.isLeft(ei)) {\n                left.set(k, ei.left);\n            }\n            else {\n                right.set(k, ei.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var left = new Map();\n        var right = new Map();\n        var entries = fa.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            if (predicateWithIndex(k, a)) {\n                right.set(k, a);\n            }\n            else {\n                left.set(k, a);\n            }\n        }\n        return separated(left, right);\n    };\n}\n/**\n * @since 2.10.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var m = new Map();\n        var entries = fa.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            var o = f(k, a);\n            if (_.isSome(o)) {\n                m.set(k, o.value);\n            }\n        }\n        return m;\n    };\n};\nexport function filterWithIndex(p) {\n    return function (m) {\n        var out = new Map();\n        var entries = m.entries();\n        var e;\n        while (!(e = entries.next()).done) {\n            var _a = e.value, k = _a[0], a = _a[1];\n            if (p(k, a)) {\n                out.set(k, a);\n            }\n        }\n        return out;\n    };\n}\nvar _map = function (fa, f) { return _mapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _filter = function (fa, p) {\n    return _filterWithIndex(fa, function (_, a) { return p(a); });\n};\nvar _filterMap = function (fa, f) { return _filterMapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _partition = function (fa, predicate) {\n    return _partitionWithIndex(fa, function (_, a) { return predicate(a); });\n};\nvar _partitionMap = function (fa, f) { return _partitionMapWithIndex(fa, function (_, a) { return f(a); }); };\nvar _filterWithIndex = function (fa, p) { return pipe(fa, filterWithIndex(p)); };\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _partitionWithIndex = function (fa, p) { return pipe(fa, partitionWithIndex(p)); };\nvar _partitionMapWithIndex = function (fa, f) {\n    return pipe(fa, partitionMapWithIndex(f));\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = function (fa) {\n    var m = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, k = _a[0], oa = _a[1];\n        if (_.isSome(oa)) {\n            m.set(k, oa.value);\n        }\n    }\n    return m;\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return _filter(fa, predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return _filterMap(fa, f);\n}; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return _map(fa, f); }; };\n/**\n * @category mapping\n * @since 2.7.1\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return _mapWithIndex(fa, f);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return _partition(fa, predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return function (fa) { return _partitionMap(fa, f); }; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (fa) {\n    var left = new Map();\n    var right = new Map();\n    var entries = fa.entries();\n    var e;\n    while (!(e = entries.next()).done) {\n        var _a = e.value, k = _a[0], ei = _a[1];\n        if (_.isLeft(ei)) {\n            left.set(k, ei.left);\n        }\n        else {\n            right.set(k, ei.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Map';\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E, S) {\n    var unionES = union(E, S);\n    return {\n        concat: function (first, second) { return unionES(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E, S) { return ({\n    concat: getUnionSemigroup(E, S).concat,\n    empty: new Map()\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E, S) {\n    var intersectionES = intersection(E, S);\n    return {\n        concat: function (first, second) { return intersectionES(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    return function () {\n        var differenceE = difference(E);\n        return {\n            concat: function (first, second) { return differenceE(second)(first); }\n        };\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport function getFilterableWithIndex() {\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        mapWithIndex: _mapWithIndex,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        partitionMapWithIndex: _partitionMapWithIndex,\n        partitionWithIndex: _partitionWithIndex,\n        filterMapWithIndex: _filterMapWithIndex,\n        filterWithIndex: _filterWithIndex\n    };\n}\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport function getWitherable(O) {\n    var TWI = getTraversableWithIndex(O);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        reduce: TWI.reduce,\n        foldMap: TWI.foldMap,\n        reduceRight: TWI.reduceRight,\n        traverse: TWI.traverse,\n        sequence: TWI.sequence,\n        mapWithIndex: _mapWithIndex,\n        reduceWithIndex: TWI.reduceWithIndex,\n        foldMapWithIndex: TWI.foldMapWithIndex,\n        reduceRightWithIndex: TWI.reduceRightWithIndex,\n        traverseWithIndex: TWI.traverseWithIndex,\n        wilt: wiltDefault(TWI, Compactable),\n        wither: witherDefault(TWI, Compactable)\n    };\n}\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduce = RM.reduce;\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var foldMap = RM.foldMap;\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceRight = RM.reduceRight;\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) {\n    return __assign(__assign({}, RM.getFoldable(O)), { URI: URI });\n};\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceWithIndex = RM.reduceWithIndex;\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var foldMapWithIndex = RM.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.11.0\n */\nexport var reduceRightWithIndex = RM.reduceRightWithIndex;\n/**\n * @category folding\n * @since 2.10.0\n */\nexport var getFoldableWithIndex = function (O) {\n    return __assign(__assign({}, RM.getFoldableWithIndex(O)), { URI: URI });\n};\n/**\n * @category traversing\n * @since 2.10.0\n */\nexport var getTraversableWithIndex = function (O) {\n    var FWI = getFoldableWithIndex(O);\n    var keysO = keys(O);\n    var traverseWithIndex = function (F) {\n        return function (ta, f) {\n            var fm = F.of(new Map());\n            var ks = keysO(ta);\n            var len = ks.length;\n            var _loop_1 = function (i) {\n                var key = ks[i];\n                var a = ta.get(key);\n                fm = F.ap(F.map(fm, function (m) { return function (b) { return m.set(key, b); }; }), f(key, a));\n            };\n            for (var i = 0; i < len; i++) {\n                _loop_1(i);\n            }\n            return fm;\n        };\n    };\n    var traverse = function (F) {\n        var traverseWithIndexF = traverseWithIndex(F);\n        return function (ta, f) { return traverseWithIndexF(ta, function (_, a) { return f(a); }); };\n    };\n    var sequence = function (F) {\n        var traverseWithIndexF = traverseWithIndex(F);\n        return function (ta) { return traverseWithIndexF(ta, function (_, a) { return a; }); };\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        mapWithIndex: _mapWithIndex,\n        reduce: FWI.reduce,\n        foldMap: FWI.foldMap,\n        reduceRight: FWI.reduceRight,\n        reduceWithIndex: FWI.reduceWithIndex,\n        foldMapWithIndex: FWI.foldMapWithIndex,\n        reduceRightWithIndex: FWI.reduceRightWithIndex,\n        traverse: traverse,\n        sequence: sequence,\n        traverseWithIndex: traverseWithIndex\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\nvar copy = function (m) { return new Map(m); };\n/**\n * @since 2.11.0\n */\nexport var union = function (E, M) {\n    var unionEM = RM.union(E, M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return copy(second);\n        }\n        if (isEmpty(second)) {\n            return copy(first);\n        }\n        return unionEM(second)(first);\n    }; };\n};\n/**\n * @since 2.11.0\n */\nexport var intersection = function (E, M) {\n    var intersectionEM = RM.intersection(E, M);\n    return function (second) { return function (first) {\n        if (isEmpty(first) || isEmpty(second)) {\n            return new Map();\n        }\n        return intersectionEM(second)(first);\n    }; };\n};\n/**\n * @since 2.11.0\n */\nexport var difference = function (E) {\n    var differenceE = RM.difference(E);\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return copy(second);\n            }\n            if (isEmpty(second)) {\n                return copy(first);\n            }\n            return differenceE(second)(first);\n        };\n    };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use a `new Map()` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = new Map();\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`Filterable`](#filterable) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var map_ = Filterable;\n",
  "import { getMonoid as getEM } from './Endomorphism';\nimport { getMonoid as getFM } from './function';\nimport * as _ from './internal';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.min(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (B) { return ({\n    concat: Se.min(B).concat,\n    empty: B.top\n}); };\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.max(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (B) { return ({\n    concat: Se.max(B).concat,\n    empty: B.bottom\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Monoid'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = function (M) { return ({\n    concat: Se.reverse(M).concat,\n    empty: M.empty\n}); };\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const M = struct<Point>({\n *   x: N.MonoidSum,\n *   y: N.MonoidSum\n * })\n *\n * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (monoids) {\n    var empty = {};\n    for (var k in monoids) {\n        if (_.has.call(monoids, k)) {\n            empty[k] = monoids[k].empty;\n        }\n    }\n    return {\n        concat: Se.struct(monoids).concat,\n        empty: empty\n    };\n};\n/**\n * Given a tuple of monoids returns a monoid for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Monoid'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const M1 = tuple(S.Monoid, N.MonoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return ({\n        concat: Se.tuple.apply(Se, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    });\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = function (M) { return Se.concatAll(M)(M.empty); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`Monoid`](./void.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidVoid = {\n    concat: Se.semigroupVoid.concat,\n    empty: undefined\n};\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleMonoid = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructMonoid = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualMonoid = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinMonoid = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetMonoid = min;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAll = {\n    concat: Se.semigroupAll.concat,\n    empty: true\n};\n/**\n * Use [`MonoidAny`](./boolean.ts.html#monoidany) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAny = {\n    concat: Se.semigroupAny.concat,\n    empty: false\n};\n/**\n * Use [`getMonoid`](./function.ts.html#getmonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionMonoid = getFM;\n/**\n * Use [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) instead.\n *\n * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) is reversed.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return reverse(getEM()); };\n/**\n * Use [`Monoid`](./string.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidString = {\n    concat: Se.semigroupString.concat,\n    empty: ''\n};\n/**\n * Use [`MonoidSum`](./number.ts.html#monoidsum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidSum = {\n    concat: Se.semigroupSum.concat,\n    empty: 0\n};\n/**\n * Use [`MonoidProduct`](./number.ts.html#monoidproduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidProduct = {\n    concat: Se.semigroupProduct.concat,\n    empty: 1\n};\n",
  "import { getMonoid as getEM } from './Endomorphism';\nimport { getMonoid as getFM } from './function';\nimport * as _ from './internal';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.min(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (B) { return ({\n    concat: Se.min(B).concat,\n    empty: B.top\n}); };\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.max(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (B) { return ({\n    concat: Se.max(B).concat,\n    empty: B.bottom\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Monoid'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = function (M) { return ({\n    concat: Se.reverse(M).concat,\n    empty: M.empty\n}); };\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const M = struct<Point>({\n *   x: N.MonoidSum,\n *   y: N.MonoidSum\n * })\n *\n * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (monoids) {\n    var empty = {};\n    for (var k in monoids) {\n        if (_.has.call(monoids, k)) {\n            empty[k] = monoids[k].empty;\n        }\n    }\n    return {\n        concat: Se.struct(monoids).concat,\n        empty: empty\n    };\n};\n/**\n * Given a tuple of monoids returns a monoid for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Monoid'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const M1 = tuple(S.Monoid, N.MonoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return ({\n        concat: Se.tuple.apply(Se, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    });\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = function (M) { return Se.concatAll(M)(M.empty); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`Monoid`](./void.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidVoid = {\n    concat: Se.semigroupVoid.concat,\n    empty: undefined\n};\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleMonoid = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructMonoid = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualMonoid = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinMonoid = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetMonoid = min;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAll = {\n    concat: Se.semigroupAll.concat,\n    empty: true\n};\n/**\n * Use [`MonoidAny`](./boolean.ts.html#monoidany) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAny = {\n    concat: Se.semigroupAny.concat,\n    empty: false\n};\n/**\n * Use [`getMonoid`](./function.ts.html#getmonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionMonoid = getFM;\n/**\n * Use [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) instead.\n *\n * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) is reversed.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return reverse(getEM()); };\n/**\n * Use [`Monoid`](./string.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidString = {\n    concat: Se.semigroupString.concat,\n    empty: ''\n};\n/**\n * Use [`MonoidSum`](./number.ts.html#monoidsum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidSum = {\n    concat: Se.semigroupSum.concat,\n    empty: 0\n};\n/**\n * Use [`MonoidProduct`](./number.ts.html#monoidproduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidProduct = {\n    concat: Se.semigroupProduct.concat,\n    empty: 1\n};\n",
  "import { getMonoid as getEM } from './Endomorphism';\nimport { getMonoid as getFM } from './function';\nimport * as _ from './internal';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.min(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (B) { return ({\n    concat: Se.min(B).concat,\n    empty: B.top\n}); };\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.max(N.Bounded)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (B) { return ({\n    concat: Se.max(B).concat,\n    empty: B.bottom\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Monoid'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = function (M) { return ({\n    concat: Se.reverse(M).concat,\n    empty: M.empty\n}); };\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const M = struct<Point>({\n *   x: N.MonoidSum,\n *   y: N.MonoidSum\n * })\n *\n * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (monoids) {\n    var empty = {};\n    for (var k in monoids) {\n        if (_.has.call(monoids, k)) {\n            empty[k] = monoids[k].empty;\n        }\n    }\n    return {\n        concat: Se.struct(monoids).concat,\n        empty: empty\n    };\n};\n/**\n * Given a tuple of monoids returns a monoid for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Monoid'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const M1 = tuple(S.Monoid, N.MonoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return ({\n        concat: Se.tuple.apply(Se, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    });\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = function (M) { return Se.concatAll(M)(M.empty); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`Monoid`](./void.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidVoid = {\n    concat: Se.semigroupVoid.concat,\n    empty: undefined\n};\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleMonoid = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructMonoid = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualMonoid = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinMonoid = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetMonoid = min;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAll = {\n    concat: Se.semigroupAll.concat,\n    empty: true\n};\n/**\n * Use [`MonoidAny`](./boolean.ts.html#monoidany) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidAny = {\n    concat: Se.semigroupAny.concat,\n    empty: false\n};\n/**\n * Use [`getMonoid`](./function.ts.html#getmonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionMonoid = getFM;\n/**\n * Use [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) instead.\n *\n * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) is reversed.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return reverse(getEM()); };\n/**\n * Use [`Monoid`](./string.ts.html#monoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidString = {\n    concat: Se.semigroupString.concat,\n    empty: ''\n};\n/**\n * Use [`MonoidSum`](./number.ts.html#monoidsum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidSum = {\n    concat: Se.semigroupSum.concat,\n    empty: 0\n};\n/**\n * Use [`MonoidProduct`](./number.ts.html#monoidproduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var monoidProduct = {\n    concat: Se.semigroupProduct.concat,\n    empty: 1\n};\n",
  "import { apFirst as apFirst_, apSecond as apSecond_ } from './Apply';\nimport { chainFirst as chainFirst_ } from './Chain';\nimport { identity, pipe as pipeFromFunctionModule } from './function';\nexport function map(F) {\n    return function (f) { return function (fa) { return F.map(fa, f); }; };\n}\nexport function contramap(F) {\n    return function (f) { return function (fa) { return F.contramap(fa, f); }; };\n}\nexport function mapWithIndex(F) {\n    return function (f) { return function (fa) { return F.mapWithIndex(fa, f); }; };\n}\nexport function ap(F) {\n    return function (fa) { return function (fab) { return F.ap(fab, fa); }; };\n}\nexport function chain(F) {\n    return function (f) { return function (fa) { return F.chain(fa, f); }; };\n}\nexport function bimap(F) {\n    return function (f, g) { return function (fea) { return F.bimap(fea, f, g); }; };\n}\nexport function mapLeft(F) {\n    return function (f) { return function (fea) { return F.mapLeft(fea, f); }; };\n}\nexport function extend(F) {\n    return function (f) { return function (wa) { return F.extend(wa, f); }; };\n}\nexport function reduce(F) {\n    return function (b, f) { return function (fa) { return F.reduce(fa, b, f); }; };\n}\nexport function foldMap(F) {\n    return function (M) {\n        var foldMapM = F.foldMap(M);\n        return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n    };\n}\nexport function reduceRight(F) {\n    return function (b, f) { return function (fa) { return F.reduceRight(fa, b, f); }; };\n}\nexport function reduceWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceWithIndex(fa, b, f); }; };\n}\nexport function foldMapWithIndex(F) {\n    return function (M) {\n        var foldMapWithIndexM = F.foldMapWithIndex(M);\n        return function (f) { return function (fa) { return foldMapWithIndexM(fa, f); }; };\n    };\n}\nexport function reduceRightWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceRightWithIndex(fa, b, f); }; };\n}\nexport function alt(F) {\n    return function (that) { return function (fa) { return F.alt(fa, that); }; };\n}\nexport function filter(F) {\n    return function (predicate) { return function (fa) { return F.filter(fa, predicate); }; };\n}\nexport function filterMap(F) {\n    return function (f) { return function (fa) { return F.filterMap(fa, f); }; };\n}\nexport function partition(F) {\n    return function (f) { return function (fa) { return F.partition(fa, f); }; };\n}\nexport function partitionMap(F) {\n    return function (f) { return function (fa) { return F.partitionMap(fa, f); }; };\n}\nexport function filterWithIndex(F) {\n    return function (predicate) { return function (fa) { return F.filterWithIndex(fa, predicate); }; };\n}\nexport function filterMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.filterMapWithIndex(fa, f); }; };\n}\nexport function partitionWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionWithIndex(fa, f); }; };\n}\nexport function partitionMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionMapWithIndex(fa, f); }; };\n}\nexport function promap(F) {\n    return function (f, g) { return function (fbc) { return F.promap(fbc, f, g); }; };\n}\nexport function compose(F) {\n    return function (ea) { return function (ab) { return F.compose(ab, ea); }; };\n}\nvar isFunctor = function (I) { return typeof I.map === 'function'; };\nvar isContravariant = function (I) { return typeof I.contramap === 'function'; };\nvar isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };\nvar isApply = function (I) { return typeof I.ap === 'function'; };\nvar isChain = function (I) { return typeof I.chain === 'function'; };\nvar isBifunctor = function (I) { return typeof I.bimap === 'function'; };\nvar isExtend = function (I) { return typeof I.extend === 'function'; };\nvar isFoldable = function (I) { return typeof I.reduce === 'function'; };\nvar isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };\nvar isAlt = function (I) { return typeof I.alt === 'function'; };\nvar isCompactable = function (I) { return typeof I.compact === 'function'; };\nvar isFilterable = function (I) { return typeof I.filter === 'function'; };\nvar isFilterableWithIndex = function (I) {\n    return typeof I.filterWithIndex === 'function';\n};\nvar isProfunctor = function (I) { return typeof I.promap === 'function'; };\nvar isSemigroupoid = function (I) { return typeof I.compose === 'function'; };\nvar isMonadThrow = function (I) { return typeof I.throwError === 'function'; };\n/** @deprecated */\nexport function pipeable(I) {\n    var r = {};\n    if (isFunctor(I)) {\n        r.map = map(I);\n    }\n    if (isContravariant(I)) {\n        r.contramap = contramap(I);\n    }\n    if (isFunctorWithIndex(I)) {\n        r.mapWithIndex = mapWithIndex(I);\n    }\n    if (isApply(I)) {\n        r.ap = ap(I);\n        r.apFirst = apFirst_(I);\n        r.apSecond = apSecond_(I);\n    }\n    if (isChain(I)) {\n        r.chain = chain(I);\n        r.chainFirst = chainFirst_(I);\n        r.flatten = r.chain(identity);\n    }\n    if (isBifunctor(I)) {\n        r.bimap = bimap(I);\n        r.mapLeft = mapLeft(I);\n    }\n    if (isExtend(I)) {\n        r.extend = extend(I);\n        r.duplicate = r.extend(identity);\n    }\n    if (isFoldable(I)) {\n        r.reduce = reduce(I);\n        r.foldMap = foldMap(I);\n        r.reduceRight = reduceRight(I);\n    }\n    if (isFoldableWithIndex(I)) {\n        r.reduceWithIndex = reduceWithIndex(I);\n        r.foldMapWithIndex = foldMapWithIndex(I);\n        r.reduceRightWithIndex = reduceRightWithIndex(I);\n    }\n    if (isAlt(I)) {\n        r.alt = alt(I);\n    }\n    if (isCompactable(I)) {\n        r.compact = I.compact;\n        r.separate = I.separate;\n    }\n    if (isFilterable(I)) {\n        r.filter = filter(I);\n        r.filterMap = filterMap(I);\n        r.partition = partition(I);\n        r.partitionMap = partitionMap(I);\n    }\n    if (isFilterableWithIndex(I)) {\n        r.filterWithIndex = filterWithIndex(I);\n        r.filterMapWithIndex = filterMapWithIndex(I);\n        r.partitionWithIndex = partitionWithIndex(I);\n        r.partitionMapWithIndex = partitionMapWithIndex(I);\n    }\n    if (isProfunctor(I)) {\n        r.promap = promap(I);\n    }\n    if (isSemigroupoid(I)) {\n        r.compose = compose(I);\n    }\n    if (isMonadThrow(I)) {\n        var fromOption = function (onNone) { return function (ma) {\n            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n        }; };\n        var fromEither = function (ma) {\n            return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);\n        };\n        var fromPredicate = function (predicate, onFalse) {\n            return function (a) {\n                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));\n            };\n        };\n        var filterOrElse = function (predicate, onFalse) {\n            return function (ma) {\n                return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); });\n            };\n        };\n        r.fromOption = fromOption;\n        r.fromEither = fromEither;\n        r.fromPredicate = fromPredicate;\n        r.filterOrElse = filterOrElse;\n    }\n    return r;\n}\n/**\n * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport var pipe = pipeFromFunctionModule;\n",
  "/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n",
  "/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n",
  "import { isNonEmpty } from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)\n * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * `string` semigroup under concatenation.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Semigroup = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * An empty `string`.\n *\n * @since 2.10.0\n */\nexport var empty = '';\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')\n * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Monoid = {\n    concat: Semigroup.concat,\n    empty: empty\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)\n * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)\n * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Show.show('a'), '\"a\"')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (s) { return JSON.stringify(s); }\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.isString('a'), true)\n * assert.deepStrictEqual(S.isString(1), false)\n *\n * @category refinements\n * @since 2.11.0\n */\nexport var isString = function (u) { return typeof u === 'string'; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 2.11.0\n */\nexport var toUpperCase = function (s) { return s.toUpperCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 2.11.0\n */\nexport var toLowerCase = function (s) { return s.toLowerCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 2.11.0\n */\nexport var replace = function (searchValue, replaceValue) {\n    return function (s) {\n        return s.replace(searchValue, replaceValue);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n *\n * @since 2.11.0\n */\nexport var trim = function (s) { return s.trim(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')\n *\n * @since 2.11.0\n */\nexport var trimLeft = function (s) { return s.trimLeft(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')\n *\n * @since 2.11.0\n */\nexport var trimRight = function (s) { return s.trimRight(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 2.11.0\n */\nexport var slice = function (start, end) {\n    return function (s) {\n        return s.slice(start, end);\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('', S.isEmpty), true)\n * assert.deepStrictEqual(pipe('a', S.isEmpty), false)\n *\n * @since 2.10.0\n */\nexport var isEmpty = function (s) { return s.length === 0; };\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.size), 3)\n *\n * @since 2.10.0\n */\nexport var size = function (s) { return s.length; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.11.0\n */\nexport var split = function (separator) {\n    return function (s) {\n        var out = s.split(separator);\n        return isNonEmpty(out) ? out : [s];\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)\n * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n *\n * @since 2.11.0\n */\nexport var includes = function (searchString, position) {\n    return function (s) {\n        return s.includes(searchString, position);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\n * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n *\n * @since 2.11.0\n */\nexport var startsWith = function (searchString, position) {\n    return function (s) {\n        return s.startsWith(searchString, position);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\n * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n *\n * @since 2.11.0\n */\nexport var endsWith = function (searchString, position) {\n    return function (s) {\n        return s.endsWith(searchString, position);\n    };\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as O from \"fp-ts/Option\";\nimport * as M from \"fp-ts/Map\";\nimport * as A from \"fp-ts/Array\";\nimport { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport { getMonoid as getEndoMonoid } from \"fp-ts/Endomorphism\";\nimport { concatAll } from \"fp-ts/Monoid\";\nimport { first } from \"fp-ts/Semigroup\";\nimport { bindTo as bindTo_, let as let__ } from \"fp-ts/Functor\";\nimport { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from \"fp-ts/Apply\";\nimport { bind as bind_ } from \"fp-ts/Chain\";\nexport const URI = \"Function\";\nexport const map = f => g => flow(g, f);\nexport const Functor = {\n    URI,\n    map: (f, g) => map(g)(f),\n};\nexport const of = constant;\nexport const ap = f => g => x => g(x)(f(x));\nexport const Applicative = {\n    ...Functor,\n    of,\n    ap: (f, g) => ap(g)(f),\n};\nexport const apFirst = apFirst_(Applicative);\nexport const apSecond = apSecond_(Applicative);\nexport const chain = f => g => x => f(g(x))(x);\nexport const flatMap = chain;\nexport const Monad = {\n    ...Applicative,\n    chain: (f, g) => chain(g)(f),\n};\nexport const Do = of({});\nexport const bindTo = bindTo_(Functor);\nexport const bind = bind_(Monad);\nexport const apS = apS_(Applicative);\nconst let_ = let__(Functor);\nexport { let_ as let, };\nexport const withIndex = f => g => xs => {\n    let i = 0;\n    return f(y => g(i++)(y))(xs);\n};\nexport const unary = tupled;\nexport const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));\nexport const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);\nexport const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);\nexport const when = flow(not, unless);\nexport const until = (f) => (g) => {\n    const h = x => (f(x) ? x : h(g(x)));\n    return h;\n};\nexport const construct = (x) => (xs) => new x(...xs);\nexport const invoke = (x) => (ys) => (z) => z[x](...ys);\nexport const invokeNullary = flip(invoke)([]);\nexport const invokeOn = () => (x) => ys => z => z[x](...ys);\nexport const memoize = (eq) => (f) => {\n    const cache = new Map();\n    return k => {\n        const cached = M.lookup(eq)(k)(cache);\n        if (O.isSome(cached))\n            return cached.value;\n        const val = f(k);\n        cache.set(k, val);\n        return val;\n    };\n};\nexport const curry2T = (f) => (a) => (b) => f([a, b]);\nexport const curry2 = flow(unary, curry2T);\nexport const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);\nexport const curry3 = flow(unary, curry3T);\nexport const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);\nexport const curry4 = flow(unary, curry4T);\nexport const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);\nexport const curry5 = flow(unary, curry5T);\nexport const uncurry2 = (f) => ([a, b]) => f(a)(b);\nexport const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);\nexport const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);\nexport const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);\nexport function fork(fs) {\n    return (x) => fs.map(f => f(x));\n}\nexport const converge = (f) => (gs) => flow(x => fork(gs)(x), f);\nexport const isInstanceOf = (x) => (y) => y instanceof x;\nexport const applyEvery = concatAll(getEndoMonoid());\nexport const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));\nexport const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);\n",
  "import * as Pred from \"fp-ts/Predicate\";\nimport { flow } from \"fp-ts/function\";\nimport { invert } from \"./Boolean\";\nimport { concatAll } from \"fp-ts/Monoid\";\nexport const allPass = (fs) => concatAll(Pred.getMonoidAll())(fs);\nexport const anyPass = (fs) => concatAll(Pred.getMonoidAny())(fs);\nexport const nonePass = (fs) => flow(anyPass(fs), invert);\n",
  "import { flow } from \"fp-ts/function\";\nimport { not } from \"fp-ts/Predicate\";\nimport * as R from \"fp-ts/Record\";\nimport * as A from \"fp-ts/Array\";\nimport * as T from \"fp-ts/Tuple\";\nimport { last } from \"fp-ts/Semigroup\";\nimport { elemV } from \"./Array\";\nimport * as Str from \"fp-ts/string\";\nexport const values = Object.values;\nexport const lookupV = (x) => (k) => R.lookup(k)(x);\nexport const reject = (f) => R.filter(not(f));\nexport const invertLast = (f) => flow(R.toArray, A.map(flow(T.mapSnd(f), T.swap)), R.fromFoldable(last(), A.Foldable));\nexport const invertAll = (f) => flow(R.toArray, A.map(flow(T.bimap(f, A.of), T.swap)), R.fromFoldable(A.getMonoid(), A.Foldable));\nexport const pick = (ks) => R.filterWithIndex(elemV(Str.Eq)(ks));\nexport const omit = (ks) => R.filterWithIndex(not(elemV(Str.Eq)(ks)));\n",
  "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as RR from 'fp-ts/es6/ReadonlyRecord';\nimport { constant, flow, identity } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport * as E from 'fp-ts/es6/Either';\nimport { pipe } from 'fp-ts/es6/pipeable';\n// -------------------------------------------------------------------------------------\n// Iso\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var iso = function (get, reverseGet) { return ({\n    get: get,\n    reverseGet: reverseGet\n}); };\n/** @internal */\nexport var isoAsLens = function (sa) { return lens(sa.get, flow(sa.reverseGet, constant)); };\n/** @internal */\nexport var isoAsPrism = function (sa) { return prism(flow(sa.get, O.some), sa.reverseGet); };\n/** @internal */\nexport var isoAsOptional = function (sa) {\n    return optional(flow(sa.get, O.some), flow(sa.reverseGet, constant));\n};\n/** @internal */\nexport var isoAsTraversal = function (sa) {\n    return traversal(function (F) { return function (f) { return function (s) {\n        return F.map(f(sa.get(s)), function (a) { return sa.reverseGet(a); });\n    }; }; });\n};\n// -------------------------------------------------------------------------------------\n// Lens\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var lens = function (get, set) { return ({ get: get, set: set }); };\n/** @internal */\nexport var lensAsOptional = function (sa) { return optional(flow(sa.get, O.some), sa.set); };\n/** @internal */\nexport var lensAsTraversal = function (sa) {\n    return traversal(function (F) { return function (f) { return function (s) { return F.map(f(sa.get(s)), function (a) { return sa.set(a)(s); }); }; }; });\n};\n/** @internal */\nexport var lensComposeLens = function (ab) { return function (sa) {\n    return lens(function (s) { return ab.get(sa.get(s)); }, function (b) { return function (s) { return sa.set(ab.set(b)(sa.get(s)))(s); }; });\n}; };\n/** @internal */\nexport var prismComposePrism = function (ab) { return function (sa) {\n    return prism(flow(sa.getOption, O.chain(ab.getOption)), flow(ab.reverseGet, sa.reverseGet));\n}; };\n/** @internal */\nexport var lensComposePrism = function (ab) { return function (sa) {\n    return optionalComposeOptional(prismAsOptional(ab))(lensAsOptional(sa));\n}; };\n/** @internal */\nexport var lensId = function () { return lens(identity, constant); };\n/** @internal */\nexport var lensProp = function (prop) { return function (sa) {\n    return lens(function (s) { return sa.get(s)[prop]; }, function (ap) { return function (s) {\n        var _a;\n        var oa = sa.get(s);\n        if (ap === oa[prop]) {\n            return s;\n        }\n        return sa.set(Object.assign({}, oa, (_a = {}, _a[prop] = ap, _a)))(s);\n    }; });\n}; };\n/** @internal */\nexport var lensProps = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return function (sa) {\n        return lens(function (s) {\n            var a = sa.get(s);\n            var r = {};\n            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\n                var k = props_1[_i];\n                r[k] = a[k];\n            }\n            return r;\n        }, function (a) { return function (s) {\n            var oa = sa.get(s);\n            for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {\n                var k = props_2[_i];\n                if (a[k] !== oa[k]) {\n                    return sa.set(Object.assign({}, oa, a))(s);\n                }\n            }\n            return s;\n        }; });\n    };\n};\n/** @internal */\nexport var lensComponent = function (prop) { return function (sa) {\n    return lens(function (s) { return sa.get(s)[prop]; }, function (ap) { return function (s) {\n        var oa = sa.get(s);\n        if (ap === oa[prop]) {\n            return s;\n        }\n        var copy = oa.slice();\n        copy[prop] = ap;\n        return sa.set(copy)(s);\n    }; });\n}; };\n/** @internal */\nexport var lensAtKey = function (key) { return function (sa) {\n    return pipe(sa, lensComposeLens(atReadonlyRecord().at(key)));\n}; };\n// -------------------------------------------------------------------------------------\n// Prism\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var prism = function (getOption, reverseGet) { return ({ getOption: getOption, reverseGet: reverseGet }); };\n/** @internal */\nexport var prismAsOptional = function (sa) { return optional(sa.getOption, function (a) { return prismSet(a)(sa); }); };\n/** @internal */\nexport var prismAsTraversal = function (sa) {\n    return traversal(function (F) { return function (f) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return prismSet(a)(sa)(s); }); }));\n    }; }; });\n};\n/** @internal */\nexport var prismModifyOption = function (f) { return function (sa) { return function (s) {\n    return pipe(sa.getOption(s), O.map(function (o) {\n        var n = f(o);\n        return n === o ? s : sa.reverseGet(n);\n    }));\n}; }; };\n/** @internal */\nexport var prismModify = function (f) { return function (sa) {\n    var g = prismModifyOption(f)(sa);\n    return function (s) {\n        return pipe(g(s), O.getOrElse(function () { return s; }));\n    };\n}; };\n/** @internal */\nexport var prismSet = function (a) { return prismModify(function () { return a; }); };\n/** @internal */\nexport var prismComposeLens = function (ab) { return function (sa) {\n    return optionalComposeOptional(lensAsOptional(ab))(prismAsOptional(sa));\n}; };\n/** @internal */\nexport var prismFromNullable = function () { return prism(O.fromNullable, identity); };\n/** @internal */\nexport var prismFromPredicate = function (predicate) {\n    return prism(O.fromPredicate(predicate), identity);\n};\n/** @internal */\nexport var prismSome = function () { return prism(identity, O.some); };\n/** @internal */\nexport var prismRight = function () { return prism(O.fromEither, E.right); };\n/** @internal */\nexport var prismLeft = function () {\n    return prism(function (s) { return (E.isLeft(s) ? O.some(s.left) : O.none); }, // TODO: replace with E.getLeft in v3\n    E.left);\n};\n// -------------------------------------------------------------------------------------\n// Optional\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var optional = function (getOption, set) { return ({\n    getOption: getOption,\n    set: set\n}); };\n/** @internal */\nexport var optionalAsTraversal = function (sa) {\n    return traversal(function (F) { return function (f) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; });\n};\n/** @internal */\nexport var optionalModifyOption = function (f) { return function (optional) { return function (s) {\n    return pipe(optional.getOption(s), O.map(function (a) {\n        var n = f(a);\n        return n === a ? s : optional.set(n)(s);\n    }));\n}; }; };\n/** @internal */\nexport var optionalModify = function (f) { return function (optional) {\n    var g = optionalModifyOption(f)(optional);\n    return function (s) {\n        return pipe(g(s), O.getOrElse(function () { return s; }));\n    };\n}; };\n/** @internal */\nexport var optionalComposeOptional = function (ab) { return function (sa) {\n    return optional(flow(sa.getOption, O.chain(ab.getOption)), function (b) { return optionalModify(ab.set(b))(sa); });\n}; };\n/** @internal */\nexport var optionalIndex = function (i) { return function (sa) {\n    return pipe(sa, optionalComposeOptional(indexReadonlyArray().index(i)));\n}; };\n/** @internal */\nexport var optionalIndexNonEmpty = function (i) { return function (sa) { return pipe(sa, optionalComposeOptional(indexReadonlyNonEmptyArray().index(i))); }; };\n/** @internal */\nexport var optionalKey = function (key) { return function (sa) {\n    return pipe(sa, optionalComposeOptional(indexReadonlyRecord().index(key)));\n}; };\n/** @internal */\nexport var optionalFindFirst = function (predicate) {\n    return optional(RA.findFirst(predicate), function (a) { return function (s) {\n        return pipe(RA.findIndex(predicate)(s), O.fold(function () { return s; }, function (i) { return RA.unsafeUpdateAt(i, a, s); }));\n    }; });\n};\nvar unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = __spreadArray([as[0]], as.slice(1), true);\n        xs[i] = a;\n        return xs;\n    }\n};\n/** @internal */\nexport var optionalFindFirstNonEmpty = function (predicate) {\n    return optional(RA.findFirst(predicate), function (a) { return function (as) {\n        return pipe(RA.findIndex(predicate)(as), O.fold(function () { return as; }, function (i) { return unsafeUpdateAt(i, a, as); }));\n    }; });\n};\n// -------------------------------------------------------------------------------------\n// Traversal\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var traversal = function (modifyF) { return ({\n    modifyF: modifyF\n}); };\n/** @internal */\nexport function traversalComposeTraversal(ab) {\n    return function (sa) { return traversal(function (F) { return function (f) { return sa.modifyF(F)(ab.modifyF(F)(f)); }; }); };\n}\n/** @internal */\nexport var ApplicativeIdentity = {\n    URI: 'Identity',\n    map: function (fa, f) { return f(fa); },\n    of: identity,\n    ap: \n    /* istanbul ignore next */\n    function (fab, fa) { return fab(fa); }\n};\nvar isIdentity = function (F) { return F.URI === 'Identity'; };\nexport function fromTraversable(T) {\n    return function () {\n        return traversal(function (F) {\n            // if `F` is `Identity` then `traverseF = map`\n            var traverseF = isIdentity(F)\n                ? T.map\n                : T.traverse(F);\n            return function (f) { return function (s) { return traverseF(s, f); }; };\n        });\n    };\n}\n/** @internal */\nexport function traversalTraverse(T) {\n    return traversalComposeTraversal(fromTraversable(T)());\n}\n// -------------------------------------------------------------------------------------\n// Ix\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var index = function (index) { return ({ index: index }); };\n/** @internal */\nexport var indexReadonlyArray = function () {\n    return index(function (i) {\n        return optional(function (as) { return RA.lookup(i, as); }, function (a) { return function (as) {\n            return pipe(RA.lookup(i, as), O.fold(function () { return as; }, function () { return RA.unsafeUpdateAt(i, a, as); }));\n        }; });\n    });\n};\n/** @internal */\nexport var indexReadonlyNonEmptyArray = function () {\n    return index(function (i) {\n        return optional(function (as) { return RA.lookup(i, as); }, function (a) { return function (as) {\n            return pipe(RA.lookup(i, as), O.fold(function () { return as; }, function () { return unsafeUpdateAt(i, a, as); }));\n        }; });\n    });\n};\n/** @internal */\nexport var indexReadonlyRecord = function () {\n    return index(function (k) {\n        return optional(function (r) { return RR.lookup(k, r); }, function (a) { return function (r) {\n            if (r[k] === a || O.isNone(RR.lookup(k, r))) {\n                return r;\n            }\n            return RR.insertAt(k, a)(r);\n        }; });\n    });\n};\n// -------------------------------------------------------------------------------------\n// At\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var at = function (at) { return ({ at: at }); };\n/** @internal */\nexport function atReadonlyRecord() {\n    return at(function (key) {\n        return lens(function (r) { return RR.lookup(key, r); }, O.fold(function () { return RR.deleteAt(key); }, function (a) { return RR.insertAt(key, a); }));\n    });\n}\n",
  "import * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RM from 'fp-ts/es6/ReadonlyMap';\nimport * as RS from 'fp-ts/es6/ReadonlySet';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var at = _.at;\n/**\n * Lift an instance of `At` using an `Iso`.\n *\n * @category constructors\n * @since 2.3.0\n */\nexport var fromIso = function (iso) { return function (sia) {\n    return at(function (i) { return pipe(iso, _.isoAsLens, _.lensComposeLens(sia.at(i))); });\n}; };\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var atReadonlyRecord = _.atReadonlyRecord;\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var atReadonlyMap = function (E) {\n    var lookupE = RM.lookup(E);\n    var deleteAtE = RM.deleteAt(E);\n    var insertAtE = RM.insertAt(E);\n    return function () {\n        return at(function (key) {\n            return _.lens(function (s) { return lookupE(key, s); }, O.fold(function () { return deleteAtE(key); }, function (a) { return insertAtE(key, a); }));\n        });\n    };\n};\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var atReadonlySet = function (E) {\n    var elemE = RS.elem(E);\n    var insertE = RS.insert(E);\n    var removeE = RS.remove(E);\n    return at(function (a) {\n        var insert = insertE(a);\n        var remove = removeE(a);\n        return _.lens(function (s) { return elemE(a, s); }, function (b) { return function (s) { return (b ? insert(s) : remove(s)); }; });\n    });\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `atReadonlyRecord` instead.\n *\n * @category constructors\n * @since 2.3.2\n * @deprecated\n */\nexport var atRecord = _.atReadonlyRecord;\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var iso = _.iso;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return iso(identity, identity); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View an `Iso` as a `Lens`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asLens = _.isoAsLens;\n/**\n * View an `Iso` as a `Prism`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asPrism = _.isoAsPrism;\n/**\n * View an `Iso` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.isoAsOptional;\n/**\n * View an `Iso` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.isoAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose an `Iso` with an `Iso`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = function (ab) { return function (sa) {\n    return iso(flow(sa.get, ab.get), flow(ab.reverseGet, sa.reverseGet));\n}; };\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = compose;\n/**\n * Compose an `Iso` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = function (ab) {\n    return flow(asLens, _.lensComposeLens(ab));\n};\n/**\n * Compose an `Iso` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = function (ab) {\n    return flow(asPrism, _.prismComposePrism(ab));\n};\n/**\n * Compose an `Iso` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose an `Iso` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var reverse = function (sa) { return iso(sa.reverseGet, sa.get); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) { return function (s) {\n    return sa.reverseGet(f(sa.get(s)));\n}; }; };\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return pipe(sa.get(s), f, function (fa) { return F.map(fa, sa.reverseGet); }); }; }; };\n}\n/**\n * Return a `Prism` from a `Iso` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return composePrism(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Lens` from a `Iso` and a prop.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var prop = function (prop) {\n    return flow(asLens, _.lensProp(prop));\n};\n/**\n * Return a `Lens` from a `Iso` and a list of props.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return flow(asLens, _.lensProps.apply(_, props));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var component = function (prop) { return flow(asLens, _.lensComponent(prop)); };\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var atKey = function (key) {\n    return flow(asLens, _.lensAtKey(key));\n};\n/**\n * Return a `Prism` from a `Iso` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var some = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Iso` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var right = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Iso` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var left = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Iso` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return iso(flow(ea.get, ab), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Iso';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var iso = _.iso;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return iso(identity, identity); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View an `Iso` as a `Lens`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asLens = _.isoAsLens;\n/**\n * View an `Iso` as a `Prism`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asPrism = _.isoAsPrism;\n/**\n * View an `Iso` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.isoAsOptional;\n/**\n * View an `Iso` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.isoAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose an `Iso` with an `Iso`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = function (ab) { return function (sa) {\n    return iso(flow(sa.get, ab.get), flow(ab.reverseGet, sa.reverseGet));\n}; };\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = compose;\n/**\n * Compose an `Iso` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = function (ab) {\n    return flow(asLens, _.lensComposeLens(ab));\n};\n/**\n * Compose an `Iso` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = function (ab) {\n    return flow(asPrism, _.prismComposePrism(ab));\n};\n/**\n * Compose an `Iso` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose an `Iso` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var reverse = function (sa) { return iso(sa.reverseGet, sa.get); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) { return function (s) {\n    return sa.reverseGet(f(sa.get(s)));\n}; }; };\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return pipe(sa.get(s), f, function (fa) { return F.map(fa, sa.reverseGet); }); }; }; };\n}\n/**\n * Return a `Prism` from a `Iso` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return composePrism(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Lens` from a `Iso` and a prop.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var prop = function (prop) {\n    return flow(asLens, _.lensProp(prop));\n};\n/**\n * Return a `Lens` from a `Iso` and a list of props.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return flow(asLens, _.lensProps.apply(_, props));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var component = function (prop) { return flow(asLens, _.lensComponent(prop)); };\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var atKey = function (key) {\n    return flow(asLens, _.lensAtKey(key));\n};\n/**\n * Return a `Prism` from a `Iso` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var some = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Iso` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var right = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Iso` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var left = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Iso` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return iso(flow(ea.get, ab), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Iso';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var iso = _.iso;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return iso(identity, identity); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View an `Iso` as a `Lens`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asLens = _.isoAsLens;\n/**\n * View an `Iso` as a `Prism`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asPrism = _.isoAsPrism;\n/**\n * View an `Iso` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.isoAsOptional;\n/**\n * View an `Iso` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.isoAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose an `Iso` with an `Iso`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = function (ab) { return function (sa) {\n    return iso(flow(sa.get, ab.get), flow(ab.reverseGet, sa.reverseGet));\n}; };\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = compose;\n/**\n * Compose an `Iso` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = function (ab) {\n    return flow(asLens, _.lensComposeLens(ab));\n};\n/**\n * Compose an `Iso` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = function (ab) {\n    return flow(asPrism, _.prismComposePrism(ab));\n};\n/**\n * Compose an `Iso` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose an `Iso` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var reverse = function (sa) { return iso(sa.reverseGet, sa.get); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) { return function (s) {\n    return sa.reverseGet(f(sa.get(s)));\n}; }; };\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return pipe(sa.get(s), f, function (fa) { return F.map(fa, sa.reverseGet); }); }; }; };\n}\n/**\n * Return a `Prism` from a `Iso` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return composePrism(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Lens` from a `Iso` and a prop.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var prop = function (prop) {\n    return flow(asLens, _.lensProp(prop));\n};\n/**\n * Return a `Lens` from a `Iso` and a list of props.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return flow(asLens, _.lensProps.apply(_, props));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var component = function (prop) { return flow(asLens, _.lensComponent(prop)); };\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var atKey = function (key) {\n    return flow(asLens, _.lensAtKey(key));\n};\n/**\n * Return a `Prism` from a `Iso` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var some = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Iso` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var right = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Iso` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var left = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Iso` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return iso(flow(ea.get, ab), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Iso';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var iso = _.iso;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return iso(identity, identity); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View an `Iso` as a `Lens`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asLens = _.isoAsLens;\n/**\n * View an `Iso` as a `Prism`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asPrism = _.isoAsPrism;\n/**\n * View an `Iso` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.isoAsOptional;\n/**\n * View an `Iso` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.isoAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose an `Iso` with an `Iso`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = function (ab) { return function (sa) {\n    return iso(flow(sa.get, ab.get), flow(ab.reverseGet, sa.reverseGet));\n}; };\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = compose;\n/**\n * Compose an `Iso` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = function (ab) {\n    return flow(asLens, _.lensComposeLens(ab));\n};\n/**\n * Compose an `Iso` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = function (ab) {\n    return flow(asPrism, _.prismComposePrism(ab));\n};\n/**\n * Compose an `Iso` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose an `Iso` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var reverse = function (sa) { return iso(sa.reverseGet, sa.get); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) { return function (s) {\n    return sa.reverseGet(f(sa.get(s)));\n}; }; };\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return pipe(sa.get(s), f, function (fa) { return F.map(fa, sa.reverseGet); }); }; }; };\n}\n/**\n * Return a `Prism` from a `Iso` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return composePrism(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Lens` from a `Iso` and a prop.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var prop = function (prop) {\n    return flow(asLens, _.lensProp(prop));\n};\n/**\n * Return a `Lens` from a `Iso` and a list of props.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return flow(asLens, _.lensProps.apply(_, props));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var component = function (prop) { return flow(asLens, _.lensComponent(prop)); };\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Iso` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Lens` from a `Iso` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var atKey = function (key) {\n    return flow(asLens, _.lensAtKey(key));\n};\n/**\n * Return a `Prism` from a `Iso` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var some = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Iso` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var right = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Iso` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var left = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Iso` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return iso(flow(ea.get, ab), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Iso';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "/**\n * **This module is experimental**\n *\n * Experimental features are published in order to get early feedback from the community.\n *\n * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.\n *\n * @since 2.3.0\n */\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\nimport * as RM from 'fp-ts/es6/ReadonlyMap';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var index = _.index;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var fromAt = function (at) {\n    return index(function (i) { return _.lensComposePrism(_.prismSome())(at.at(i)); });\n};\n/**\n * Lift an instance of `Index` using an `Iso`.\n *\n * @category constructors\n * @since 2.3.0\n */\nexport var fromIso = function (iso) { return function (sia) {\n    return index(function (i) { return pipe(iso, _.isoAsOptional, _.optionalComposeOptional(sia.index(i))); });\n}; };\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var indexReadonlyArray = _.indexReadonlyArray;\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var indexReadonlyNonEmptyArray = _.indexReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var indexReadonlyRecord = _.indexReadonlyRecord;\n/**\n * @category constructors\n * @since 2.3.7\n */\nexport var indexReadonlyMap = function (E) {\n    var lookupE = RM.lookup(E);\n    var insertAtE = RM.insertAt(E);\n    return function () {\n        return index(function (key) {\n            return _.optional(function (s) { return lookupE(key, s); }, function (next) {\n                var insert = insertAtE(key, next);\n                return function (s) {\n                    return pipe(lookupE(key, s), O.fold(function () { return s; }, function (prev) { return (next === prev ? s : insert(s)); }));\n                };\n            });\n        });\n    };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `indexReadonlyArray` instead.\n *\n * @category constructors\n * @since 2.3.2\n * @deprecated\n */\nexport var indexArray = _.indexReadonlyArray;\n/**\n * Use `indexReadonlyRecord` instead.\n *\n * @category constructors\n * @since 2.3.2\n * @deprecated\n */\nexport var indexRecord = _.indexReadonlyRecord;\n",
  "import { flow } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var lens = _.lens;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = _.lensId;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Lens` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.lensAsOptional;\n/**\n * View a `Lens` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.lensAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Lens` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.lensComposeLens;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = compose;\n/**\n * Compose a `Lens` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsLens, compose);\n/**\n * Compose a `Lens` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composePrism = _.lensComposePrism;\n/**\n * Compose a `Lens` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose a `Lens` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) { return function (s) {\n    var o = sa.get(s);\n    var n = f(o);\n    return o === n ? s : sa.set(n)(s);\n}; }; };\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) { return pipe(sa.get(s), f, function (fa) { return F.map(fa, function (a) { return sa.set(a)(s); }); }); }; }; };\n}\n/**\n * Return a `Optional` from a `Lens` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return composePrism(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Lens` from a `Lens` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = _.lensProp;\n/**\n * Return a `Lens` from a `Lens` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = _.lensProps;\n/**\n * Return a `Lens` from a `Lens` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = _.lensComponent;\n/**\n * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Lens` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Lens` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Lens` from a `Lens` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = _.lensAtKey;\n/**\n * Return a `Optional` from a `Lens` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Optional` from a `Lens` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Optional` from a `Lens` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncomposePrism(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Lens` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return lens(flow(ea.get, ab), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Lens';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { constant, flow } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return optional(O.some, constant); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsOptional, compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nexport var setOption = function (a) { return modifyOption(function () { return a; }); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.optionalModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nexport function filter(predicate) {\n    return compose(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return compose(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return compose(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return optional(flow(ea.getOption, O.map(ab)), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { constant, flow } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return optional(O.some, constant); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsOptional, compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nexport var setOption = function (a) { return modifyOption(function () { return a; }); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.optionalModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nexport function filter(predicate) {\n    return compose(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return compose(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return compose(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return optional(flow(ea.getOption, O.map(ab)), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { constant, flow } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return optional(O.some, constant); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsOptional, compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nexport var setOption = function (a) { return modifyOption(function () { return a; }); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.optionalModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nexport function filter(predicate) {\n    return compose(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return compose(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return compose(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return optional(flow(ea.getOption, O.map(ab)), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { constant, flow } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return optional(O.some, constant); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsOptional, compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nexport var setOption = function (a) { return modifyOption(function () { return a; }); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.optionalModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nexport function filter(predicate) {\n    return compose(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return compose(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return compose(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return optional(flow(ea.getOption, O.map(ab)), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { constant, flow } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var optional = _.optional;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return optional(O.some, constant); };\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Optional` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.optionalAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Optional` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.optionalComposeOptional;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = compose;\n/**\n * Compose a `Optional` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsOptional, compose);\n/**\n * Compose a `Optional` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.7\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsOptional, _.optionalComposeOptional);\n/**\n * Compose a `Optional` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.optionalModifyOption;\n/**\n * @category combinators\n * @since 2.3.7\n */\nexport var setOption = function (a) { return modifyOption(function () { return a; }); };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.optionalModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), function (a) { return sa.set(a)(s); }); }));\n    }; }; };\n}\n/**\n * Return an `Optional` from a `Optional` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismFromNullable()));\nexport function filter(predicate) {\n    return compose(_.prismAsOptional(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Optional` from a `Optional` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsOptional));\n};\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = _.optionalIndex;\n/**\n * Return a `Optional` from a `Optional` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = _.optionalIndexNonEmpty;\n/**\n * Return a `Optional` from a `Optional` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = _.optionalKey;\n/**\n * Return a `Optional` from a `Optional` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsOptional(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Optional` from a `Optional` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Optional` from a `Optional` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsOptional(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Optional` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return compose(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return compose(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) { return imap_(ea, f, g); }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return optional(flow(ea.getOption, O.map(ab)), flow(ba, ea.set)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Optional';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var prism = _.prism;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return prism(O.some, identity); };\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var fromPredicate = _.prismFromPredicate;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Prism` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.prismAsOptional;\n/**\n * View a `Prism` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.prismAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Prism` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.prismComposePrism;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = compose;\n/**\n * Compose a `Prism` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsPrism, compose);\n/**\n * Compose a `Prism` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeLens = _.prismComposeLens;\n/**\n * Compose a `Prism` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose a `Prism` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = _.prismSet;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.prismModifyOption;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.prismModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), sa.reverseGet); }));\n    }; }; };\n}\n/**\n * Return a `Prism` from a `Prism` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismFromNullable());\nexport function filter(predicate) {\n    return compose(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Optional` from a `Prism` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return composeLens(pipe(_.lensId(), _.lensProp(prop)));\n}; // TODO: simplify?\n/**\n * Return a `Optional` from a `Prism` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return composeLens(pipe(_.lensId(), _.lensProps.apply(_, props)));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) { return composeLens(pipe(_.lensId(), _.lensComponent(prop))); };\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return _.prismComposeLens(_.atReadonlyRecord().at(key))(sa);\n}; };\n/**\n * Return a `Prism` from a `Prism` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Prism` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Prism` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Prism` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return prism(flow(ea.getOption, O.map(ab)), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Prism';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var prism = _.prism;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return prism(O.some, identity); };\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var fromPredicate = _.prismFromPredicate;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Prism` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.prismAsOptional;\n/**\n * View a `Prism` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.prismAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Prism` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.prismComposePrism;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = compose;\n/**\n * Compose a `Prism` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsPrism, compose);\n/**\n * Compose a `Prism` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeLens = _.prismComposeLens;\n/**\n * Compose a `Prism` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose a `Prism` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = _.prismSet;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.prismModifyOption;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.prismModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), sa.reverseGet); }));\n    }; }; };\n}\n/**\n * Return a `Prism` from a `Prism` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismFromNullable());\nexport function filter(predicate) {\n    return compose(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Optional` from a `Prism` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return composeLens(pipe(_.lensId(), _.lensProp(prop)));\n}; // TODO: simplify?\n/**\n * Return a `Optional` from a `Prism` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return composeLens(pipe(_.lensId(), _.lensProps.apply(_, props)));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) { return composeLens(pipe(_.lensId(), _.lensComponent(prop))); };\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return _.prismComposeLens(_.atReadonlyRecord().at(key))(sa);\n}; };\n/**\n * Return a `Prism` from a `Prism` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Prism` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Prism` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Prism` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return prism(flow(ea.getOption, O.map(ab)), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Prism';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var prism = _.prism;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return prism(O.some, identity); };\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var fromPredicate = _.prismFromPredicate;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Prism` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.prismAsOptional;\n/**\n * View a `Prism` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.prismAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Prism` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.prismComposePrism;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = compose;\n/**\n * Compose a `Prism` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsPrism, compose);\n/**\n * Compose a `Prism` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeLens = _.prismComposeLens;\n/**\n * Compose a `Prism` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose a `Prism` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = _.prismSet;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.prismModifyOption;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.prismModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), sa.reverseGet); }));\n    }; }; };\n}\n/**\n * Return a `Prism` from a `Prism` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismFromNullable());\nexport function filter(predicate) {\n    return compose(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Optional` from a `Prism` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return composeLens(pipe(_.lensId(), _.lensProp(prop)));\n}; // TODO: simplify?\n/**\n * Return a `Optional` from a `Prism` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return composeLens(pipe(_.lensId(), _.lensProps.apply(_, props)));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) { return composeLens(pipe(_.lensId(), _.lensComponent(prop))); };\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return _.prismComposeLens(_.atReadonlyRecord().at(key))(sa);\n}; };\n/**\n * Return a `Prism` from a `Prism` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Prism` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Prism` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Prism` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return prism(flow(ea.getOption, O.map(ab)), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Prism';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import { flow, identity } from 'fp-ts/es6/function';\nimport * as O from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var prism = _.prism;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return prism(O.some, identity); };\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var fromPredicate = _.prismFromPredicate;\n// -------------------------------------------------------------------------------------\n// converters\n// -------------------------------------------------------------------------------------\n/**\n * View a `Prism` as a `Optional`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asOptional = _.prismAsOptional;\n/**\n * View a `Prism` as a `Traversal`.\n *\n * @category converters\n * @since 2.3.0\n */\nexport var asTraversal = _.prismAsTraversal;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Prism` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.prismComposePrism;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = compose;\n/**\n * Compose a `Prism` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsPrism, compose);\n/**\n * Compose a `Prism` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeLens = _.prismComposeLens;\n/**\n * Compose a `Prism` with an `Optional`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var composeOptional = function (ab) {\n    return flow(asOptional, _.optionalComposeOptional(ab));\n};\n/**\n * Compose a `Prism` with an `Traversal`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = function (ab) {\n    return flow(asTraversal, _.traversalComposeTraversal(ab));\n};\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = _.prismSet;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modifyOption = _.prismModifyOption;\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = _.prismModify;\nexport function modifyF(F) {\n    return function (f) { return function (sa) { return function (s) {\n        return pipe(sa.getOption(s), O.fold(function () { return F.of(s); }, function (a) { return F.map(f(a), sa.reverseGet); }));\n    }; }; };\n}\n/**\n * Return a `Prism` from a `Prism` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.3\n */\nexport var fromNullable = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismFromNullable());\nexport function filter(predicate) {\n    return compose(_.prismFromPredicate(predicate));\n}\n/**\n * Return a `Optional` from a `Prism` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return composeLens(pipe(_.lensId(), _.lensProp(prop)));\n}; // TODO: simplify?\n/**\n * Return a `Optional` from a `Prism` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return composeLens(pipe(_.lensId(), _.lensProps.apply(_, props)));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) { return composeLens(pipe(_.lensId(), _.lensComponent(prop))); };\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) {\n    return flow(asOptional, _.optionalIndex(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on an index of a `ReadonlyNonEmptyArray`.\n *\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) {\n    return flow(asOptional, _.optionalIndexNonEmpty(i));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) {\n    return flow(asOptional, _.optionalKey(key));\n};\n/**\n * Return a `Optional` from a `Prism` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return _.prismComposeLens(_.atReadonlyRecord().at(key))(sa);\n}; };\n/**\n * Return a `Prism` from a `Prism` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismSome());\n/**\n * Return a `Prism` from a `Prism` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismRight());\n/**\n * Return a `Prism` from a `Prism` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismLeft());\n/**\n * Return a `Traversal` from a `Prism` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport function traverse(T) {\n    return flow(asTraversal, _.traversalTraverse(T));\n}\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Invariant\n * @since 2.3.0\n */\nexport var imap = function (f, g) { return function (ea) {\n    return imap_(ea, f, g);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar imap_ = function (ea, ab, ba) { return prism(flow(ea.getOption, O.map(ab)), flow(ba, ea.reverseGet)); };\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Prism';\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Invariant = {\n    URI: URI,\n    imap: imap_\n};\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import * as C from 'fp-ts/es6/Const';\nimport { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexport var fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsTraversal, compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = \n/*#__PURE__*/\nflow(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = function (a) { return modify(function () { return a; }); };\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\n/**\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var traverse = _.traversalTraverse;\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fold = function (M) { return foldMap(M)(identity); };\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var getAll = function (s) { return function (sa) {\n    return foldMap(RA.getMonoid())(RA.of)(sa)(s);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import * as C from 'fp-ts/es6/Const';\nimport { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexport var fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsTraversal, compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = \n/*#__PURE__*/\nflow(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = function (a) { return modify(function () { return a; }); };\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\n/**\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var traverse = _.traversalTraverse;\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fold = function (M) { return foldMap(M)(identity); };\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var getAll = function (s) { return function (sa) {\n    return foldMap(RA.getMonoid())(RA.of)(sa)(s);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import * as C from 'fp-ts/es6/Const';\nimport { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexport var fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsTraversal, compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = \n/*#__PURE__*/\nflow(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = function (a) { return modify(function () { return a; }); };\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\n/**\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var traverse = _.traversalTraverse;\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fold = function (M) { return foldMap(M)(identity); };\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var getAll = function (s) { return function (sa) {\n    return foldMap(RA.getMonoid())(RA.of)(sa)(s);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import * as C from 'fp-ts/es6/Const';\nimport { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexport var fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsTraversal, compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = \n/*#__PURE__*/\nflow(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = function (a) { return modify(function () { return a; }); };\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\n/**\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var traverse = _.traversalTraverse;\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fold = function (M) { return foldMap(M)(identity); };\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var getAll = function (s) { return function (sa) {\n    return foldMap(RA.getMonoid())(RA.of)(sa)(s);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "import * as C from 'fp-ts/es6/Const';\nimport { flow, identity } from 'fp-ts/es6/function';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as RA from 'fp-ts/es6/ReadonlyArray';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.3.8\n */\nexport var traversal = _.traversal;\n/**\n * @category constructors\n * @since 2.3.0\n */\nexport var id = function () { return traversal(function (_) { return function (f) { return f; }; }); };\n/**\n * Create a `Traversal` from a `Traversable`.\n *\n * @category constructor\n * @since 2.3.0\n */\nexport var fromTraversable = _.fromTraversable;\n// -------------------------------------------------------------------------------------\n// compositions\n// -------------------------------------------------------------------------------------\n/**\n * Compose a `Traversal` with a `Traversal`.\n *\n * @category compositions\n * @since 2.3.0\n */\nexport var compose = _.traversalComposeTraversal;\n/**\n * Alias of `compose`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeTraversal = compose;\n/**\n * Compose a `Traversal` with a `Iso`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeIso = \n/*#__PURE__*/\nflow(_.isoAsTraversal, compose);\n/**\n * Compose a `Traversal` with a `Lens`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeLens = \n/*#__PURE__*/\nflow(_.lensAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Prism`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composePrism = \n/*#__PURE__*/\nflow(_.prismAsTraversal, _.traversalComposeTraversal);\n/**\n * Compose a `Traversal` with a `Optional`.\n *\n * @category compositions\n * @since 2.3.8\n */\nexport var composeOptional = \n/*#__PURE__*/\nflow(_.optionalAsTraversal, _.traversalComposeTraversal);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var modify = function (f) { return function (sa) {\n    return sa.modifyF(_.ApplicativeIdentity)(f);\n}; };\n/**\n * @category combinators\n * @since 2.3.0\n */\nexport var set = function (a) { return modify(function () { return a; }); };\n/**\n * Return a `Traversal` from a `Traversal` focused on a nullable value.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fromNullable = function (sa) {\n    return composePrism(_.prismFromNullable())(sa);\n};\nexport function filter(predicate) {\n    return compose(_.prismAsTraversal(_.prismFromPredicate(predicate)));\n}\n/**\n * Return a `Traversal` from a `Traversal` and a prop.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var prop = function (prop) {\n    return compose(pipe(_.lensId(), _.lensProp(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` and a list of props.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var props = function () {\n    var props = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        props[_i] = arguments[_i];\n    }\n    return compose(pipe(_.lensId(), _.lensProps.apply(_, props), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on a component of a tuple.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var component = function (prop) {\n    return compose(pipe(_.lensId(), _.lensComponent(prop), _.lensAsTraversal));\n};\n/**\n * Return a `Traversal` from a `Traversal` focused on an index of a `ReadonlyArray`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var index = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyArray().index(i))));\n}; };\n/**\n * @category combinators\n * @since 2.3.8\n */\nexport var indexNonEmpty = function (i) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyNonEmptyArray().index(i))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var key = function (key) { return function (sa) {\n    return pipe(sa, compose(_.optionalAsTraversal(_.indexReadonlyRecord().index(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on a required key of a `ReadonlyRecord`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var atKey = function (key) { return function (sa) {\n    return pipe(sa, compose(_.lensAsTraversal(_.atReadonlyRecord().at(key))));\n}; };\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Some` of a `Option` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var some = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismSome()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Right` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var right = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismRight()));\n/**\n * Return a `Traversal` from a `Traversal` focused on the `Left` of a `Either` type.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var left = \n/*#__PURE__*/\ncompose(/*#__PURE__*/ _.prismAsTraversal(/*#__PURE__*/ _.prismLeft()));\n/**\n * Return a `Traversal` from a `Traversal` focused on a `Traversable`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var traverse = _.traversalTraverse;\nexport function findFirst(predicate) {\n    return composeOptional(_.optionalFindFirst(predicate));\n}\nexport function findFirstNonEmpty(predicate) {\n    return composeOptional(_.optionalFindFirstNonEmpty(predicate));\n}\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var foldMap = function (M) { return function (f) { return function (sa) {\n    return sa.modifyF(C.getApplicative(M))(function (a) { return C.make(f(a)); });\n}; }; };\n/**\n * Map each target to a `Monoid` and combine the results.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var fold = function (M) { return foldMap(M)(identity); };\n/**\n * Get all the targets of a `Traversal`.\n *\n * @category combinators\n * @since 2.3.0\n */\nexport var getAll = function (s) { return function (sa) {\n    return foldMap(RA.getMonoid())(RA.of)(sa)(s);\n}; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var URI = 'monocle-ts/Traversal';\n/**\n * @category instances\n * @since 2.3.8\n */\nexport var Semigroupoid = {\n    URI: URI,\n    compose: function (ab, ea) { return compose(ab)(ea); }\n};\n/**\n * @category instances\n * @since 2.3.0\n */\nexport var Category = {\n    URI: URI,\n    compose: Semigroupoid.compose,\n    id: id\n};\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "/**\n * @since 1.0.0\n */\nimport * as A from 'fp-ts/es6/Array';\nimport { getApplicative, make } from 'fp-ts/es6/Const';\nimport { constant, identity } from 'fp-ts/es6/function';\nimport { monoidAll, monoidAny } from 'fp-ts/es6/Monoid';\nimport { fromNullable, fromPredicate, getFirstMonoid, isNone, option, some } from 'fp-ts/es6/Option';\nimport { pipe } from 'fp-ts/es6/pipeable';\nimport * as at from './At';\nimport * as iso from './Iso';\nimport * as index from './Ix';\nimport * as lens from './Lens';\nimport * as optional from './Optional';\nimport * as prism from './Prism';\nimport * as traversal from './Traversal';\nexport { \n/**\n * @since 2.3.0\n */\nat, \n/**\n * @since 2.3.0\n */\niso, \n/**\n * @since 2.3.0\n */\nindex, \n/**\n * @since 2.3.0\n */\nlens, \n/**\n * @since 2.3.0\n */\nprism, \n/**\n * @since 2.3.0\n */\noptional, \n/**\n * @since 2.3.0\n */\ntraversal };\n//\n// compat\n//\nvar fromIso = function (iso) { return new Iso(iso.get, iso.reverseGet); };\nvar fromLens = function (lens) { return new Lens(lens.get, lens.set); };\nvar fromPrism = function (prism) { return new Prism(prism.getOption, prism.reverseGet); };\nvar fromOptional = function (optional) {\n    return new Optional(optional.getOption, optional.set);\n};\nvar fromTraversal = function (traversal) { return new Traversal(traversal.modifyF); };\nvar fromAt = function (at) { return new At(function (i) { return fromLens(at.at(i)); }); };\nvar fromIndex = function (ix) { return new Index(function (i) { return fromOptional(ix.index(i)); }); };\n//\n// old APIs\n//\nvar update = function (o, k, a) {\n    var _a;\n    return a === o[k] ? o : Object.assign({}, o, (_a = {}, _a[k] = a, _a));\n};\n/**\n * Laws:\n * 1. `reverseGet(get(s)) = s`\n * 2. `get(reversetGet(a)) = a`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Iso = /** @class */ (function () {\n    function Iso(get, reverseGet) {\n        this.get = get;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Iso';\n        /**\n         * @since 1.0.0\n         */\n        this.unwrap = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.to = this.get;\n        /**\n         * @since 1.0.0\n         */\n        this.wrap = this.reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this.from = this.reverseGet;\n    }\n    /**\n     * reverse the `Iso`: the source becomes the target and the target becomes the source\n     * @since 1.0.0\n     */\n    Iso.prototype.reverse = function () {\n        return fromIso(iso.reverse(this));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Iso.prototype.modify = function (f) {\n        return iso.modify(f)(this);\n    };\n    /**\n     * view an `Iso` as a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asLens = function () {\n        return fromLens(iso.asLens(this));\n    };\n    /**\n     * view an `Iso` as a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asPrism = function () {\n        return fromPrism(iso.asPrism(this));\n    };\n    /**\n     * view an `Iso` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asOptional = function () {\n        return fromOptional(iso.asOptional(this));\n    };\n    /**\n     * view an `Iso` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asTraversal = function () {\n        return fromTraversal(iso.asTraversal(this));\n    };\n    /**\n     * view an `Iso` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * view an `Iso` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view an `Iso` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose an `Iso` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.compose = function (ab) {\n        return fromIso(iso.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeIso = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Lens `\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeLens = function (ab) {\n        return fromLens(pipe(this, iso.asLens, lens.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composePrism = function (ab) {\n        return fromPrism(pipe(this, iso.asPrism, prism.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, iso.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, iso.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Iso` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose an `Iso` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Iso.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    return Iso;\n}());\nexport { Iso };\n/**\n * Laws:\n * 1. `get(set(a)(s)) = a`\n * 2. `set(get(s))(s) = s`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Lens = /** @class */ (function () {\n    function Lens(get, set) {\n        this.get = get;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Lens';\n    }\n    /**\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     *   address: {\n     *     city: string\n     *   }\n     * }\n     *\n     * const city = Lens.fromPath<Person>()(['address', 'city'])\n     *\n     * const person: Person = { name: 'Giulio', age: 43, address: { city: 'Milan' } }\n     *\n     * assert.strictEqual(city.get(person), 'Milan')\n     * assert.deepStrictEqual(city.set('London')(person), { name: 'Giulio', age: 43, address: { city: 'London' } })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromPath = function () {\n        var fromProp = Lens.fromProp();\n        return function (path) {\n            var lens = fromProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromProp(prop)); }, lens);\n        };\n    };\n    /**\n     * Returns a `Lens` from a type and a prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * type Person = {\n     *   name: string\n     *   age: number\n     * }\n     *\n     * const age = Lens.fromProp<Person>()('age')\n     *\n     * const person: Person = { name: 'Giulio', age: 43 }\n     *\n     * assert.strictEqual(age.get(person), 43)\n     * assert.deepStrictEqual(age.set(44)(person), { name: 'Giulio', age: 44 })\n     *\n     * @since 1.0.0\n     */\n    Lens.fromProp = function () {\n        return function (prop) { return fromLens(pipe(lens.id(), lens.prop(prop))); };\n    };\n    Lens.fromProps = function () {\n        return function (props) { return fromLens(pipe(lens.id(), lens.props.apply(lens, props))); };\n    };\n    /**\n     * Returns a `Lens` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Lens } from 'monocle-ts'\n     *\n     * interface Outer {\n     *   inner?: Inner\n     * }\n     *\n     * interface Inner {\n     *   value: number\n     *   foo: string\n     * }\n     *\n     * const inner = Lens.fromNullableProp<Outer>()('inner', { value: 0, foo: 'foo' })\n     * const value = Lens.fromProp<Inner>()('value')\n     * const lens = inner.compose(value)\n     *\n     * assert.deepStrictEqual(lens.set(1)({}), { inner: { value: 1, foo: 'foo' } })\n     * assert.strictEqual(lens.get({}), 0)\n     * assert.deepStrictEqual(lens.set(1)({ inner: { value: 1, foo: 'bar' } }), { inner: { value: 1, foo: 'bar' } })\n     * assert.strictEqual(lens.get({ inner: { value: 1, foo: 'bar' } }), 1)\n     *\n     * @since 1.0.0\n     */\n    Lens.fromNullableProp = function () {\n        return function (k, defaultValue) {\n            return new Lens(function (s) {\n                var osk = fromNullable(s[k]);\n                if (isNone(osk)) {\n                    return defaultValue;\n                }\n                else {\n                    return osk.value;\n                }\n            }, function (a) { return function (s) { return update(s, k, a); }; });\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Lens.prototype.modify = function (f) {\n        return lens.modify(f)(this);\n    };\n    /**\n     * view a `Lens` as a Optional\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asOptional = function () {\n        return fromOptional(lens.asOptional(this));\n    };\n    /**\n     * view a `Lens` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asTraversal = function () {\n        return fromTraversal(lens.asTraversal(this));\n    };\n    /**\n     * view a `Lens` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Lens` as a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asGetter = function () {\n        var _this = this;\n        return new Getter(function (s) { return _this.get(s); });\n    };\n    /**\n     * view a `Lens` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Lens` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.compose = function (ab) {\n        return fromLens(lens.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeLens = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeGetter = function (ab) {\n        return this.asGetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Optional`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, lens.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, lens.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Lens` with an `Setter`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Lens` with an `Iso`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composeIso = function (ab) {\n        return fromLens(pipe(this, lens.compose(pipe(ab, iso.asLens))));\n    };\n    /**\n     * compose a `Lens` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Lens.prototype.composePrism = function (ab) {\n        return fromOptional(lens.composePrism(ab)(this));\n    };\n    return Lens;\n}());\nexport { Lens };\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, reverseGet)) = s`\n * 2. `getOption(reverseGet(a)) = some(a)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Prism = /** @class */ (function () {\n    function Prism(getOption, reverseGet) {\n        this.getOption = getOption;\n        this.reverseGet = reverseGet;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Prism';\n    }\n    Prism.fromPredicate = function (predicate) {\n        return fromPrism(prism.fromPredicate(predicate));\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.some = function () {\n        return somePrism;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modify = function (f) {\n        var _this = this;\n        return function (s) {\n            var os = _this.modifyOption(f)(s);\n            if (isNone(os)) {\n                return s;\n            }\n            else {\n                return os.value;\n            }\n        };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Prism.prototype.modifyOption = function (f) {\n        var _this = this;\n        return function (s) {\n            return option.map(_this.getOption(s), function (v) {\n                var n = f(v);\n                return n === v ? s : _this.reverseGet(n);\n            });\n        };\n    };\n    /**\n     * set the target of a `Prism` with a value\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.set = function (a) {\n        return this.modify(function () { return a; });\n    };\n    /**\n     * view a `Prism` as a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asOptional = function () {\n        return fromOptional(prism.asOptional(this));\n    };\n    /**\n     * view a `Prism` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asTraversal = function () {\n        return fromTraversal(prism.asTraversal(this));\n    };\n    /**\n     * view a `Prism` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * view a `Prism` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * compose a `Prism` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.compose = function (ab) {\n        return fromPrism(prism.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composePrism = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeOptional = function (ab) {\n        return fromOptional(pipe(this, prism.asOptional, optional.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, prism.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose a `Prism` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Prism` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeIso = function (ab) {\n        return fromPrism(pipe(this, prism.compose(pipe(ab, iso.asPrism))));\n    };\n    /**\n     * compose a `Prism` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeLens = function (ab) {\n        return fromOptional(prism.composeLens(ab)(this));\n    };\n    /**\n     * compose a `Prism` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Prism.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Prism;\n}());\nexport { Prism };\nvar somePrism = \n/*#__PURE__*/\nnew Prism(identity, some);\n/**\n * Laws:\n * 1. `pipe(getOption(s), fold(() => s, a => set(a)(s))) = s`\n * 2. `getOption(set(a)(s)) = pipe(getOption(s), map(_ => a))`\n * 3. `set(a)(set(a)(s)) = set(a)(s)`\n *\n * @category constructor\n * @since 1.0.0\n */\nvar Optional = /** @class */ (function () {\n    function Optional(getOption, set) {\n        this.getOption = getOption;\n        this.set = set;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Optional';\n    }\n    /**\n     * Returns an `Optional` from a nullable (`A | null | undefined`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface Phone {\n     *   number: string\n     * }\n     * interface Employment {\n     *   phone?: Phone\n     * }\n     * interface Info {\n     *   employment?: Employment\n     * }\n     * interface Response {\n     *   info?: Info\n     * }\n     *\n     * const numberFromResponse = Optional.fromPath<Response>()(['info', 'employment', 'phone', 'number'])\n     *\n     * const response1: Response = {\n     *   info: {\n     *     employment: {\n     *       phone: {\n     *         number: '555-1234'\n     *       }\n     *     }\n     *   }\n     * }\n     * const response2: Response = {\n     *   info: {\n     *     employment: {}\n     *   }\n     * }\n     *\n     * numberFromResponse.getOption(response1) // some('555-1234')\n     * numberFromResponse.getOption(response2) // none\n     *\n     * @since 2.1.0\n     */\n    Optional.fromPath = function () {\n        var fromNullableProp = Optional.fromNullableProp();\n        return function (path) {\n            var optional = fromNullableProp(path[0]);\n            return path.slice(1).reduce(function (acc, prop) { return acc.compose(fromNullableProp(prop)); }, optional);\n        };\n    };\n    /**\n     * @example\n     * import { Optional } from 'monocle-ts'\n     *\n     * interface S {\n     *   a: number | undefined | null\n     * }\n     *\n     * const optional = Optional.fromNullableProp<S>()('a')\n     *\n     * const s1: S = { a: undefined }\n     * const s2: S = { a: null }\n     * const s3: S = { a: 1 }\n     *\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), s2)\n     * assert.deepStrictEqual(optional.set(2)(s3), { a: 2 })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromNullableProp = function () {\n        return function (k) {\n            return new Optional(function (s) { return fromNullable(s[k]); }, function (a) { return function (s) { return (s[k] == null ? s : update(s, k, a)); }; });\n        };\n    };\n    /**\n     * Returns an `Optional` from an option (`Option<A>`) prop\n     *\n     * @example\n     * import { Optional } from 'monocle-ts'\n     * import * as O from 'fp-ts/Option'\n     *\n     * interface S {\n     *   a: O.Option<number>\n     * }\n     *\n     * const optional = Optional.fromOptionProp<S>()('a')\n     * const s1: S = { a: O.none }\n     * const s2: S = { a: O.some(1) }\n     * assert.deepStrictEqual(optional.set(2)(s1), s1)\n     * assert.deepStrictEqual(optional.set(2)(s2), { a: O.some(2) })\n     *\n     * @since 1.0.0\n     */\n    Optional.fromOptionProp = function () {\n        var formProp = Lens.fromProp();\n        return function (prop) { return formProp(prop).composePrism(somePrism); };\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modify = function (f) {\n        return optional.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Optional.prototype.modifyOption = function (f) {\n        return optional.modifyOption(f)(this);\n    };\n    /**\n     * view a `Optional` as a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asTraversal = function () {\n        return fromTraversal(optional.asTraversal(this));\n    };\n    /**\n     * view an `Optional` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return function (s) {\n            var oa = _this.getOption(s);\n            return isNone(oa) ? M.empty : f(oa.value);\n        }; }; });\n    };\n    /**\n     * view an `Optional` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Optional` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.compose = function (ab) {\n        return fromOptional(optional.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeOptional = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeTraversal = function (ab) {\n        return fromTraversal(pipe(this, optional.asTraversal, traversal.compose(ab)));\n    };\n    /**\n     * compose an `Optional` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose an `Optional` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeLens = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, lens.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composePrism = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, prism.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeIso = function (ab) {\n        return fromOptional(pipe(this, optional.compose(pipe(ab, iso.asOptional))));\n    };\n    /**\n     * compose an `Optional` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Optional.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Optional;\n}());\nexport { Optional };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Traversal = /** @class */ (function () {\n    function Traversal(\n    // Van Laarhoven representation\n    modifyF) {\n        this.modifyF = modifyF;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Traversal';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.modify = function (f) {\n        return traversal.modify(f)(this);\n    };\n    /**\n     * @since 1.0.0\n     */\n    Traversal.prototype.set = function (a) {\n        return traversal.set(a)(this);\n    };\n    Traversal.prototype.filter = function (predicate) {\n        return fromTraversal(traversal.filter(predicate)(this));\n    };\n    /**\n     * view a `Traversal` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function (M) { return function (f) {\n            return _this.modifyF(getApplicative(M))(function (a) { return make(f(a)); });\n        }; });\n    };\n    /**\n     * view a `Traversal` as a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.asSetter = function () {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(f); });\n    };\n    /**\n     * compose a `Traversal` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.compose = function (ab) {\n        return fromTraversal(traversal.compose(ab)(this));\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeTraversal = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeSetter = function (ab) {\n        return this.asSetter().compose(ab);\n    };\n    /**\n     * compose a `Traversal` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asTraversal());\n    };\n    /**\n     * compose a `Traversal` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeLens = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, lens.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composePrism = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, prism.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeIso = function (ab) {\n        return fromTraversal(pipe(this, traversal.compose(pipe(ab, iso.asTraversal))));\n    };\n    /**\n     * compose a `Traversal` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Traversal.prototype.composeGetter = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Traversal;\n}());\nexport { Traversal };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar At = /** @class */ (function () {\n    function At(at) {\n        this.at = at;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'At';\n    }\n    /**\n     * lift an instance of `At` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    At.prototype.fromIso = function (iso) {\n        return fromAt(at.fromIso(iso)(this));\n    };\n    return At;\n}());\nexport { At };\n/**\n * @category constructor\n * @since 1.2.0\n */\nvar Index = /** @class */ (function () {\n    function Index(index) {\n        this.index = index;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Index';\n    }\n    /**\n     * @since 1.2.0\n     */\n    Index.fromAt = function (at) {\n        return fromIndex(index.fromAt(at));\n    };\n    /**\n     * lift an instance of `Index` using an `Iso`\n     *\n     * @since 1.2.0\n     */\n    Index.prototype.fromIso = function (iso) {\n        return fromIndex(index.fromIso(iso)(this));\n    };\n    return Index;\n}());\nexport { Index };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Getter = /** @class */ (function () {\n    function Getter(get) {\n        this.get = get;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Getter';\n    }\n    /**\n     * view a `Getter` as a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.asFold = function () {\n        var _this = this;\n        return new Fold(function () { return function (f) { return function (s) { return f(_this.get(s)); }; }; });\n    };\n    /**\n     * compose a `Getter` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Getter(function (s) { return ab.get(_this.get(s)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeGetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeFold = function (ab) {\n        return this.asFold().compose(ab);\n    };\n    /**\n     * compose a `Getter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asGetter());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeTraversal = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composeOptional = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    /**\n     * compose a `Getter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Getter.prototype.composePrism = function (ab) {\n        return this.asFold().compose(ab.asFold());\n    };\n    return Getter;\n}());\nexport { Getter };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Fold = /** @class */ (function () {\n    function Fold(foldMap) {\n        this.foldMap = foldMap;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Fold';\n        this.getAll = foldMap(A.getMonoid())(A.of);\n        this.exist = foldMap(monoidAny);\n        this.all = foldMap(monoidAll);\n        this.foldMapFirst = foldMap(getFirstMonoid());\n    }\n    /**\n     * compose a `Fold` with a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.compose = function (ab) {\n        var _this = this;\n        return new Fold(function (M) { return function (f) { return _this.foldMap(M)(ab.foldMap(M)(f)); }; });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeFold = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Fold` with a `Getter`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeGetter = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeLens = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composePrism = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    /**\n     * compose a `Fold` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.composeIso = function (ab) {\n        return this.compose(ab.asFold());\n    };\n    Fold.prototype.find = function (p) {\n        return this.foldMapFirst(fromPredicate(p));\n    };\n    /**\n     * get the first target of a `Fold`\n     *\n     * @since 1.0.0\n     */\n    Fold.prototype.headOption = function (s) {\n        return this.find(function () { return true; })(s);\n    };\n    return Fold;\n}());\nexport { Fold };\n/**\n * @category constructor\n * @since 1.0.0\n */\nvar Setter = /** @class */ (function () {\n    function Setter(modify) {\n        this.modify = modify;\n        /**\n         * @since 1.0.0\n         */\n        this._tag = 'Setter';\n    }\n    /**\n     * @since 1.0.0\n     */\n    Setter.prototype.set = function (a) {\n        return this.modify(constant(a));\n    };\n    /**\n     * compose a `Setter` with a `Setter`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.compose = function (ab) {\n        var _this = this;\n        return new Setter(function (f) { return _this.modify(ab.modify(f)); });\n    };\n    /**\n     * Alias of `compose`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeSetter = function (ab) {\n        return this.compose(ab);\n    };\n    /**\n     * compose a `Setter` with a `Traversal`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeTraversal = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Optional`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeOptional = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Lens`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeLens = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Prism`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composePrism = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    /**\n     * compose a `Setter` with a `Iso`\n     *\n     * @since 1.0.0\n     */\n    Setter.prototype.composeIso = function (ab) {\n        return this.compose(ab.asSetter());\n    };\n    return Setter;\n}());\nexport { Setter };\nexport function fromTraversable(T) {\n    var f = traversal.fromTraversable(T);\n    return function () { return fromTraversal(f()); };\n}\nexport function fromFoldable(F) {\n    return function () {\n        return new Fold(function (M) {\n            var foldMapFM = F.foldMap(M);\n            return function (f) { return function (s) { return foldMapFM(s, f); }; };\n        });\n    };\n}\n",
  "debugger\r\n\r\nimport { array as a, eq, number, option as o, ord, string, task } from \"fp-ts\"\r\nimport { guard } from \"fp-ts-std/Function\"\r\nimport { anyPass } from \"fp-ts-std/Predicate\"\r\nimport { values } from \"fp-ts-std/Record\"\r\nimport { groupBy } from \"fp-ts/NonEmptyArray\"\r\nimport { mapWithIndex } from \"fp-ts/Record\"\r\nimport { constTrue, constant, flow as f, identity, pipe as p, tupled } from \"fp-ts/function\"\r\nimport { startsWith } from \"fp-ts/string\"\r\nimport { Lens, Optional } from \"monocle-ts\"\r\nimport { set } from \"spectacles-ts\"\r\nimport {\r\n    createSPPlaylistFromTracks,\r\n    fetchGQLAlbum,\r\n    fetchGQLArtistDiscography,\r\n    fetchGQLArtistOverview,\r\n    fetchPlatArtistLikedTracks,\r\n    fetchPlatFolder,\r\n    fetchPlatLikedTracks,\r\n    fetchPlatPlaylistContents,\r\n    fetchPlatRootFolder,\r\n    fetchTrackLFMAPI,\r\n    fetchWebAlbumsSpot,\r\n    fetchWebArtistsSpot,\r\n    fetchWebPlaylistsSpot,\r\n    fetchWebTracksSpot,\r\n    movePlatPlaylistTracks,\r\n    setPlatPlaylistVisibility,\r\n} from \"../../shared/api\"\r\nimport { objConcat, pMchain, tapAny, withProgress } from \"../../shared/fp\"\r\nimport {\r\n    TrackData,\r\n    TracksPopulater,\r\n    parseAPITrackFromPlaylist,\r\n    parseAPITrackFromSpotify,\r\n    parsePlatLikedTracks,\r\n    parsePlatTrackFromArtistLikedTracks,\r\n    parseTopTrackFromArtist,\r\n    parseTrackFromAlbum,\r\n} from \"../../shared/parse\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, createQueueItem, setPlayingContext, setQueue } from \"../../shared/util\"\r\nimport { CONFIG } from \"./settings\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nenum SortBy {\r\n    SPOTIFY_PLAYCOUNT = \"Spotify - Play Count\",\r\n    SPOTIFY_POPULARITY = \"Spotify - Popularity\",\r\n    SPOTIFY_RELEASEDATE = \"Spotify - Release Date\",\r\n    LASTFM_SCROBBLES = \"LastFM - Scrobbles\",\r\n    LASTFM_PERSONALSCROBBLES = \"LastFM - My Scrobbles\",\r\n    LASTFM_PLAYCOUNT = \"LastFM - Play Count\",\r\n}\r\n\r\nenum SortProp {\r\n    \"Spotify - Play Count\" = \"playcount\",\r\n    \"Spotify - Popularity\" = \"popularity\",\r\n    \"Spotify - Release Date\" = \"releaseDate\",\r\n    \"LastFM - Scrobbles\" = \"scrobbles\",\r\n    \"LastFM - My Scrobbles\" = \"personalScrobbles\",\r\n    \"LastFM - Play Count\" = \"lastfmPlaycount\",\r\n}\r\n\r\n// Fetching Tracks\r\n\r\nconst getAlbumTracks = async (uri: SpotifyURI) => {\r\n    const albumRes = await fetchGQLAlbum(uri)\r\n    const releaseDate = new Date(albumRes.date.isoString).getTime()\r\n\r\n    return p(\r\n        albumRes.tracks.items,\r\n        a.map(\r\n            f(\r\n                parseTrackFromAlbum,\r\n                set(\"albumUri\", albumRes.uri),\r\n                set(\"albumName\", albumRes.name),\r\n                set(\"releaseDate\", releaseDate),\r\n            ),\r\n        ),\r\n    )\r\n}\r\n\r\nconst getPlaylistTracks = f(fetchPlatPlaylistContents, pMchain(a.map(parseAPITrackFromPlaylist)))\r\n\r\nasync function getArtistTracks(uri: SpotifyURI) {\r\n    const extractUriFromReleases = (x: { releases: { items: Array<{ uri: SpotifyURI }> } }) => x.releases.items[0].uri\r\n    const getTracksFromAlbums = f(a.map(getAlbumTracks), ps => Promise.all(ps), pMchain(a.flatten))\r\n\r\n    const allTracks = new Array<TrackData | Promise<TrackData>>()\r\n\r\n    const add = (tracks: TrackData[]) => {\r\n        allTracks.push(...tracks)\r\n    }\r\n\r\n    const albumsLike = []\r\n    const albumsLikeReleases = []\r\n\r\n    if (CONFIG.artistAllDiscography) {\r\n        const disc = await fetchGQLArtistDiscography(uri)\r\n        albumsLikeReleases.push(...disc)\r\n    } else {\r\n        const disc = (await fetchGQLArtistOverview(uri)).discography\r\n\r\n        if (CONFIG.artistLikedTracks) {\r\n            const likedTracks = await fetchPlatArtistLikedTracks(uri)\r\n            p(likedTracks, a.map(parsePlatTrackFromArtistLikedTracks), add)\r\n        }\r\n\r\n        if (CONFIG.artistTopTracks)\r\n            p(\r\n                disc.topTracks.items,\r\n                a.map(i => i.track),\r\n                a.map(parseTopTrackFromArtist),\r\n                add,\r\n            )\r\n\r\n        if (CONFIG.artistPopularReleases) albumsLike.push(...disc.popularReleasesAlbums.items.map(r => r.uri))\r\n        if (CONFIG.artistSingles) albumsLikeReleases.push(...disc.singles.items)\r\n        if (CONFIG.artistAlbums) albumsLikeReleases.push(...disc.albums.items)\r\n        if (CONFIG.artistCompilations) albumsLikeReleases.push(...disc.compilations.items)\r\n    }\r\n\r\n    albumsLike.push(...albumsLikeReleases.map(extractUriFromReleases))\r\n    await p(albumsLike, getTracksFromAlbums, pMchain(add))\r\n\r\n    return await Promise.all(allTracks)\r\n}\r\n\r\n// ------------- For populateTracksSpot -------------\r\nconst fetchAPITracksFromTracks: TracksPopulater = f(\r\n    a.map(({ uri }) => URI.fromString(uri)!.id!),\r\n    fetchWebTracksSpot,\r\n    pMchain(a.map(parseAPITrackFromSpotify)),\r\n)\r\n\r\nconst fetchAlbumTracksFromTracks: TracksPopulater = f(\r\n    groupBy(track => track.albumUri!),\r\n    withProgress(mapWithIndex<SpotifyURI, TrackData[], Promise<TrackData[]>>)(async (albumUri, tracks) => {\r\n        const uriEq = p(\r\n            string.Eq,\r\n            eq.contramap((t: TrackData) => t.uri),\r\n        )\r\n\r\n        const albumTracks = await getAlbumTracks(albumUri)\r\n\r\n        return a.intersection(uriEq)(albumTracks, tracks)\r\n    }),\r\n    values,\r\n    ps => Promise.all(ps),\r\n    pMchain(a.flatten),\r\n)\r\n// --------------------------------------------------\r\n\r\nconst populateTracksSpot = (propName: keyof typeof SortProp) => (tracks: TrackData[]) =>\r\n    p(\r\n        tracks,\r\n        a.filter(f(toOptProp(propName), o.isNone)),\r\n        guard([[startsWith(SortBy.SPOTIFY_PLAYCOUNT), constant(fetchAlbumTracksFromTracks)]])(\r\n            constant(fetchAPITracksFromTracks),\r\n        )(propName),\r\n        pMchain(a.concat(tracks)),\r\n        pMchain(groupBy(Lens.fromProp<TrackData>()(\"uri\").get)),\r\n        pMchain(values<TrackData[]>),\r\n        pMchain(a.map(objConcat<TrackData>())),\r\n    )\r\n\r\nconst populateTrackLastFM = async (track: TrackData) => {\r\n    const lastfmTrack = (await fetchTrackLFMAPI(CONFIG.LFMApiKey, track.artistName, track.name, CONFIG.lastFmUsername))\r\n        .track\r\n    track.lastfmPlaycount = Number(lastfmTrack.listeners)\r\n    track.scrobbles = Number(lastfmTrack.playcount)\r\n    track.personalScrobbles = Number(lastfmTrack.userplaycount)\r\n    return track\r\n}\r\n\r\n// Fetching, Sorting and Playing\r\n\r\nconst fetchTracks = f(\r\n    tapAny(uri => void (lastFetchedUri = uri)),\r\n    guard<SpotifyURI, Promise<TrackData[]>>([\r\n        [URI.isAlbum, getAlbumTracks],\r\n        [URI.isArtist, getArtistTracks],\r\n        [URI.isPlaylistV1OrV2, getPlaylistTracks],\r\n        [URI.isCollection, f(fetchPlatLikedTracks, pMchain(a.map(parsePlatLikedTracks)))],\r\n    ])(task.of([])),\r\n)\r\n\r\nconst populateTracks = guard<keyof typeof SortProp, TracksPopulater>([\r\n    [startsWith(\"Spotify\"), populateTracksSpot],\r\n    [\r\n        startsWith(\"LastFM\"),\r\n        constant(f(p(withProgress(a.map<TrackData, Promise<TrackData>>)(populateTrackLastFM)), ps => Promise.all(ps))),\r\n    ],\r\n])(constant(task.of([])))\r\n\r\nlet lastSortedQueue: TrackData[] = []\r\n;(globalThis as any).lastSortedQueue = lastSortedQueue\r\nconst _setQueue = (inverted: boolean) => async (queue: TrackData[]) => {\r\n    if (Spicetify.Platform.PlayerAPI._queue._queue === null)\r\n        return void Spicetify.showNotification(\"Queue is null!\", true)\r\n\r\n    const uriOrd = p(\r\n        string.Ord,\r\n        ord.contramap((t: TrackData) => t.uri),\r\n    )\r\n\r\n    lastSortedQueue = p(queue, a.uniq(uriOrd), inverted ? a.reverse : identity)\r\n    console.log(\" ~ file: app.tsx:217 ~ const_setQueue= ~ inverted:\", inverted)\r\n    console.log(\" ~ file: app.tsx:217 ~ const_setQueue= ~ lastSortedQueue:\", lastSortedQueue)\r\n    ;(globalThis as any).lastSortedQueue = lastSortedQueue\r\n\r\n    const isQueued = URI.isCollection(lastFetchedUri)\r\n\r\n    await p(\r\n        lastSortedQueue,\r\n        a.map(t => t.uri),\r\n        a.concat([\"spotify:separator\"]),\r\n        a.map(createQueueItem(isQueued)),\r\n        setQueue,\r\n    )\r\n    if (!isQueued) await setPlayingContext(lastFetchedUri)\r\n    await Spicetify.Platform.PlayerAPI.skipToNext()\r\n}\r\n\r\nconst toOptProp = (prop: keyof typeof SortProp) => Optional.fromNullableProp<TrackData>()(SortProp[prop]).getOption\r\n\r\nlet lastFetchedUri: SpotifyURI\r\nlet lastActionName: keyof typeof SortProp | \"True Shuffle\" | \"Stars\"\r\nconst sortByProp = (name: keyof typeof SortProp) => async (uri: SpotifyURI) => {\r\n    lastActionName = name\r\n    const descending = invertOrder ^ Number(CONFIG.descending)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ descending:\", descending)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ invertOrder:\", invertOrder)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ CONFIG.descending:\", CONFIG.descending)\r\n\r\n    const propOrd = p(\r\n        number.Ord,\r\n        ord.contramap((t: Required<TrackData>) => t[SortProp[name]]),\r\n    )\r\n\r\n    p(\r\n        uri,\r\n        fetchTracks,\r\n        pMchain(populateTracks(name)),\r\n        pMchain(a.map(x => (p(x, toOptProp(name), o.isSome) ? o.some(x as Required<TrackData>) : o.none))),\r\n        pMchain(a.sequence(o.Applicative)),\r\n        pMchain(o.map(a.sort(propOrd))),\r\n        pMchain(o.map(_setQueue(!!descending))),\r\n    )\r\n}\r\n\r\nlet invertOrder = 0\r\nwindow.addEventListener(\"keydown\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 1\r\n})\r\n\r\nwindow.addEventListener(\"keyup\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 0\r\n})\r\n\r\n// Menu\r\n\r\nconst fetchSortQueue =\r\n    (name: typeof lastActionName, sortFn: (tracksIn: TrackData[]) => TrackData[]) =>\r\n    ([uri]: [SpotifyURI]) => {\r\n        lastActionName = name\r\n        const descending = invertOrder ^ Number(CONFIG.descending)\r\n        p(uri, fetchTracks, pMchain(sortFn), pMchain(_setQueue(!!descending)))\r\n    }\r\n\r\nconst shuffle = <A,>(array: A[], l = array.length): A[] =>\r\n    l == 0 ? [] : [array.splice(Math.floor(Math.random() * l), 1)[0], ...shuffle(array)]\r\nconst shuffleSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"True Shuffle\",\r\n    fetchSortQueue(\"True Shuffle\", shuffle) as any,\r\n    constTrue,\r\n    \"shuffle\",\r\n    false,\r\n)\r\n\r\nconst starsOrd = p(\r\n    number.Ord,\r\n    ord.contramap((t: { uri: SpotifyURI }) => (globalThis as any).tracksRatings[t.uri] ?? 0),\r\n)\r\nconst starsSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"Stars\",\r\n    fetchSortQueue(\"Stars\", a.sort(starsOrd)) as any,\r\n    () => (globalThis as any).tracksRatings !== undefined,\r\n    \"heart-active\",\r\n    false,\r\n)\r\n\r\nconst createSortByPropSubmenu = (name: keyof typeof SortProp, icon: any) =>\r\n    new Spicetify.ContextMenu.Item(name, tupled(sortByProp(name)) as any, constTrue, icon, false)\r\n\r\nnew Spicetify.ContextMenu.SubMenu(\r\n    \"Sort by\",\r\n    a\r\n        .zipWith(\r\n            values(SortBy),\r\n            [\"play\", \"heart\", \"list-view\", \"volume\", \"artist\", \"subtitles\"],\r\n            createSortByPropSubmenu,\r\n        )\r\n        .concat([shuffleSubmenu, starsSubmenu]),\r\n    tupled(anyPass([URI.isAlbum, URI.isArtist, URI.isPlaylistV1OrV2, URI.isCollection])) as any,\r\n).register()\r\n\r\n// Topbar\r\n\r\nconst generatePlaylistName = async () => {\r\n    const uriToId = (uri: SpotifyURI) => URI.fromString(uri)!.id!\r\n    const getName = (fn: Function) => async (id: SpotifyID) => (await fn([id]))[0].name\r\n\r\n    const collectionName = await guard([\r\n        [URI.isAlbum, f(uriToId, getName(fetchWebAlbumsSpot))],\r\n        [URI.isArtist, f(uriToId, getName(fetchWebArtistsSpot))],\r\n        [URI.isPlaylistV1OrV2, f(uriToId, getName(fetchWebPlaylistsSpot))],\r\n        [URI.isCollection, task.of(\"Liked Tracks\")],\r\n    ])(task.of(\"Unresolved\"))(lastFetchedUri)\r\n\r\n    return `${collectionName} - ${lastActionName}`\r\n}\r\nnew Spicetify.Topbar.Button(\"Add Sorted Queue to Sorted Playlists\", \"plus2px\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n\r\n    const sortedPlaylistsFolder = await fetchPlatFolder(CONFIG.sortedPlaylistsFolderUri).catch(fetchPlatRootFolder)\r\n\r\n    const playlistName = await generatePlaylistName()\r\n\r\n    const { uri } = await createSPPlaylistFromTracks(\r\n        playlistName,\r\n        lastSortedQueue.map(t => t.uri),\r\n        sortedPlaylistsFolder.uri,\r\n    )\r\n\r\n    setPlatPlaylistVisibility(uri, false)\r\n\r\n    Spicetify.showNotification(`Playlist ${playlistName} created`)\r\n})\r\n\r\nnew Spicetify.Topbar.Button(\"Reorder Playlist with Sorted Queue\", \"chart-down\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n    if (!URI.isPlaylistV1OrV2(lastFetchedUri))\r\n        return void Spicetify.showNotification(\"Last sorted queue must be a playlist\")\r\n\r\n    p(\r\n        lastSortedQueue as unknown as Array<{ uid: string }>,\r\n        withProgress(a.map<{ uid: string }, void>)(\r\n            t => void movePlatPlaylistTracks(lastFetchedUri, [t], SpotifyLoc.after.end()),\r\n        ),\r\n    )\r\n})\r\n",
  "import { array as a, eq, string } from \"fp-ts\"\r\nimport { guard, memoize } from \"fp-ts-std/Function\"\r\nimport { getUnionSemigroup } from \"fp-ts/Record\"\r\nimport { Refinement } from \"fp-ts/Refinement\"\r\nimport { first } from \"fp-ts/Semigroup\"\r\nimport { flow as f, pipe as p, tupled, untupled } from \"fp-ts/function\"\r\n\r\ntype refineBranch<A, B extends A, R> = [Refinement<A, B>, (x: B) => R]\r\nexport const guard2 = <A, A1 extends A, A2 extends A, R>(branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>]) =>\r\n    guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard3 = <A, A1 extends A, A2 extends A, A3 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>],\r\n) => guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard4 = <A, A1 extends A, A2 extends A, A3 extends A, A4 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>, refineBranch<A, A4, R>],\r\n) =>\r\n    guard(\r\n        branches as unknown as [\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n        ],\r\n    )\r\nexport const guard5 = <A, A1 extends A, A2 extends A, A3 extends A, A4 extends A, A5 extends A, R>(\r\n    branches: [\r\n        refineBranch<A, A1, R>,\r\n        refineBranch<A, A2, R>,\r\n        refineBranch<A, A3, R>,\r\n        refineBranch<A, A4, R>,\r\n        refineBranch<A, A5, R>,\r\n    ],\r\n) =>\r\n    guard(\r\n        branches as unknown as [\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n        ],\r\n    )\r\n\r\nexport const objConcat2 = <A1, A2>() => getUnionSemigroup(first<any>()).concat as (x: A1, y: A2) => A1 & A2\r\nexport const objConcat = <A,>() => a.reduce({} as A, objConcat2<A, A>())\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const is =\r\n    <A,>(c: keyof A) =>\r\n    <B extends A>(a: A[typeof c]) =>\r\n    (field: A): field is B =>\r\n        field[c] === a\r\n\r\nexport const tapAny =\r\n    <A,>(f: (a: A) => void) =>\r\n    (fa: A) => {\r\n        f(fa)\r\n        return fa\r\n    }\r\n\r\nexport const chunckify =\r\n    (n: number) =>\r\n    <A, R>(g: (a: A[]) => Promise<R[]>) =>\r\n        f(a.chunksOf(n)<A>, a.map(g), ps => Promise.all(ps), pMchain(a.flatten))\r\n\r\nexport const withProgress =\r\n    <F extends (f: (...a: any) => any) => (fa: any) => any>(map: F) =>\r\n    (f: Parameters<F>[0]) =>\r\n    (fa: Parameters<ReturnType<F>>[0]): ReturnType<ReturnType<F>> => {\r\n        let i = 0\r\n        return map(async (...a: Parameters<Parameters<F>[0]>) => {\r\n            // @ts-ignore\r\n            const ret = await f(...a)\r\n            const progress = Math.round((i++ / Object.values(fa).length) * 100)\r\n            Spicetify.showNotification(`Loading: ${progress}%`, false, 200)\r\n            return ret\r\n        })(fa)\r\n    }\r\n\r\nexport const memoize2 = <A extends any[], R>(fn: (...args: A) => R) =>\r\n    p(fn, tupled, memoize<A>(eq.contramap(JSON.stringify)(string.Eq)), untupled)\r\n",
  "import { array as a, eq, string } from \"fp-ts\"\r\nimport { guard, memoize } from \"fp-ts-std/Function\"\r\nimport { getUnionSemigroup } from \"fp-ts/Record\"\r\nimport { Refinement } from \"fp-ts/Refinement\"\r\nimport { first } from \"fp-ts/Semigroup\"\r\nimport { flow as f, pipe as p, tupled, untupled } from \"fp-ts/function\"\r\n\r\ntype refineBranch<A, B extends A, R> = [Refinement<A, B>, (x: B) => R]\r\nexport const guard2 = <A, A1 extends A, A2 extends A, R>(branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>]) =>\r\n    guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard3 = <A, A1 extends A, A2 extends A, A3 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>],\r\n) => guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard4 = <A, A1 extends A, A2 extends A, A3 extends A, A4 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>, refineBranch<A, A4, R>],\r\n) =>\r\n    guard(\r\n        branches as unknown as [\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n        ],\r\n    )\r\nexport const guard5 = <A, A1 extends A, A2 extends A, A3 extends A, A4 extends A, A5 extends A, R>(\r\n    branches: [\r\n        refineBranch<A, A1, R>,\r\n        refineBranch<A, A2, R>,\r\n        refineBranch<A, A3, R>,\r\n        refineBranch<A, A4, R>,\r\n        refineBranch<A, A5, R>,\r\n    ],\r\n) =>\r\n    guard(\r\n        branches as unknown as [\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n            refineBranch<A, A, R>,\r\n        ],\r\n    )\r\n\r\nexport const objConcat2 = <A1, A2>() => getUnionSemigroup(first<any>()).concat as (x: A1, y: A2) => A1 & A2\r\nexport const objConcat = <A,>() => a.reduce({} as A, objConcat2<A, A>())\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const is =\r\n    <A,>(c: keyof A) =>\r\n    <B extends A>(a: A[typeof c]) =>\r\n    (field: A): field is B =>\r\n        field[c] === a\r\n\r\nexport const tapAny =\r\n    <A,>(f: (a: A) => void) =>\r\n    (fa: A) => {\r\n        f(fa)\r\n        return fa\r\n    }\r\n\r\nexport const chunckify =\r\n    (n: number) =>\r\n    <A, R>(g: (a: A[]) => Promise<R[]>) =>\r\n        f(a.chunksOf(n)<A>, a.map(g), ps => Promise.all(ps), pMchain(a.flatten))\r\n\r\nexport const withProgress =\r\n    <F extends (f: (...a: any) => any) => (fa: any) => any>(map: F) =>\r\n    (f: Parameters<F>[0]) =>\r\n    (fa: Parameters<ReturnType<F>>[0]): ReturnType<ReturnType<F>> => {\r\n        let i = 0\r\n        return map(async (...a: Parameters<Parameters<F>[0]>) => {\r\n            // @ts-ignore\r\n            const ret = await f(...a)\r\n            const progress = Math.round((i++ / Object.values(fa).length) * 100)\r\n            Spicetify.showNotification(`Loading: ${progress}%`, false, 200)\r\n            return ret\r\n        })(fa)\r\n    }\r\n\r\nexport const memoize2 = <A extends any[], R>(fn: (...args: A) => R) =>\r\n    p(fn, tupled, memoize<A>(eq.contramap(JSON.stringify)(string.Eq)), untupled)\r\n",
  "// export interface SpotifyID\r\n//     extends Newtype<{ readonly SpotifyID: unique symbol }, string> {}\r\n// export interface SpotifyURI\r\n//     extends Newtype<{ readonly SpotifyURI: unique symbol }, string> {}\r\n\r\nimport { array as a } from \"fp-ts\"\r\nimport { constant, pipe as p } from \"fp-ts/function\"\r\n\r\nexport const mustLoadForApi = [\"CosmosAsync\", \"GraphQL\", \"Platform\"]\r\nexport const mustLoadForUtil = [\"URI\"]\r\nexport const mustLoadForSettings = [\"React\", \"ReactDOM\"]\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLoc = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport namespace SpotifyLoc {\r\n    export namespace before {\r\n        export const start = constant({ before: \"start\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n\r\n    export namespace after {\r\n        export const end = constant({ after: \"end\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\n//! Does location actually point to document.body?\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E,\r\n) =>\r\n    new Promise((resolve: (value: Element | null) => void) => {\r\n        const res = (v: any) => {\r\n            observer.disconnect()\r\n            resolve(v)\r\n        }\r\n\r\n        const observer = new MutationObserver(() => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el && (!notEl || el !== notEl)) return res(el)\r\n        })\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout) setTimeout(() => res(null), timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const isLiked = (uris: SpotifyURI[]) => Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"](...uris)\r\n\r\nexport const toggleLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isLiked(uris)\r\n\r\n    return await p(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n",
  "// export interface SpotifyID\r\n//     extends Newtype<{ readonly SpotifyID: unique symbol }, string> {}\r\n// export interface SpotifyURI\r\n//     extends Newtype<{ readonly SpotifyURI: unique symbol }, string> {}\r\n\r\nimport { array as a } from \"fp-ts\"\r\nimport { constant, pipe as p } from \"fp-ts/function\"\r\n\r\nexport const mustLoadForApi = [\"CosmosAsync\", \"GraphQL\", \"Platform\"]\r\nexport const mustLoadForUtil = [\"URI\"]\r\nexport const mustLoadForSettings = [\"React\", \"ReactDOM\"]\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLoc = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport namespace SpotifyLoc {\r\n    export namespace before {\r\n        export const start = constant({ before: \"start\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n\r\n    export namespace after {\r\n        export const end = constant({ after: \"end\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\n//! Does location actually point to document.body?\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E,\r\n) =>\r\n    new Promise((resolve: (value: Element | null) => void) => {\r\n        const res = (v: any) => {\r\n            observer.disconnect()\r\n            resolve(v)\r\n        }\r\n\r\n        const observer = new MutationObserver(() => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el && (!notEl || el !== notEl)) return res(el)\r\n        })\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout) setTimeout(() => res(null), timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const isLiked = (uris: SpotifyURI[]) => Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"](...uris)\r\n\r\nexport const toggleLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isLiked(uris)\r\n\r\n    return await p(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n",
  "// export interface SpotifyID\r\n//     extends Newtype<{ readonly SpotifyID: unique symbol }, string> {}\r\n// export interface SpotifyURI\r\n//     extends Newtype<{ readonly SpotifyURI: unique symbol }, string> {}\r\n\r\nimport { array as a } from \"fp-ts\"\r\nimport { constant, pipe as p } from \"fp-ts/function\"\r\n\r\nexport const mustLoadForApi = [\"CosmosAsync\", \"GraphQL\", \"Platform\"]\r\nexport const mustLoadForUtil = [\"URI\"]\r\nexport const mustLoadForSettings = [\"React\", \"ReactDOM\"]\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLoc = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport namespace SpotifyLoc {\r\n    export namespace before {\r\n        export const start = constant({ before: \"start\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n\r\n    export namespace after {\r\n        export const end = constant({ after: \"end\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\n//! Does location actually point to document.body?\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E,\r\n) =>\r\n    new Promise((resolve: (value: Element | null) => void) => {\r\n        const res = (v: any) => {\r\n            observer.disconnect()\r\n            resolve(v)\r\n        }\r\n\r\n        const observer = new MutationObserver(() => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el && (!notEl || el !== notEl)) return res(el)\r\n        })\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout) setTimeout(() => res(null), timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const isLiked = (uris: SpotifyURI[]) => Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"](...uris)\r\n\r\nexport const toggleLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isLiked(uris)\r\n\r\n    return await p(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n",
  "// export interface SpotifyID\r\n//     extends Newtype<{ readonly SpotifyID: unique symbol }, string> {}\r\n// export interface SpotifyURI\r\n//     extends Newtype<{ readonly SpotifyURI: unique symbol }, string> {}\r\n\r\nimport { array as a } from \"fp-ts\"\r\nimport { constant, pipe as p } from \"fp-ts/function\"\r\n\r\nexport const mustLoadForApi = [\"CosmosAsync\", \"GraphQL\", \"Platform\"]\r\nexport const mustLoadForUtil = [\"URI\"]\r\nexport const mustLoadForSettings = [\"React\", \"ReactDOM\"]\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLoc = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport namespace SpotifyLoc {\r\n    export namespace before {\r\n        export const start = constant({ before: \"start\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n\r\n    export namespace after {\r\n        export const end = constant({ after: \"end\" } as SpotifyLoc)\r\n\r\n        export const fromUri = (uri: SpotifyURI) => ({\r\n            before: { uri },\r\n        })\r\n\r\n        export const fromUid = (uid: string) => ({\r\n            before: { uid },\r\n        })\r\n    }\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\n//! Does location actually point to document.body?\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E,\r\n) =>\r\n    new Promise((resolve: (value: Element | null) => void) => {\r\n        const res = (v: any) => {\r\n            observer.disconnect()\r\n            resolve(v)\r\n        }\r\n\r\n        const observer = new MutationObserver(() => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el && (!notEl || el !== notEl)) return res(el)\r\n        })\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout) setTimeout(() => res(null), timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const isLiked = (uris: SpotifyURI[]) => Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"](...uris)\r\n\r\nexport const toggleLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isLiked(uris)\r\n\r\n    return await p(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { invokeNullary } from \"fp-ts-std/Function\"\r\nimport { pipe as p } from \"fp-ts/function\"\r\nimport { pMchain, chunckify, memoize2 } from \"./fp\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, escapeRegex } from \"./util\"\r\n\r\nconst { URI } = Spicetify\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const likePlatPlaylist = async (uri: SpotifyURI) => await Spicetify.Platform.RootlistAPI.add([uri])\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLoc = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLoc = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n",
  "import { SpotApiTrack, fetchGQLAlbumRes, fetchPlatArtistLikedTracksRes, fetchWebPlaylistRes } from \"./api\"\r\nimport { SpotifyURI } from \"./util\"\r\n\r\nexport type TrackData = {\r\n    albumName?: string\r\n    albumUri: SpotifyURI\r\n    artistName: string\r\n    artistUri: SpotifyURI\r\n    durationMilis: number\r\n    name: string\r\n    playcount?: number\r\n    popularity?: number\r\n    releaseDate?: number\r\n    uri: SpotifyURI\r\n    lastfmPlaycount?: number\r\n    scrobbles?: number\r\n    personalScrobbles?: number\r\n}\r\n\r\nexport type UnparsedTrack = any\r\nexport type TrackParser = (track: UnparsedTrack) => TrackData\r\nexport type TracksPopulater = (tracks: TrackData[]) => Promise<TrackData[]>\r\n\r\nexport const parseTrackFromAlbum = ({ track }: fetchGQLAlbumRes[\"tracks\"][\"items\"][0]) => ({\r\n    albumName: \"\", // gets filled in later\r\n    albumUri: \"\", // gets filled in later\r\n    artistName: track.artists.items[0].profile.name,\r\n    artistUri: track.artists.items[0].uri,\r\n    durationMilis: track.duration.totalMilliseconds,\r\n    name: track.name,\r\n    playcount: Number(track.playcount),\r\n    popularity: undefined,\r\n    releaseDate: -1, // gets filled in later\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parseTopTrackFromArtist = (track: UnparsedTrack) => ({\r\n    albumName: undefined,\r\n    albumUri: track.albumOfTrack.uri as SpotifyURI,\r\n    artistName: track.artists.items[0].profile.name as string,\r\n    artistUri: track.artists.items[0].uri as SpotifyURI,\r\n    durationMilis: track.duration.totalMilliseconds as number,\r\n    name: track.name as string,\r\n    playcount: Number(track.playcount) as number,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri as SpotifyURI,\r\n})\r\n\r\nexport const parsePlatTrackFromArtistLikedTracks = (track: fetchPlatArtistLikedTracksRes[0]) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration.milliseconds,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri,\r\n})\r\n\r\n// NOT USED\r\n// export const parseTrackFromPlaylistSP = (track: UnparsedTrack) => ({\r\n//     albumName: track.album.name,\r\n//     albumUri: track.album.link,\r\n//     artistName: track.artists[0].name,\r\n//     artistUri: track.artists[0].link,\r\n//     durationMilis: track.length * 1000,\r\n//     name: track.name,\r\n//     playcount: undefined,\r\n//     popularity: track.popularity,\r\n//     releaseDate: undefined,\r\n//     uri: track.link,\r\n// })\r\n\r\nexport const parseAPITrackFromPlaylist = (track: fetchWebPlaylistRes[0]) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration.milliseconds,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uid: track.uid,\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parseAPITrackFromSpotify = (track: SpotApiTrack) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration_ms,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: track.popularity,\r\n    releaseDate: new Date(track.album.release_date).getTime(),\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parsePlatLikedTracks = (track: UnparsedTrack) => ({\r\n    albumName: track.album.name as string,\r\n    albumUri: track.album.uri as SpotifyURI,\r\n    artistName: track.artists[0].name as string,\r\n    artistUri: track.artists[0].uri as SpotifyURI,\r\n    durationMilis: track.duration.milliseconds as number,\r\n    name: track.name as string,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri as SpotifyURI,\r\n})\r\n",
  "import { task } from \"fp-ts\"\r\nimport { constVoid } from \"fp-ts/function\"\r\nimport React, { useState } from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport { guard4, is } from \"./fp\"\r\nimport { sleep } from \"./util\"\r\n\r\nexport class SettingsSection {\r\n    private stopHistoryListener: any\r\n    private setRerender: Function | null = null\r\n\r\n    constructor(\r\n        public name: string,\r\n        public sectionId: string,\r\n        public sectionFields: { [key: string]: SettingsField } = {},\r\n    ) {}\r\n\r\n    static waitForReact = async () => {\r\n        while (!(Spicetify.React && Spicetify.ReactDOM)) sleep(100)\r\n        return this\r\n    }\r\n\r\n    pushSettings = async () => {\r\n        while (!Spicetify?.Platform?.History?.listen) await sleep(100)\r\n\r\n        if (this.stopHistoryListener) this.stopHistoryListener()\r\n\r\n        this.stopHistoryListener = Spicetify.Platform.History.listen(({ pathname = \"\" }) => {\r\n            if (pathname === \"/preferences\") this.render()\r\n        })\r\n\r\n        if (Spicetify.Platform.History.location.pathname === \"/preferences\") await this.render()\r\n    }\r\n\r\n    toObject = () =>\r\n        new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop) => SettingsSection.getFieldValue(this.getId(prop.toString())),\r\n            },\r\n        )\r\n\r\n    rerender = () => {\r\n        if (this.setRerender) this.setRerender(Math.random())\r\n    }\r\n\r\n    private render = async () => {\r\n        while (!document.getElementById(\"desktop.settings.selectLanguage\")) {\r\n            if (Spicetify.Platform.History.location.pathname !== \"/preferences\") return\r\n            await sleep(100)\r\n        }\r\n\r\n        const allSettingsContainer = document.querySelector(\".x-settings-container\")!\r\n\r\n        let pluginSettingsContainer = Array.from(allSettingsContainer.children).find(({ id }) => id === this.sectionId)\r\n\r\n        if (!pluginSettingsContainer) {\r\n            pluginSettingsContainer = document.createElement(\"div\")\r\n            pluginSettingsContainer.id = this.sectionId\r\n            pluginSettingsContainer.className = \"settingsContainer\"\r\n            allSettingsContainer.appendChild(pluginSettingsContainer)\r\n        }\r\n\r\n        ReactDOM.render(<this.FieldsContainer />, pluginSettingsContainer)\r\n    }\r\n\r\n    addButton = (\r\n        nameId: string,\r\n        description: string,\r\n        text: string,\r\n        onClick: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void = constVoid,\r\n        events: ButtonField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        events.onClick = onClick\r\n\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.BUTTON,\r\n            description,\r\n            text,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addToggle = (\r\n        nameId: string,\r\n        description: string,\r\n        defaultValue = task.of(true),\r\n        onChange: (e: React.ChangeEvent<HTMLInputElement>) => void = constVoid,\r\n        events: ToggleField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.TOGGLE,\r\n            description,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addInput = (\r\n        nameId: string,\r\n        description: string,\r\n        defaultValue: task.Task<string>,\r\n        onChange: (e: React.ChangeEvent<HTMLInputElement>) => void = constVoid,\r\n        inputType = \"text\",\r\n        events: InputField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.INPUT,\r\n            description,\r\n            inputType,\r\n            events,\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    addDropDown = (\r\n        nameId: string,\r\n        description: string,\r\n        options: string[],\r\n        defaultValue = task.of(0),\r\n        onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void = constVoid,\r\n        events: DropdownField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.DROPDOWN,\r\n            description,\r\n            options,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addHidden = (nameId: string, defaultValue: any) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.HIDDEN,\r\n            description: \"\",\r\n        }\r\n        return this\r\n    }\r\n\r\n    getId = (nameId: string) => `extensions:${this.sectionId}:${nameId}`\r\n\r\n    private useStateFor = <A,>(id: string) => {\r\n        const [value, setValueState] = useState(SettingsSection.getFieldValue<A>(id))\r\n\r\n        return [\r\n            value,\r\n            (newValue: A) => {\r\n                if (newValue !== undefined) {\r\n                    setValueState(newValue)\r\n                    SettingsSection.setFieldValue(id!, newValue)\r\n                }\r\n            },\r\n        ] as const\r\n    }\r\n\r\n    static getFieldValue = <R,>(id: string): R => {\r\n        return JSON.parse(Spicetify.LocalStorage.get(id) ?? \"null\") // \"null\" is parsed as null, the more you know\r\n    }\r\n\r\n    static setFieldValue = (id: string, newValue: any) => {\r\n        Spicetify.LocalStorage.set(id, JSON.stringify(newValue))\r\n    }\r\n\r\n    private static setDefaultFieldValue = async (id: string, defaultValue: task.Task<any>) => {\r\n        if (SettingsSection.getFieldValue(id) === null) SettingsSection.setFieldValue(id, await defaultValue())\r\n    }\r\n\r\n    private FieldsContainer = () => {\r\n        const [rerender, setRerender] = useState<number>(0)\r\n        this.setRerender = setRerender\r\n\r\n        return (\r\n            <div className=\"x-settings-section\" key={rerender}>\r\n                <h2 className=\"Type__TypeElement-sc-goli3j-0 TypeElement-cello-textBase-type\">{this.name}</h2>\r\n                {Object.entries(this.sectionFields).map(([nameId, field]) => {\r\n                    return <this.Field field={field} />\r\n                })}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    private Field = ({ field }: { field: SettingsField }) => {\r\n        const isType = is<SettingsField>(\"type\")\r\n\r\n        return (\r\n            <div className=\"x-settings-row\">\r\n                <this.SettingDescription id={field.id} description={field.description} />\r\n                <div className=\"x-settings-secondColumn\">\r\n                    {guard4([\r\n                        [isType<InputField>(FieldType.INPUT), this.SettingInputField],\r\n                        [isType(FieldType.BUTTON), this.SettingButtonField],\r\n                        [isType(FieldType.TOGGLE), this.SettingToggleField],\r\n                        [isType(FieldType.DROPDOWN), this.SettingDropdownField],\r\n                    ])(this.SettingHidden)(field)}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    private SettingDescription = ({ id, description }: { id: string; description: string }) => (\r\n        <div className=\"x-settings-firstColumn\">\r\n            <label className=\"Type__TypeElement-sc-goli3j-0 TypeElement-viola-textSubdued-type\" htmlFor={id}>\r\n                {description}\r\n            </label>\r\n        </div>\r\n    )\r\n\r\n    private SettingButtonField = (field: ButtonField) => (\r\n        <span className=\"\">\r\n            <button\r\n                id={field.id}\r\n                className=\"Button-sc-y0gtbx-0 Button-sm-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button\"\r\n                {...field.events}\r\n                type={field.type}\r\n            >\r\n                {field.text}\r\n            </button>\r\n        </span>\r\n    )\r\n\r\n    private SettingToggleField = (field: ToggleField) => {\r\n        const [value, setValue] = this.useStateFor<boolean>(field.id)\r\n\r\n        return (\r\n            <label className=\"x-settings-secondColumn x-toggle-wrapper\">\r\n                <input\r\n                    id={field.id}\r\n                    className=\"x-toggle-input\"\r\n                    type=\"checkbox\"\r\n                    checked={SettingsSection.getFieldValue(field.id)}\r\n                    {...field.events}\r\n                    onChange={e => {\r\n                        setValue(e.currentTarget.checked)\r\n                        field.events.onChange?.(e)\r\n                    }}\r\n                />\r\n                <span className=\"x-toggle-indicatorWrapper\">\r\n                    <span className=\"x-toggle-indicator\"></span>\r\n                </span>\r\n            </label>\r\n        )\r\n    }\r\n\r\n    private SettingInputField = (field: InputField) => {\r\n        const [value, setValue] = this.useStateFor<string>(field.id)\r\n\r\n        return (\r\n            <input\r\n                className=\"x-settings-input\"\r\n                id={field.id}\r\n                dir=\"ltr\"\r\n                value={SettingsSection.getFieldValue(field.id)}\r\n                type={field.inputType}\r\n                {...field.events}\r\n                onChange={e => {\r\n                    setValue(e.currentTarget.value)\r\n                    field.events.onChange?.(e)\r\n                }}\r\n            />\r\n        )\r\n    }\r\n    private SettingDropdownField = (field: DropdownField) => {\r\n        const [value, setValue] = this.useStateFor<number>(field.id)\r\n\r\n        return (\r\n            <select\r\n                className=\"main-dropDown-dropDown\"\r\n                id={field.id}\r\n                {...field.events}\r\n                onChange={e => {\r\n                    setValue(e.currentTarget.selectedIndex)\r\n                    field.events.onChange?.(e)\r\n                }}\r\n            >\r\n                {field.options.map((option, i) => (\r\n                    <option selected={i === SettingsSection.getFieldValue(field.id)} value={i + 1}>\r\n                        {option}\r\n                    </option>\r\n                ))}\r\n            </select>\r\n        )\r\n    }\r\n\r\n    private SettingHidden = () => <></>\r\n}\r\n\r\nexport const enum FieldType {\r\n    HIDDEN = \"hidden\",\r\n    INPUT = \"input\",\r\n    DROPDOWN = \"dropdown\",\r\n    BUTTON = \"button\",\r\n    TOGGLE = \"toggle\",\r\n}\r\n\r\nexport interface BaseField<A> {\r\n    id: string\r\n    type: FieldType\r\n    description: string\r\n}\r\n\r\nexport interface ButtonField extends BaseField<never> {\r\n    type: FieldType.BUTTON\r\n    text: string\r\n    events: Partial<React.ButtonHTMLAttributes<HTMLButtonElement>>\r\n}\r\n\r\nexport interface ToggleField extends BaseField<boolean> {\r\n    type: FieldType.TOGGLE\r\n    events: Partial<React.InputHTMLAttributes<HTMLInputElement>>\r\n}\r\n\r\nexport interface InputField extends BaseField<string> {\r\n    type: FieldType.INPUT\r\n    inputType: string\r\n    events: Partial<React.InputHTMLAttributes<HTMLInputElement>>\r\n}\r\n\r\nexport interface DropdownField extends BaseField<number> {\r\n    type: FieldType.DROPDOWN\r\n    options: string[]\r\n    events: Partial<React.SelectHTMLAttributes<HTMLSelectElement>>\r\n}\r\n\r\nexport interface HiddenField extends BaseField<any> {\r\n    type: FieldType.HIDDEN\r\n}\r\n\r\nexport type SettingsField = HiddenField | DropdownField | InputField | ButtonField | ToggleField\r\n",
  "import { task } from \"fp-ts\"\r\nimport { constVoid } from \"fp-ts/function\"\r\nimport React, { useState } from \"react\"\r\nimport ReactDOM from \"react-dom\"\r\nimport { guard4, is } from \"./fp\"\r\nimport { sleep } from \"./util\"\r\n\r\nexport class SettingsSection {\r\n    private stopHistoryListener: any\r\n    private setRerender: Function | null = null\r\n\r\n    constructor(\r\n        public name: string,\r\n        public sectionId: string,\r\n        public sectionFields: { [key: string]: SettingsField } = {},\r\n    ) {}\r\n\r\n    static waitForReact = async () => {\r\n        while (!(Spicetify.React && Spicetify.ReactDOM)) sleep(100)\r\n        return this\r\n    }\r\n\r\n    pushSettings = async () => {\r\n        while (!Spicetify?.Platform?.History?.listen) await sleep(100)\r\n\r\n        if (this.stopHistoryListener) this.stopHistoryListener()\r\n\r\n        this.stopHistoryListener = Spicetify.Platform.History.listen(({ pathname = \"\" }) => {\r\n            if (pathname === \"/preferences\") this.render()\r\n        })\r\n\r\n        if (Spicetify.Platform.History.location.pathname === \"/preferences\") await this.render()\r\n    }\r\n\r\n    toObject = () =>\r\n        new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop) => SettingsSection.getFieldValue(this.getId(prop.toString())),\r\n            },\r\n        )\r\n\r\n    rerender = () => {\r\n        if (this.setRerender) this.setRerender(Math.random())\r\n    }\r\n\r\n    private render = async () => {\r\n        while (!document.getElementById(\"desktop.settings.selectLanguage\")) {\r\n            if (Spicetify.Platform.History.location.pathname !== \"/preferences\") return\r\n            await sleep(100)\r\n        }\r\n\r\n        const allSettingsContainer = document.querySelector(\".x-settings-container\")!\r\n\r\n        let pluginSettingsContainer = Array.from(allSettingsContainer.children).find(({ id }) => id === this.sectionId)\r\n\r\n        if (!pluginSettingsContainer) {\r\n            pluginSettingsContainer = document.createElement(\"div\")\r\n            pluginSettingsContainer.id = this.sectionId\r\n            pluginSettingsContainer.className = \"settingsContainer\"\r\n            allSettingsContainer.appendChild(pluginSettingsContainer)\r\n        }\r\n\r\n        ReactDOM.render(<this.FieldsContainer />, pluginSettingsContainer)\r\n    }\r\n\r\n    addButton = (\r\n        nameId: string,\r\n        description: string,\r\n        text: string,\r\n        onClick: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void = constVoid,\r\n        events: ButtonField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        events.onClick = onClick\r\n\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.BUTTON,\r\n            description,\r\n            text,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addToggle = (\r\n        nameId: string,\r\n        description: string,\r\n        defaultValue = task.of(true),\r\n        onChange: (e: React.ChangeEvent<HTMLInputElement>) => void = constVoid,\r\n        events: ToggleField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.TOGGLE,\r\n            description,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addInput = (\r\n        nameId: string,\r\n        description: string,\r\n        defaultValue: task.Task<string>,\r\n        onChange: (e: React.ChangeEvent<HTMLInputElement>) => void = constVoid,\r\n        inputType = \"text\",\r\n        events: InputField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.INPUT,\r\n            description,\r\n            inputType,\r\n            events,\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    addDropDown = (\r\n        nameId: string,\r\n        description: string,\r\n        options: string[],\r\n        defaultValue = task.of(0),\r\n        onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void = constVoid,\r\n        events: DropdownField[\"events\"] = {},\r\n    ) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        events.onChange = onChange\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.DROPDOWN,\r\n            description,\r\n            options,\r\n            events,\r\n        }\r\n        return this\r\n    }\r\n\r\n    addHidden = (nameId: string, defaultValue: any) => {\r\n        const id = this.getId(nameId)\r\n\r\n        SettingsSection.setDefaultFieldValue(id, defaultValue)\r\n\r\n        this.sectionFields[nameId] = {\r\n            id,\r\n            type: FieldType.HIDDEN,\r\n            description: \"\",\r\n        }\r\n        return this\r\n    }\r\n\r\n    getId = (nameId: string) => `extensions:${this.sectionId}:${nameId}`\r\n\r\n    private useStateFor = <A,>(id: string) => {\r\n        const [value, setValueState] = useState(SettingsSection.getFieldValue<A>(id))\r\n\r\n        return [\r\n            value,\r\n            (newValue: A) => {\r\n                if (newValue !== undefined) {\r\n                    setValueState(newValue)\r\n                    SettingsSection.setFieldValue(id!, newValue)\r\n                }\r\n            },\r\n        ] as const\r\n    }\r\n\r\n    static getFieldValue = <R,>(id: string): R => {\r\n        return JSON.parse(Spicetify.LocalStorage.get(id) ?? \"null\") // \"null\" is parsed as null, the more you know\r\n    }\r\n\r\n    static setFieldValue = (id: string, newValue: any) => {\r\n        Spicetify.LocalStorage.set(id, JSON.stringify(newValue))\r\n    }\r\n\r\n    private static setDefaultFieldValue = async (id: string, defaultValue: task.Task<any>) => {\r\n        if (SettingsSection.getFieldValue(id) === null) SettingsSection.setFieldValue(id, await defaultValue())\r\n    }\r\n\r\n    private FieldsContainer = () => {\r\n        const [rerender, setRerender] = useState<number>(0)\r\n        this.setRerender = setRerender\r\n\r\n        return (\r\n            <div className=\"x-settings-section\" key={rerender}>\r\n                <h2 className=\"Type__TypeElement-sc-goli3j-0 TypeElement-cello-textBase-type\">{this.name}</h2>\r\n                {Object.entries(this.sectionFields).map(([nameId, field]) => {\r\n                    return <this.Field field={field} />\r\n                })}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    private Field = ({ field }: { field: SettingsField }) => {\r\n        const isType = is<SettingsField>(\"type\")\r\n\r\n        return (\r\n            <div className=\"x-settings-row\">\r\n                <this.SettingDescription id={field.id} description={field.description} />\r\n                <div className=\"x-settings-secondColumn\">\r\n                    {guard4([\r\n                        [isType<InputField>(FieldType.INPUT), this.SettingInputField],\r\n                        [isType(FieldType.BUTTON), this.SettingButtonField],\r\n                        [isType(FieldType.TOGGLE), this.SettingToggleField],\r\n                        [isType(FieldType.DROPDOWN), this.SettingDropdownField],\r\n                    ])(this.SettingHidden)(field)}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    private SettingDescription = ({ id, description }: { id: string; description: string }) => (\r\n        <div className=\"x-settings-firstColumn\">\r\n            <label className=\"Type__TypeElement-sc-goli3j-0 TypeElement-viola-textSubdued-type\" htmlFor={id}>\r\n                {description}\r\n            </label>\r\n        </div>\r\n    )\r\n\r\n    private SettingButtonField = (field: ButtonField) => (\r\n        <span className=\"\">\r\n            <button\r\n                id={field.id}\r\n                className=\"Button-sc-y0gtbx-0 Button-sm-buttonSecondary-useBrowserDefaultFocusStyle x-settings-button\"\r\n                {...field.events}\r\n                type={field.type}\r\n            >\r\n                {field.text}\r\n            </button>\r\n        </span>\r\n    )\r\n\r\n    private SettingToggleField = (field: ToggleField) => {\r\n        const [value, setValue] = this.useStateFor<boolean>(field.id)\r\n\r\n        return (\r\n            <label className=\"x-settings-secondColumn x-toggle-wrapper\">\r\n                <input\r\n                    id={field.id}\r\n                    className=\"x-toggle-input\"\r\n                    type=\"checkbox\"\r\n                    checked={SettingsSection.getFieldValue(field.id)}\r\n                    {...field.events}\r\n                    onChange={e => {\r\n                        setValue(e.currentTarget.checked)\r\n                        field.events.onChange?.(e)\r\n                    }}\r\n                />\r\n                <span className=\"x-toggle-indicatorWrapper\">\r\n                    <span className=\"x-toggle-indicator\"></span>\r\n                </span>\r\n            </label>\r\n        )\r\n    }\r\n\r\n    private SettingInputField = (field: InputField) => {\r\n        const [value, setValue] = this.useStateFor<string>(field.id)\r\n\r\n        return (\r\n            <input\r\n                className=\"x-settings-input\"\r\n                id={field.id}\r\n                dir=\"ltr\"\r\n                value={SettingsSection.getFieldValue(field.id)}\r\n                type={field.inputType}\r\n                {...field.events}\r\n                onChange={e => {\r\n                    setValue(e.currentTarget.value)\r\n                    field.events.onChange?.(e)\r\n                }}\r\n            />\r\n        )\r\n    }\r\n    private SettingDropdownField = (field: DropdownField) => {\r\n        const [value, setValue] = this.useStateFor<number>(field.id)\r\n\r\n        return (\r\n            <select\r\n                className=\"main-dropDown-dropDown\"\r\n                id={field.id}\r\n                {...field.events}\r\n                onChange={e => {\r\n                    setValue(e.currentTarget.selectedIndex)\r\n                    field.events.onChange?.(e)\r\n                }}\r\n            >\r\n                {field.options.map((option, i) => (\r\n                    <option selected={i === SettingsSection.getFieldValue(field.id)} value={i + 1}>\r\n                        {option}\r\n                    </option>\r\n                ))}\r\n            </select>\r\n        )\r\n    }\r\n\r\n    private SettingHidden = () => <></>\r\n}\r\n\r\nexport const enum FieldType {\r\n    HIDDEN = \"hidden\",\r\n    INPUT = \"input\",\r\n    DROPDOWN = \"dropdown\",\r\n    BUTTON = \"button\",\r\n    TOGGLE = \"toggle\",\r\n}\r\n\r\nexport interface BaseField<A> {\r\n    id: string\r\n    type: FieldType\r\n    description: string\r\n}\r\n\r\nexport interface ButtonField extends BaseField<never> {\r\n    type: FieldType.BUTTON\r\n    text: string\r\n    events: Partial<React.ButtonHTMLAttributes<HTMLButtonElement>>\r\n}\r\n\r\nexport interface ToggleField extends BaseField<boolean> {\r\n    type: FieldType.TOGGLE\r\n    events: Partial<React.InputHTMLAttributes<HTMLInputElement>>\r\n}\r\n\r\nexport interface InputField extends BaseField<string> {\r\n    type: FieldType.INPUT\r\n    inputType: string\r\n    events: Partial<React.InputHTMLAttributes<HTMLInputElement>>\r\n}\r\n\r\nexport interface DropdownField extends BaseField<number> {\r\n    type: FieldType.DROPDOWN\r\n    options: string[]\r\n    events: Partial<React.SelectHTMLAttributes<HTMLSelectElement>>\r\n}\r\n\r\nexport interface HiddenField extends BaseField<any> {\r\n    type: FieldType.HIDDEN\r\n}\r\n\r\nexport type SettingsField = HiddenField | DropdownField | InputField | ButtonField | ToggleField\r\n",
  "import { task } from \"fp-ts\"\r\nimport { SettingsSection } from \"../../shared/settings\"\r\nimport { createPlatFolder } from \"../../shared/api\"\r\nimport { SpotifyURI } from \"../../shared/util\"\r\n\r\nconst SORTED_PLAYLISTS_FOLDER_NAME = \"Sorted Playlists\"\r\n\r\nconst settings = new SettingsSection(\"Sort+\", \"sort-plus\")\r\n    .addToggle(\"descending\", \"Descending\", task.of(true))\r\n    .addToggle(\"artistAllDiscography\", \"All of the artist's Discography\", task.of(false))\r\n    .addToggle(\"artistTopTracks\", \"Top Tracks\")\r\n    .addToggle(\"artistPopularReleases\", \"Popular Releases\", task.of(false))\r\n    .addToggle(\"artistSingles\", \"Singles\")\r\n    .addToggle(\"artistAlbums\", \"Albums\")\r\n    .addToggle(\"artistCompilations\", \"Compilations\")\r\n    .addToggle(\"artistLikedTracks\", \"Liked Tracks\", task.of(false))\r\n    .addInput(\"lastFmUsername\", \"Last.fm Username\", task.of(\"Delusoire\"))\r\n    .addInput(\"LFMApiKey\", \"Last.fm API Key\", task.of(\"44654ea047786d90338c17331a5f5d95\"))\r\n    .addInput(\r\n        \"sortedPlaylistsFolderUri\",\r\n        \"Sorted Playlists folder uri\",\r\n        async () => (await createPlatFolder(SORTED_PLAYLISTS_FOLDER_NAME)).uri,\r\n    )\r\n\r\nsettings.pushSettings()\r\n\r\nexport const CONFIG = settings.toObject() as {\r\n    artistAllDiscography: boolean\r\n    artistTopTracks: boolean\r\n    artistPopularReleases: boolean\r\n    artistSingles: boolean\r\n    artistAlbums: boolean\r\n    artistCompilations: boolean\r\n    artistLikedTracks: boolean\r\n    descending: boolean\r\n    lastFmUsername: string\r\n    LFMApiKey: string\r\n    sortedPlaylistsFolderUri: SpotifyURI\r\n}\r\n",
  "debugger\r\n\r\nimport { array as a, eq, number, option as o, ord, string, task } from \"fp-ts\"\r\nimport { guard } from \"fp-ts-std/Function\"\r\nimport { anyPass } from \"fp-ts-std/Predicate\"\r\nimport { values } from \"fp-ts-std/Record\"\r\nimport { groupBy } from \"fp-ts/NonEmptyArray\"\r\nimport { mapWithIndex } from \"fp-ts/Record\"\r\nimport { constTrue, constant, flow as f, identity, pipe as p, tupled } from \"fp-ts/function\"\r\nimport { startsWith } from \"fp-ts/string\"\r\nimport { Lens, Optional } from \"monocle-ts\"\r\nimport { set } from \"spectacles-ts\"\r\nimport {\r\n    createSPPlaylistFromTracks,\r\n    fetchGQLAlbum,\r\n    fetchGQLArtistDiscography,\r\n    fetchGQLArtistOverview,\r\n    fetchPlatArtistLikedTracks,\r\n    fetchPlatFolder,\r\n    fetchPlatLikedTracks,\r\n    fetchPlatPlaylistContents,\r\n    fetchPlatRootFolder,\r\n    fetchTrackLFMAPI,\r\n    fetchWebAlbumsSpot,\r\n    fetchWebArtistsSpot,\r\n    fetchWebPlaylistsSpot,\r\n    fetchWebTracksSpot,\r\n    movePlatPlaylistTracks,\r\n    setPlatPlaylistVisibility,\r\n} from \"../../shared/api\"\r\nimport { objConcat, pMchain, tapAny, withProgress } from \"../../shared/fp\"\r\nimport {\r\n    TrackData,\r\n    TracksPopulater,\r\n    parseAPITrackFromPlaylist,\r\n    parseAPITrackFromSpotify,\r\n    parsePlatLikedTracks,\r\n    parsePlatTrackFromArtistLikedTracks,\r\n    parseTopTrackFromArtist,\r\n    parseTrackFromAlbum,\r\n} from \"../../shared/parse\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, createQueueItem, setPlayingContext, setQueue } from \"../../shared/util\"\r\nimport { CONFIG } from \"./settings\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nenum SortBy {\r\n    SPOTIFY_PLAYCOUNT = \"Spotify - Play Count\",\r\n    SPOTIFY_POPULARITY = \"Spotify - Popularity\",\r\n    SPOTIFY_RELEASEDATE = \"Spotify - Release Date\",\r\n    LASTFM_SCROBBLES = \"LastFM - Scrobbles\",\r\n    LASTFM_PERSONALSCROBBLES = \"LastFM - My Scrobbles\",\r\n    LASTFM_PLAYCOUNT = \"LastFM - Play Count\",\r\n}\r\n\r\nenum SortProp {\r\n    \"Spotify - Play Count\" = \"playcount\",\r\n    \"Spotify - Popularity\" = \"popularity\",\r\n    \"Spotify - Release Date\" = \"releaseDate\",\r\n    \"LastFM - Scrobbles\" = \"scrobbles\",\r\n    \"LastFM - My Scrobbles\" = \"personalScrobbles\",\r\n    \"LastFM - Play Count\" = \"lastfmPlaycount\",\r\n}\r\n\r\n// Fetching Tracks\r\n\r\nconst getAlbumTracks = async (uri: SpotifyURI) => {\r\n    const albumRes = await fetchGQLAlbum(uri)\r\n    const releaseDate = new Date(albumRes.date.isoString).getTime()\r\n\r\n    return p(\r\n        albumRes.tracks.items,\r\n        a.map(\r\n            f(\r\n                parseTrackFromAlbum,\r\n                set(\"albumUri\", albumRes.uri),\r\n                set(\"albumName\", albumRes.name),\r\n                set(\"releaseDate\", releaseDate),\r\n            ),\r\n        ),\r\n    )\r\n}\r\n\r\nconst getPlaylistTracks = f(fetchPlatPlaylistContents, pMchain(a.map(parseAPITrackFromPlaylist)))\r\n\r\nasync function getArtistTracks(uri: SpotifyURI) {\r\n    const extractUriFromReleases = (x: { releases: { items: Array<{ uri: SpotifyURI }> } }) => x.releases.items[0].uri\r\n    const getTracksFromAlbums = f(a.map(getAlbumTracks), ps => Promise.all(ps), pMchain(a.flatten))\r\n\r\n    const allTracks = new Array<TrackData | Promise<TrackData>>()\r\n\r\n    const add = (tracks: TrackData[]) => {\r\n        allTracks.push(...tracks)\r\n    }\r\n\r\n    const albumsLike = []\r\n    const albumsLikeReleases = []\r\n\r\n    if (CONFIG.artistAllDiscography) {\r\n        const disc = await fetchGQLArtistDiscography(uri)\r\n        albumsLikeReleases.push(...disc)\r\n    } else {\r\n        const disc = (await fetchGQLArtistOverview(uri)).discography\r\n\r\n        if (CONFIG.artistLikedTracks) {\r\n            const likedTracks = await fetchPlatArtistLikedTracks(uri)\r\n            p(likedTracks, a.map(parsePlatTrackFromArtistLikedTracks), add)\r\n        }\r\n\r\n        if (CONFIG.artistTopTracks)\r\n            p(\r\n                disc.topTracks.items,\r\n                a.map(i => i.track),\r\n                a.map(parseTopTrackFromArtist),\r\n                add,\r\n            )\r\n\r\n        if (CONFIG.artistPopularReleases) albumsLike.push(...disc.popularReleasesAlbums.items.map(r => r.uri))\r\n        if (CONFIG.artistSingles) albumsLikeReleases.push(...disc.singles.items)\r\n        if (CONFIG.artistAlbums) albumsLikeReleases.push(...disc.albums.items)\r\n        if (CONFIG.artistCompilations) albumsLikeReleases.push(...disc.compilations.items)\r\n    }\r\n\r\n    albumsLike.push(...albumsLikeReleases.map(extractUriFromReleases))\r\n    await p(albumsLike, getTracksFromAlbums, pMchain(add))\r\n\r\n    return await Promise.all(allTracks)\r\n}\r\n\r\n// ------------- For populateTracksSpot -------------\r\nconst fetchAPITracksFromTracks: TracksPopulater = f(\r\n    a.map(({ uri }) => URI.fromString(uri)!.id!),\r\n    fetchWebTracksSpot,\r\n    pMchain(a.map(parseAPITrackFromSpotify)),\r\n)\r\n\r\nconst fetchAlbumTracksFromTracks: TracksPopulater = f(\r\n    groupBy(track => track.albumUri!),\r\n    withProgress(mapWithIndex<SpotifyURI, TrackData[], Promise<TrackData[]>>)(async (albumUri, tracks) => {\r\n        const uriEq = p(\r\n            string.Eq,\r\n            eq.contramap((t: TrackData) => t.uri),\r\n        )\r\n\r\n        const albumTracks = await getAlbumTracks(albumUri)\r\n\r\n        return a.intersection(uriEq)(albumTracks, tracks)\r\n    }),\r\n    values,\r\n    ps => Promise.all(ps),\r\n    pMchain(a.flatten),\r\n)\r\n// --------------------------------------------------\r\n\r\nconst populateTracksSpot = (propName: keyof typeof SortProp) => (tracks: TrackData[]) =>\r\n    p(\r\n        tracks,\r\n        a.filter(f(toOptProp(propName), o.isNone)),\r\n        guard([[startsWith(SortBy.SPOTIFY_PLAYCOUNT), constant(fetchAlbumTracksFromTracks)]])(\r\n            constant(fetchAPITracksFromTracks),\r\n        )(propName),\r\n        pMchain(a.concat(tracks)),\r\n        pMchain(groupBy(Lens.fromProp<TrackData>()(\"uri\").get)),\r\n        pMchain(values<TrackData[]>),\r\n        pMchain(a.map(objConcat<TrackData>())),\r\n    )\r\n\r\nconst populateTrackLastFM = async (track: TrackData) => {\r\n    const lastfmTrack = (await fetchTrackLFMAPI(CONFIG.LFMApiKey, track.artistName, track.name, CONFIG.lastFmUsername))\r\n        .track\r\n    track.lastfmPlaycount = Number(lastfmTrack.listeners)\r\n    track.scrobbles = Number(lastfmTrack.playcount)\r\n    track.personalScrobbles = Number(lastfmTrack.userplaycount)\r\n    return track\r\n}\r\n\r\n// Fetching, Sorting and Playing\r\n\r\nconst fetchTracks = f(\r\n    tapAny(uri => void (lastFetchedUri = uri)),\r\n    guard<SpotifyURI, Promise<TrackData[]>>([\r\n        [URI.isAlbum, getAlbumTracks],\r\n        [URI.isArtist, getArtistTracks],\r\n        [URI.isPlaylistV1OrV2, getPlaylistTracks],\r\n        [URI.isCollection, f(fetchPlatLikedTracks, pMchain(a.map(parsePlatLikedTracks)))],\r\n    ])(task.of([])),\r\n)\r\n\r\nconst populateTracks = guard<keyof typeof SortProp, TracksPopulater>([\r\n    [startsWith(\"Spotify\"), populateTracksSpot],\r\n    [\r\n        startsWith(\"LastFM\"),\r\n        constant(f(p(withProgress(a.map<TrackData, Promise<TrackData>>)(populateTrackLastFM)), ps => Promise.all(ps))),\r\n    ],\r\n])(constant(task.of([])))\r\n\r\nlet lastSortedQueue: TrackData[] = []\r\n;(globalThis as any).lastSortedQueue = lastSortedQueue\r\nconst _setQueue = (inverted: boolean) => async (queue: TrackData[]) => {\r\n    if (Spicetify.Platform.PlayerAPI._queue._queue === null)\r\n        return void Spicetify.showNotification(\"Queue is null!\", true)\r\n\r\n    const uriOrd = p(\r\n        string.Ord,\r\n        ord.contramap((t: TrackData) => t.uri),\r\n    )\r\n\r\n    lastSortedQueue = p(queue, a.uniq(uriOrd), inverted ? a.reverse : identity)\r\n    console.log(\" ~ file: app.tsx:217 ~ const_setQueue= ~ inverted:\", inverted)\r\n    console.log(\" ~ file: app.tsx:217 ~ const_setQueue= ~ lastSortedQueue:\", lastSortedQueue)\r\n    ;(globalThis as any).lastSortedQueue = lastSortedQueue\r\n\r\n    const isQueued = URI.isCollection(lastFetchedUri)\r\n\r\n    await p(\r\n        lastSortedQueue,\r\n        a.map(t => t.uri),\r\n        a.concat([\"spotify:separator\"]),\r\n        a.map(createQueueItem(isQueued)),\r\n        setQueue,\r\n    )\r\n    if (!isQueued) await setPlayingContext(lastFetchedUri)\r\n    await Spicetify.Platform.PlayerAPI.skipToNext()\r\n}\r\n\r\nconst toOptProp = (prop: keyof typeof SortProp) => Optional.fromNullableProp<TrackData>()(SortProp[prop]).getOption\r\n\r\nlet lastFetchedUri: SpotifyURI\r\nlet lastActionName: keyof typeof SortProp | \"True Shuffle\" | \"Stars\"\r\nconst sortByProp = (name: keyof typeof SortProp) => async (uri: SpotifyURI) => {\r\n    lastActionName = name\r\n    const descending = invertOrder ^ Number(CONFIG.descending)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ descending:\", descending)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ invertOrder:\", invertOrder)\r\n    console.log(\" ~ file: app.tsx:236 ~ sortByProp ~ CONFIG.descending:\", CONFIG.descending)\r\n\r\n    const propOrd = p(\r\n        number.Ord,\r\n        ord.contramap((t: Required<TrackData>) => t[SortProp[name]]),\r\n    )\r\n\r\n    p(\r\n        uri,\r\n        fetchTracks,\r\n        pMchain(populateTracks(name)),\r\n        pMchain(a.map(x => (p(x, toOptProp(name), o.isSome) ? o.some(x as Required<TrackData>) : o.none))),\r\n        pMchain(a.sequence(o.Applicative)),\r\n        pMchain(o.map(a.sort(propOrd))),\r\n        pMchain(o.map(_setQueue(!!descending))),\r\n    )\r\n}\r\n\r\nlet invertOrder = 0\r\nwindow.addEventListener(\"keydown\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 1\r\n})\r\n\r\nwindow.addEventListener(\"keyup\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 0\r\n})\r\n\r\n// Menu\r\n\r\nconst fetchSortQueue =\r\n    (name: typeof lastActionName, sortFn: (tracksIn: TrackData[]) => TrackData[]) =>\r\n    ([uri]: [SpotifyURI]) => {\r\n        lastActionName = name\r\n        const descending = invertOrder ^ Number(CONFIG.descending)\r\n        p(uri, fetchTracks, pMchain(sortFn), pMchain(_setQueue(!!descending)))\r\n    }\r\n\r\nconst shuffle = <A,>(array: A[], l = array.length): A[] =>\r\n    l == 0 ? [] : [array.splice(Math.floor(Math.random() * l), 1)[0], ...shuffle(array)]\r\nconst shuffleSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"True Shuffle\",\r\n    fetchSortQueue(\"True Shuffle\", shuffle) as any,\r\n    constTrue,\r\n    \"shuffle\",\r\n    false,\r\n)\r\n\r\nconst starsOrd = p(\r\n    number.Ord,\r\n    ord.contramap((t: { uri: SpotifyURI }) => (globalThis as any).tracksRatings[t.uri] ?? 0),\r\n)\r\nconst starsSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"Stars\",\r\n    fetchSortQueue(\"Stars\", a.sort(starsOrd)) as any,\r\n    () => (globalThis as any).tracksRatings !== undefined,\r\n    \"heart-active\",\r\n    false,\r\n)\r\n\r\nconst createSortByPropSubmenu = (name: keyof typeof SortProp, icon: any) =>\r\n    new Spicetify.ContextMenu.Item(name, tupled(sortByProp(name)) as any, constTrue, icon, false)\r\n\r\nnew Spicetify.ContextMenu.SubMenu(\r\n    \"Sort by\",\r\n    a\r\n        .zipWith(\r\n            values(SortBy),\r\n            [\"play\", \"heart\", \"list-view\", \"volume\", \"artist\", \"subtitles\"],\r\n            createSortByPropSubmenu,\r\n        )\r\n        .concat([shuffleSubmenu, starsSubmenu]),\r\n    tupled(anyPass([URI.isAlbum, URI.isArtist, URI.isPlaylistV1OrV2, URI.isCollection])) as any,\r\n).register()\r\n\r\n// Topbar\r\n\r\nconst generatePlaylistName = async () => {\r\n    const uriToId = (uri: SpotifyURI) => URI.fromString(uri)!.id!\r\n    const getName = (fn: Function) => async (id: SpotifyID) => (await fn([id]))[0].name\r\n\r\n    const collectionName = await guard([\r\n        [URI.isAlbum, f(uriToId, getName(fetchWebAlbumsSpot))],\r\n        [URI.isArtist, f(uriToId, getName(fetchWebArtistsSpot))],\r\n        [URI.isPlaylistV1OrV2, f(uriToId, getName(fetchWebPlaylistsSpot))],\r\n        [URI.isCollection, task.of(\"Liked Tracks\")],\r\n    ])(task.of(\"Unresolved\"))(lastFetchedUri)\r\n\r\n    return `${collectionName} - ${lastActionName}`\r\n}\r\nnew Spicetify.Topbar.Button(\"Add Sorted Queue to Sorted Playlists\", \"plus2px\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n\r\n    const sortedPlaylistsFolder = await fetchPlatFolder(CONFIG.sortedPlaylistsFolderUri).catch(fetchPlatRootFolder)\r\n\r\n    const playlistName = await generatePlaylistName()\r\n\r\n    const { uri } = await createSPPlaylistFromTracks(\r\n        playlistName,\r\n        lastSortedQueue.map(t => t.uri),\r\n        sortedPlaylistsFolder.uri,\r\n    )\r\n\r\n    setPlatPlaylistVisibility(uri, false)\r\n\r\n    Spicetify.showNotification(`Playlist ${playlistName} created`)\r\n})\r\n\r\nnew Spicetify.Topbar.Button(\"Reorder Playlist with Sorted Queue\", \"chart-down\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n    if (!URI.isPlaylistV1OrV2(lastFetchedUri))\r\n        return void Spicetify.showNotification(\"Last sorted queue must be a playlist\")\r\n\r\n    p(\r\n        lastSortedQueue as unknown as Array<{ uid: string }>,\r\n        withProgress(a.map<{ uid: string }, void>)(\r\n            t => void movePlatPlaylistTracks(lastFetchedUri, [t], SpotifyLoc.after.end()),\r\n        ),\r\n    )\r\n})\r\n"
  ],
  "mappings": "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",
  "debugId": "A6CA769A8E8EF6FB64756e2164756e21",
  "names": []
}